[{"title":"2020就这么过去了呀","url":"/2020/12/31/2020%E5%B0%B1%E8%BF%99%E4%B9%88%E8%BF%87%E5%8E%BB%E4%BA%86%E5%91%80/","content":"<p>今天就是2020年最后一天，说真的，没想到今年就这么过去了~</p>\n<span id=\"more\"></span> \n<p>我很清晰记得，2020年1月3日从天津回家，距离我上次回家，已经过去了10个月。回到家完成毕业设计，等待考研结果，提前准备复试 ，一切都是顺其自然。</p>\n<p>直到除夕前一天，武汉封城，让整个2020变得不太一样。我从来没想过一个城市会被封锁，而且整整是76天。疫情直到现在还没完全消散。坦白说，如果今年不是因为疫情扩招的话，或许，我会有另外一条路，可能会调剂到另外一所学校，也可能去工作，人生就是这么充满不确定性才有意思吧。</p>\n<p>上了研究生，其实发现并没有对学术有太大兴趣，读研的目的更多的是让我缓两年半时间进入社会。研究生期间也许没有什么大成果出来，但是我认为一定可以锻炼自己的思维能力。在这个期间除了完成必要的学术工作，还是有很多自己的时间去学其他东西，静下心下来学习永远都是非常有必要的，沉淀自己才能有资本拿到更好的资源。</p>\n<p>在今年年初，开启了理财之路（购买基金），二十二岁有理财意识还是可贵的（虽然之前也会把钱放进余额宝，但是余额宝没什么意思），回头去看今年的收益，还是比较满意的，虽然本金不多，但是我相信复利所带来的魔力。当然，永远都要敬畏市场，不要跟风投资，要多学习，不要去挣认知以外的钱，不然迟早亏回去。</p>\n<p>开学的时候看了一本书叫《我的二本学生》，很焦虑，因为我也是普普通通的二本学生，二本研究生。但是不要紧，心态一定要放好，保持谦逊，保持学习。</p>\n<p>大量去阅读是快速让自己学习的一个方式之一，毕竟别人可能花了一辈子的研究写出来，而我们只需要花点钱就可以买来别人毕生的知识。所以在2021也要多阅读，如果有能力，也希望能够在学术上有成果，最后用乔布斯的一句话来结束这个不一样的2020年吧。</p>\n<p>Stay hungry，Stay foolish.</p>\n","categories":["杂谈"]},{"title":"6.16毕业回顾","url":"/2020/06/24/6.16%E6%AF%95%E4%B8%9A%E5%9B%9E%E9%A1%BE/","content":"<p>2020年6月16日这天，天气晴朗，过完这一天，就再也不是本科生了。</p>\n<span id=\"more\"></span>\n\n<p>这一天学位授予仪式如期进行，仪式感是一个很重要的东西，因为这样使得这一天与众不同，当老师为你拨穗与你握手并对你说祝贺你的那一刻，你会发现有一种成就感。</p>\n<p>四年真的一眨眼就过去了，这四年发现真的过得好快乐，虽然没有做班干部，没有参加社团，但是每天就看看书，学学习，和同学聊聊天的日子也太无忧无虑吧，作为一个南方人到北方生活居然没有一点不适应。唯一比较遗憾的是当我毕业的时候学校才装上了空调。不过也没太大关系，反正读研还在这里。</p>\n<p>这一天下午还与研究生导师第一次见面进行面试，两天之后收到老师的邮件同意我跟他学习，发了个朋友圈记录了一下。</p>\n<p>更疯狂的是，晚上和同学去爬泰山，去到泰安的时候我这一天已经走了2万步了，真的快累到不行了，然后还是从晚上十点走到第二天四点，这是我大学第一次熬夜，走上南天门都是迷离糊涂的，这一天下雨虽然没有看到日出，但是很难忘，几个同学一起在山上回忆了好多事。</p>\n<p>毕业其实并不快乐，也不敢祝你前程似锦，毕竟走进社会你会发现真的很难，所以还是坚信多读书没有什么错，教育一定是最好的投资！<br><img src=\"/images/university/3.jpg\" alt=\"纪念\"></p>\n","categories":["大学"],"tags":["本科毕业"]},{"title":"Docker下安装nginx和php","url":"/2022/01/10/Docker%E4%B8%8B%E5%AE%89%E8%A3%85nginx-php/","content":"<p>记录用docker安装nginx以及php</p>\n<span id=\"more\"></span> \n<h1 id=\"nginx\"><a href=\"#nginx\" class=\"headerlink\" title=\"nginx\"></a>nginx</h1><p>首先要创建一个nginx，不挂载任何目录，主要目的是为了先拷贝里面生成的文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run  --name nginx -d -p 80:80 nginx</span><br></pre></td></tr></table></figure>\n<p>然后把文件复制出来，注意这个bae只是一个例子而已，需要你docker ps查询你的id是什么，前面路径是docker下的，后面是你主机下的路径</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker cp bae:/etc/nginx/nginx.conf /etc/nginx/conf/</span><br><span class=\"line\">docker cp bae:/etc/nginx/conf.d /etc/nginx/conf/</span><br><span class=\"line\">docker cp bae:/usr/share/nginx/html/ /etc/nginx/html/</span><br><span class=\"line\">docker cp bae:/var/log/nginx/ /etc/nginx/log/</span><br><span class=\"line\">注：docker cp dbc 中的 &quot;bae&quot; 为容器ID前缀，只要唯一就好了，用docker ps查询</span><br></pre></td></tr></table></figure>\n<p>然后删除nginx镜像，重新创建一个</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run  --name nginx -d -p 80:80 -v /etc/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /etc/nginx/conf/conf.d/default.conf:/etc/nginx/conf.d/default.conf  -v /etc/nginx/log:/var/log/nginx  -v /etc/nginx/html:/usr/share/nginx/html  nginx</span><br></pre></td></tr></table></figure>\n\n<p>可以把项目放在html文件夹内</p>\n<h1 id=\"php\"><a href=\"#php\" class=\"headerlink\" title=\"php\"></a>php</h1><p>因为9000端口给了portainer，所以宿主机端口改成9002</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 9002:9000 --name php -v /etc/nginx/html:/usr/share/nginx/www php:fpm</span><br></pre></td></tr></table></figure>\n<p>另外，需要查看docker内运行的ip地址，把nginx中的default.conf的php部分改成下面格式，172.17.0.4是docker下的ip地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim /etc/nginx/conf.d/default.conf</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">        root   /usr/share/nginx/html;</span><br><span class=\"line\">        index  index.html index.htm index.php;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">    fastcgi_pass   172.17.0.4:9000; </span><br><span class=\"line\">    fastcgi_index  index.php;</span><br><span class=\"line\">    fastcgi_param  SCRIPT_FILENAME  /usr/share/nginx/www$fastcgi_script_name;</span><br><span class=\"line\">    fastcgi_param  SCRIPT_NAME      $fastcgi_script_name;</span><br><span class=\"line\">    include        fastcgi_params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，docker内部的IP是可能变化的，如果发现你的php项目无法识别，请检查一下docker内IP，并重新编辑上面的文件</p>\n<h1 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h1><p>写一个index.php文件放入html文件夹中</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> <span class=\"title function_ invoke__\">phpinfo</span>();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>"},{"title":"Github笔记","url":"/2021/12/04/Github%E7%AC%94%E8%AE%B0/","content":"<p>记录Github操作的笔记,来源于《Github入门与实践》。</p>\n<span id=\"more\"></span> \n<p>Tips：国内经常打不开Github，发现一个不错的<a href=\"https://github.com/521xueweihan/GitHub520\">项目</a>可以解决这个问题，或者使用UU加速器的学术资源加速，cmd刷新DNS命令：ipconfig &#x2F;flushdns。</p>\n<h1 id=\"需要掌握的语法\"><a href=\"#需要掌握的语法\" class=\"headerlink\" title=\"需要掌握的语法\"></a>需要掌握的语法</h1><ol>\n<li><p>Talklist</p>\n</li>\n<li><p>GFM</p>\n</li>\n</ol>\n<h1 id=\"Github基本操作\"><a href=\"#Github基本操作\" class=\"headerlink\" title=\"Github基本操作\"></a>Github基本操作</h1><ol>\n<li><p>git init 初始化仓库( 本地创建一个文件夹，进去后然后执行本命令)。</p>\n</li>\n<li><p>git status 查看仓库状态。</p>\n</li>\n<li><p>git add 暂存区添加文件。</p>\n</li>\n<li><p>git commit保存仓库的历史记录，是将本地修改过的文件提交到本地库中。git push是将本地库中的最新信息发送给远程库。</p>\n</li>\n<li><p>git log查看提交日志。 git log –graph图表形式查看分支。</p>\n</li>\n<li><p>git diff 查看更改前后的差别。</p>\n</li>\n<li><p>不妨养成这样的好习惯，在执行 git commit命令之前先执行 git diff HEAD 命令，查看本次提交和上次提交之前有什么区别，但是如果直接执行git diff，由于工作树和暂存区的状态并没有差别，所以不会显示东西。</p>\n</li>\n<li><p>git branch 显示分支，* 代表当前分支 ，添加参数-a可以查看本地仓库和远程仓库的分支信息。</p>\n</li>\n<li><p>git checkout -b  NAME 创建NAME这个分支，并且会马上切换到这个分支。</p>\n</li>\n<li><p>git checkout master 切换到master这个分支。</p>\n</li>\n<li><p>git checkout - 切回到上一个分支，或者直接像上面一样输入名字。</p>\n</li>\n<li><p>git merge  –no-ff feature-A ，切到master上执行这个语句，并且加上 –no - ff这个参数，就可以让feature-A合并。</p>\n</li>\n<li><p>git reset –hard 哈希值，填写相应的哈希值，就可以回溯版本，git log 只能查看以当前状态为终点的历史日志。所以用git reflog 可以查看当前仓库执行过的操作日志，然后左边就是哈希值，填写命令，就可以回溯到这个历史之前的状态，就像时间穿梭，但是，需要你没有进行Git的垃圾回收功能，才可以用这个reflog功能，其实测试了下这个日志，也就是包含最近的操作过程，即便是前几天操作的。</p>\n</li>\n<li><p>合并的时候有冲突，当解决好冲突再合并，系统提交的信息是Fix conflict。而我们其实是想记录合并的信息，所以用git commit –amend去修改上次提交的信息（我的理解是相当于修改提交这次上传的备注）。</p>\n</li>\n<li><p>git commit -am “备注信息”这个命令只能提交已经追踪过且修改了的文件(也就是早就存在的文件，只是我们需要修改一点东西)，去过是新增文件就必须使用git commit -m “备注信息”的命令。直接git commit会调用vim去描述更多的信息。</p>\n</li>\n<li><p>错字漏字等失误叫typo，所以修改备注的时候填这个，搞国际化一点，与时俱进。</p>\n</li>\n<li><p>git rebase -i HEAD~2,当我们只是修改错别字时候，在历史记录里我们想把修改后的和前一次合并起来为一次完美的提交，就需要用这个，输入命令后出来编辑器，需要把第二个左边的pick改成fixup，保存后就可以了。</p>\n</li>\n<li><p>git remote add origin <a href=\"mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;\">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;</a>:本地目录名字&#x2F;仓库名字.git    就把本地添加到这个远程仓库。并把远程仓库名称设置为origin（标识符），这里有个知识，origin在git中是什么意思，百度有很详细的解答。</p>\n</li>\n<li><p>在执行完上面添加仓库，执行git push -u origin master 可以推送到远程仓库。-u参数可以在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream，添加了这个参数，以后直接git pull从远程仓库获取内容时候，本地仓库这个分支就可以直接从origin的master分支获取内容，省去了另外添加参数的麻烦。</p>\n</li>\n<li><p>推送到其他分支，在本地创建好分支A后，输入 git push -u origin 分支A ，然后就可以了。这时候github可以看到分支A。</p>\n</li>\n<li><p>现在我们假设是另外一名开发者，git clone后默认处于master分支，但是如果远程仓库还有分支A的话，我们可以git checkout -b 分支A origin&#x2F;分支A ，也就是在本地创建一个分支A，然后再从origin的分支A获取到本地仓库。</p>\n</li>\n<li><p>git pull 两个开发者如果修改同一个部分的代码，非常容易冲突，要经常pull和push操作。</p>\n</li>\n<li><p>git remote -v 查看仓库远程地址。</p>\n</li>\n<li><p>git branck -D 分支A 删除分支A。</p>\n</li>\n<li><p>rm -rf .git 删除本地仓库</p>\n</li>\n</ol>\n<h1 id=\"奇淫技巧\"><a href=\"#奇淫技巧\" class=\"headerlink\" title=\"奇淫技巧\"></a>奇淫技巧</h1><ol>\n<li><p>比较两个分支的区别这样写，比如master和test分支：<a href=\"https://github.com/MrChanGG/Hello-World/compare/master...test\">https://github.com/MrChanGG/Hello-World/compare/master...test</a></p>\n</li>\n<li><p>查看分支与前几天的差别，比如7天内：<a href=\"https://github.com/MrChanGG/Hello-World/compare/master@%7B7.day.ago%7D...master\">https://github.com/MrChanGG/Hello-World/compare/master@{7.day.ago}...master</a></p>\n</li>\n<li><p>查看指定日期与现在的差别：<a href=\"https://github.com/MrChanGG/Hello-World/compare/master@%7B2013-01-01%7D...master\">https://github.com/MrChanGG/Hello-World/compare/master@{2013-01-01}...master</a></p>\n</li>\n<li><p>GitHub 的 issue 功能，对个人而言，就如同 TODO list 。比如commit message title, #1。如果添加上close,closes,closed,fix,fixes,fixed,resolve,resolves,resolved，就会相应关闭对应issue。比如commit message title, fix #n。</p>\n</li>\n<li><p>有的人希望用diff或者patch格式来处理Pull Request，只需要这样写：<a href=\"https://github.com/MrChanGG/Hello-World/pull/2261.patch\">https://github.com/MrChanGG/Hello-World/pull/2261.patch</a> ，这里2261代表那个编号而已，举个例子用，后面添加上patch或者diff即可。</p>\n</li>\n<li><p>shift + &#x2F;显示快捷键。</p>\n</li>\n<li><p>评论中加:会启动补全表情功能。</p>\n</li>\n<li><p>在Files Changed标签中可以看到Pull Request更改的文件内容以及前后差别，默认情况下会将空格的不同高亮显示，在URL末尾添加 ?w&#x3D;1 可以不显示空格的差别。</p>\n</li>\n</ol>\n<h1 id=\"基础概念实战总结\"><a href=\"#基础概念实战总结\" class=\"headerlink\" title=\"基础概念实战总结\"></a>基础概念实战总结</h1><ol>\n<li><p>分支并不是两个文件夹的意思，比如我们需要测试新功能的时候，就创建一个分支，拷贝一份master的代码到分支，然后写新功能去测试，如果测试没有问题，就把这个分支的代码合并到master上去，也就是相当于master是稳定版本，分支就是开发版本。</p>\n</li>\n<li><p>还有一切操作在本地完成后，需要push上去，不然没有上传到Github。</p>\n</li>\n<li><p>有个有意思的操作，在本地上有个文件是README.md(从master上clone下来的)，在master上和分支A上都有这个文件(同名但是里面内容不同)，当你在本地切换分支操作的时候，本地这个文件也会随着改变(也就是里面内容改变，不过记得要先把两个仓库的内容都要Pull下来)，很有意思哦，一定要注意分支的概念不同于文件夹。</p>\n</li>\n<li><p>关于合并,合并首先是不能冲突的，比如一个文件的第一行，在master和分支A上的内容不一样，那就是有冲突。必须要消除冲突后才能合并，合并不是覆盖的意思。冲突解决后记得add和commit。</p>\n</li>\n<li><p>务必记住一定首先Pull下来，保证仓库文件和本地一样，然后全部在本地上执行，最后再push，毕竟有时候经常time out。</p>\n</li>\n<li><p>在本地修改文件后(也进行了add和commit操作，但是没有push)，回到了master进行合并并且push，这时候只是master的内容被提交，也就是分支不同，最后push不是全部提交上去，push只是管当前的分支，所以要回到分支进行push，才可以把分支修改过的内容提交上去。</p>\n</li>\n<li><p>关于回滚操作，也就是相当于穿梭回过去。打开git reflog会看到你最近的操作，reset命令加输入前面的哈希值就能退到这一步，文件内容也会相应发生变化。</p>\n</li>\n<li><p>关于创建仓库问题，我们在本地Init后所有的操作都是在本地执行，这时候我们想把这些push到一个仓库。首先要去网上创建好一个仓库，务必记得不要初始化readme.md，这样对于我们来整合仓库会有麻烦，虽然是可以强制覆盖。</p>\n</li>\n</ol>\n<h1 id=\"PR（Pull-Request）实战总结\"><a href=\"#PR（Pull-Request）实战总结\" class=\"headerlink\" title=\"PR（Pull Request）实战总结\"></a>PR（Pull Request）实战总结</h1><ol>\n<li><p>Fork仓库。</p>\n</li>\n<li><p>clone在本地。</p>\n</li>\n<li><p>新增一个特性分支，然后修改内容，最后add,commit,push。</p>\n</li>\n<li><p>打开网页版选择这个仓库，然后点击pull request后新建PR查看文件对比然后填写相关信息即可。</p>\n</li>\n<li><p>关于仓库维护（也就是更新fork的仓库）1.首先设置远程仓库：git remote add upstream 原仓库名 2.获取最新数据：git fetch upstream 3将upstream&#x2F;master与当前master合并：git merge upstream&#x2F;master</p>\n</li>\n</ol>\n<h1 id=\"接收到PR如何操作\"><a href=\"#接收到PR如何操作\" class=\"headerlink\" title=\"接收到PR如何操作\"></a>接收到PR如何操作</h1><ol>\n<li><p>首先在本地上有我们自己原始仓库的数据。</p>\n</li>\n<li><p>get remote add PR发送者 <a href=\"mailto:&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;\">&#x67;&#105;&#116;&#x40;&#x67;&#105;&#x74;&#104;&#117;&#x62;&#x2e;&#x63;&#111;&#x6d;</a>:PR发送者&#x2F;仓库名称.git，然后git fetch。 </p>\n</li>\n<li><p>然后我们自己创建一个分支用来测试建议的功能git  checkout -b pr1,这时候pr1的代码就是和原始的仓库一样。</p>\n</li>\n<li><p>git merge PR发送者&#x2F;work，合并他们的内容进行测试。</p>\n</li>\n<li><p>测试完后没问题可以删除pr1分支。</p>\n</li>\n<li><p>接受PR建议：切换到master分支，然后合并PR发送者的分支，git diff origin&#x2F;仓库名 确认本地与Github端代码差别。</p>\n</li>\n<li><p>最后git push，PR状态会close。</p>\n</li>\n</ol>\n<h1 id=\"一些开发建议\"><a href=\"#一些开发建议\" class=\"headerlink\" title=\"一些开发建议\"></a>一些开发建议</h1><ol>\n<li><p>缩小PR体积，也就是别一次性打发一堆代码提交PR，尽可能少但是提交频率多，这样别人审阅代码不会太累。</p>\n</li>\n<li><p>准备好测试环境，比如模仿一个和正式环境高度相似的演练，或者是可以进行灰度测试，也就是先推送一小部分用户测试。</p>\n</li>\n<li><p>熟悉Gitflow流程会有助于提高开发效率。</p>\n</li>\n<li><p>版本号：一般用X.Y.Z来进行版本管理。X表示重大功能变更或者新版本，此时Y和Z为0。Y代表添加或者删除某些功能。Z代表修复某些BUG的版本。</p>\n</li>\n</ol>\n","categories":["学习笔记"],"tags":["Github"]},{"title":"树莓派HomeAassistant系列（一）外网远程控制","url":"/2022/01/02/HomeAassistant%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E5%A4%96%E7%BD%91%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6/","content":"<p>HomeAassistant系列</p>\n<span id=\"more\"></span>\n<p>在<a href=\"https://chenwingsing.github.io/2021/12/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8D%E5%90%83%E7%81%B0%E8%A1%8C%E5%8A%A8/#%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F\">这篇文章</a>中已经讲了如何进行内网穿透来远程连接我们的树莓派，那么如果能够让Homeassistant也能够进行远程连接的话，那么这样会很爽。</p>\n<p>我是在Docker下安装的HA，在设置外网远程连接的时候遇到了非常多的坑，下面先说下我遇到的坑。</p>\n<p>1.Docker下有4中network模式，有host，container，none，bridge（默认），一开始按照别人的教程安装是<code>bridge</code>模式，然后用<code>cpolar http 8123</code>进行内网穿透，遇到了我的第一个坑，页面显示400 bad request。<br><strong>解决方案</strong>：凭借着不解决不死心的决心，我搜索了各种资料，终于让我在bing上找到了方法，由于是HA是在docker下运行的，所以有一个虚拟的IP地址，可以用portainer找到网络模式下找到这个IP地址，显示为172.17.0.1，解决的方案就是在<code>configuration.yaml</code>下添加下面的信息：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:</span><br><span class=\"line\">  use_x_forwarded_for: true</span><br><span class=\"line\">  trusted_proxies:</span><br><span class=\"line\">    - 172.17.0.1</span><br></pre></td></tr></table></figure>\n<p>然后重新进行内网穿透，哇！居然可以了！可是还有坑迎接我😭</p>\n<p>2.然后我开始配置homekit，非常nice，有官方集成，直接一键傻瓜操作，并且生成了二维码让我去扫，结果我试了好几次，都说无法找到设备，我服了。<br><strong>解决方案</strong>：凭借着不解决不死心的决心，我搜索了各种资料，终于又让我在bing(必应还是不错的)上找到了方法，因为我们安装的时候docker选择bridge模式，这种网络homekit是无法找到设备的，需要设置为<code>host</code>模式，ok，行，那我删除镜像重新安装，也是非常简单的，把bridge改成host。没错，真的就是这么一回事，果然找到设备了。然后我又兴高采烈用<code>cpolar http 8123</code>穿透，结果显示400 bad request，可是这次是host模式呀，和宿主机共享呀，根本不是bridge下那种情况，所以我就在配置文件写了我的本机地址192.168.1.104，结果还是不行，难度homekit和远程连接我只能选择其中一样？可是我都想要呀，然后我又想了半天，试试能不能用nginx进行反向代理，设置了好久也没有搞定，终于最后，我查了两天资料，又让我在论坛上找到了别人的一个配置信息，只需要在<code>configuration.yaml</code>添加这个配置就可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:</span><br><span class=\"line\">  server_port: 8123</span><br><span class=\"line\">  use_x_forwarded_for: True</span><br><span class=\"line\">  trusted_proxies:</span><br><span class=\"line\">    - 127.0.0.1</span><br><span class=\"line\">    - ::1</span><br><span class=\"line\">    - 10.0.20.0/24</span><br><span class=\"line\">    - 10.10.0.0/16</span><br><span class=\"line\">    - 10.43.0.0/16</span><br><span class=\"line\">    - 10.42.0.0/16</span><br><span class=\"line\">    - 10.0.20.81</span><br><span class=\"line\">    - 10.0.20.82</span><br><span class=\"line\">    - 10.0.20.83</span><br><span class=\"line\">    - 10.42.1.14</span><br><span class=\"line\">    - 10.42.0.42</span><br><span class=\"line\">  ip_ban_enabled: False</span><br><span class=\"line\">  login_attempts_threshold: 5</span><br></pre></td></tr></table></figure>\n<p>成功了！homekit和远程我都可以一起要了！这里有个细节，就是cpolar会生成两个链接，一个是加密的https，一个是http，因为咱是白嫖，没有域名，没有服务器，所以只能用http这个，当然，如果你有域名有云服务器的话，应该不会遇到我上面这些问题，因为我看网络上远程链接教程还是比较全的。</p>\n<p><strong>一些提示</strong><a href=\"https://www.cpolar.com/\">cpolar</a>和<a href=\"https://ngrok.cc/\">ngork.cc</a>都可以用免费的内网穿透，区别在于cpolar是动态更换链接，而ngrok链接可以是固定的，但是太卡了，所以我还是选择cpolar，当然，有钱任性，可以直接买他们的服务。</p>\n<p><strong>一些心得：</strong>其实在bridge模式下能够进行远程连接，我就已经有信心在host模式下远程连接，所以我觉得肯定是一些配置上出现了问题，后来想到用nginx进行反向代理，虽然我并没有成功设置好，但是我觉得即便设置好了，也会出现400，因为本质上不是这个问题，而是HA直接拒绝你，所以后来不从这个思路下手，终于更换各种关键词去论坛上搜索，找到一个人的配置，太开心了，还有，英文还是得要学好，HA论坛都是英文。</p>\n","categories":["HomeAassistant"],"tags":["cpolar","远程控制"]},{"title":"Linux记录","url":"/2023/08/06/Linux%E8%AE%B0%E5%BD%95/","content":"<p>记录linux一些操作。</p>\n<span id=\"more\"></span>\n<h1 id=\"linux下设置定时任务\"><a href=\"#linux下设置定时任务\" class=\"headerlink\" title=\"linux下设置定时任务\"></a>linux下设置定时任务</h1><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">crontab -e #进入编辑界面设置定时任务</span><br></pre></td></tr></table></figure>\n\n<p>然后添加以下内容</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 6 * * * /usr/bin/python3 /home/pi/rent.py #每天6点执行一次</span><br></pre></td></tr></table></figure>\n\n<p>然后重启定时任务</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">service cron restart</span><br></pre></td></tr></table></figure>\n","categories":["linux"]},{"title":"MySql笔记","url":"/2022/04/14/MySql%E7%AC%94%E8%AE%B0/","content":"<p>记录极客时间《MySql实战45讲》中的一些笔记。</p>\n<span id=\"more\"></span> \n<p><img src=\"/images/mysql/logic.jpg\" alt=\"MySql的逻辑架构图\"><br>MySql的逻辑架构图</p>\n<h1 id=\"第一讲-一条SQL查询语句是如何执行的？\"><a href=\"#第一讲-一条SQL查询语句是如何执行的？\" class=\"headerlink\" title=\"第一讲 一条SQL查询语句是如何执行的？\"></a>第一讲 一条SQL查询语句是如何执行的？</h1><p>1.当一个表进行更新的时候，跟这个表有关的查询缓存就会失效。<br>2.mysql占用内存快，可以定期断开长连接，这样资源可以释放出来，或者每次进行一个大操作后，通过执行mysql_reset_connection来重新初始化资源。</p>\n<h1 id=\"第二讲-一条SQL更新语句是如何执行的？\"><a href=\"#第二讲-一条SQL更新语句是如何执行的？\" class=\"headerlink\" title=\"第二讲 一条SQL更新语句是如何执行的？\"></a>第二讲 一条SQL更新语句是如何执行的？</h1><p>1.redo log（重做日志）是InnoDB（Mysql引擎之一）特有的，binlog（归档日志）是Server层的，任何引擎都能用。<br>2.redo log是物理日志，binlog是逻辑日志。<br>3.redo log是循环写的，会覆盖。binlog是可以追加写入，不会覆盖。<br>4.两阶段提交可以保证数据恢复是逻辑的一样的。<br>本讲问题：在什么场景下，一天一备会比一周一备更有优势，或者说，它影响了这个数据库系统的哪个指标？</p>\n<h1 id=\"第三讲-为什么你改了我还看不见？\"><a href=\"#第三讲-为什么你改了我还看不见？\" class=\"headerlink\" title=\"第三讲 为什么你改了我还看不见？\"></a>第三讲 为什么你改了我还看不见？</h1><p>1.事务具有原子性，一致性，隔离性，持久性。<br>2.SQL标准事务隔离级别：读未提交，读提交，可重复读，串行化。<br>3.当数据库多个事务同时执行时，可能出现脏读，不可重复读，幻读的问题。<br>4.尽量不要使用长事务，不然占用资源，最终拖垮整个库。误用长事务具体看第三讲。<br>本讲问题：你是数据库负责人，你会怎么避免或者处理长事务这种情况？</p>\n<h1 id=\"第四讲-深入浅出索引（上）\"><a href=\"#第四讲-深入浅出索引（上）\" class=\"headerlink\" title=\"第四讲 深入浅出索引（上）\"></a>第四讲 深入浅出索引（上）</h1><p>1.索引分为主键索引和普通索引，在应用中应该尽量使用主键查询。<br>2.InnoDB选择用B+树结构，可以配合磁盘的读写特性，减少单次查询磁盘访问的次数。<br>3.本讲最后是如何避免长事务对业务的影响。<br>本讲问题：对于上面例题的两个重建索引的作法，说出你的理解，或者你觉得有什么不合适的吗？</p>\n<h1 id=\"第五讲-深入浅出索引（下）\"><a href=\"#第五讲-深入浅出索引（下）\" class=\"headerlink\" title=\"第五讲 深入浅出索引（下）\"></a>第五讲 深入浅出索引（下）</h1><p>1.数据库索引的概念包括：覆盖索引，前缀索引，索引下推。其中覆盖索引可以减少树的搜索次数，显著提示查询性能，是一个常用的优化手段。<br>2.满足语句需求的情况下，尽量少访问资源是数据库设计的重要原则之一。<br>3.建立联合索引时，如何安排索引内的字段顺序，第一原则是如果通过调整顺序可以少维护一个索引，那么这个顺序是优先考虑的。<br>本讲问题：这个例题，两个索引都是否是必须的，为什么？</p>\n<h1 id=\"第六讲-全局锁和表锁：给表加个字段怎么有这么多阻碍？\"><a href=\"#第六讲-全局锁和表锁：给表加个字段怎么有这么多阻碍？\" class=\"headerlink\" title=\"第六讲 全局锁和表锁：给表加个字段怎么有这么多阻碍？\"></a>第六讲 全局锁和表锁：给表加个字段怎么有这么多阻碍？</h1><p>1.MySql的锁大致分为全局锁，表级锁，行锁三类。<br>2.表级锁又分为：表锁，元数据锁。<br>3.全局锁主要用在逻辑备份过程中，表锁一般是在数据库引擎不支持行锁的时候才会被用到。<br>4.MDL（元数据锁）会直到事务提交才释放，在做表结构变更的时候，一定小心不要导致锁住线上查询和更新。<br>5.DML:增修改数据 DDL：修改表结构<br>本讲问题：备份一般在备库上进行，你在用-single-transaction方法做逻辑备份的过程中，如果主库上一个小表做了一个DDL，这时候从备库上会看到什么现象。</p>\n<h1 id=\"第七讲-行锁功过：怎么减少行锁对性能的影响？\"><a href=\"#第七讲-行锁功过：怎么减少行锁对性能的影响？\" class=\"headerlink\" title=\"第七讲 行锁功过：怎么减少行锁对性能的影响？\"></a>第七讲 行锁功过：怎么减少行锁对性能的影响？</h1><p>1.InnoDB支持行锁，MyISAM不支持，不支持行锁，一个表任何一个时刻只能由一个更新进行，会影响业务并发度。<br>2.两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不是需要了就立刻释放，而是要等到事务结束时才释放。<br>3.如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后面放。<br>4.发生死锁的解决方案：1.直接进入等待，直到超时。2.主动发起死锁检测。<br>5.死锁检测在热点行更新会导致利用大量资源的解决方法：1.临时把死锁检测关掉，但是有风险。2.控制并发度，但是如果客户端很多，也是很耗资源，所以并发控制可以在数据库服务端做，可以考虑用中间件实现，或者有大牛修改MySQL源码，总之基本思路是：对于相同行的更新，在进入引擎之前排队。如果没有大牛，可以将一行改成多行的逻辑，比如电影院的账户总额等于10个记录的值，每次随机给一条记录添加，这样冲突的概率为1&#x2F;10，但是你还要考虑如果有人发生退票，一部分记录会变成0，你要对代码有特殊处理。<br>本讲问题：关于删除表前面1000行数据，这三个方法你选择哪个，为什么？</p>\n<h1 id=\"第八讲-事务到底是隔离的还是不隔离的？\"><a href=\"#第八讲-事务到底是隔离的还是不隔离的？\" class=\"headerlink\" title=\"第八讲 事务到底是隔离的还是不隔离的？\"></a>第八讲 事务到底是隔离的还是不隔离的？</h1><p>这篇文章需要好好消化，举例了一个具体的操作，关于事务隔离时候的情况。<br>1.InnoDB的行数据有多个版本，每个数据版本都有自己的row trx_id，每个事务或者语句有自己的一致性视图。<br>2.普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。<br>3.对于可重复读，查询只承认在事务启动前就已经提交完成的数据。<br>4.对于读提交，查询只承认在语句启动前就已经提交完成的数据。<br>5.而当前读，总是读取已经提交完成的最新版本。<br>6.MySQL中，有两个视图的概念，1.一个是view,它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view…，而他的查询方法与表一样。2.另一个是InnoDB在实现MVCC时用到的一致性读视图即consistent read view用于支持RC（read committed，读提交）和RR（repeatable read，可重复读）隔离级别的实现。<br>7.更新数据都是先读后写的，而这个读，只能读当前的值，称为当前读（current read）。<br>本讲问题：一个具体的业务操作出现的问题，具体看原文。</p>\n<h1 id=\"第九讲-普通索引和唯一索引，应该怎么选择\"><a href=\"#第九讲-普通索引和唯一索引，应该怎么选择\" class=\"headerlink\" title=\"第九讲 普通索引和唯一索引，应该怎么选择\"></a>第九讲 普通索引和唯一索引，应该怎么选择</h1><p>1.身份证号字段比较大，不建议直接当主键，可以当唯一索引，因为这个业务代码上保证了不会写入重复的身份证号。<br>2.普通索引和唯一索引其实性能上差距不大，但是他们对更新语句性能有影响，但是非常小，只是在于一个判断。<br>3.change buffer只限于在普通索引下，不太适合唯一索引。<br>4.redo log主要是节省随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省随机读磁盘的IO消耗。<br>本讲问题：change buffer一开始是写内存，如果这个时候机器掉电重启，会不会导致change buffer丢失？</p>\n<h1 id=\"第十讲-MySQL为什么有时候会选错索引？\"><a href=\"#第十讲-MySQL为什么有时候会选错索引？\" class=\"headerlink\" title=\"第十讲 MySQL为什么有时候会选错索引？\"></a>第十讲 MySQL为什么有时候会选错索引？</h1><p>1.优化器选择索引的目的是为了找到一个最优的方案，但是有时候会判断错误从而选错索引。<br>2.如何让优化器真正选择好的索引：1.我们可以采用force index强行选择一个索引。2.或者修改语句，引导MySql使用我们期待的索引。3.在有些场景下，可以新建一个更合适的索引，或者删掉误用的索引。<br>本讲问题：具体看文章，是本文例子的扩展问题。</p>\n<h1 id=\"第十一讲-怎么给字符串字段加索引？\"><a href=\"#第十一讲-怎么给字符串字段加索引？\" class=\"headerlink\" title=\"第十一讲 怎么给字符串字段加索引？\"></a>第十一讲 怎么给字符串字段加索引？</h1><p>1.使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。<br>2.使用前缀索引就用不上覆盖索引对查询性能的优化，这一点则需要我们考虑是否使用前缀索引。<br>3.倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题，比如身份证。<br>4.创建hash字段索引，查询性能稳定，有额外的存储和计算消耗，和倒序存储一样均不支持范围扫描。<br>本讲问题：维护一个学生信息库，如何设计登录名的索引，这是算实战题，得好好看。</p>\n<h1 id=\"第十二讲-为什么我的MySQL会抖一下？\"><a href=\"#第十二讲-为什么我的MySQL会抖一下？\" class=\"headerlink\" title=\"第十二讲 为什么我的MySQL会抖一下？\"></a>第十二讲 为什么我的MySQL会抖一下？</h1><p>1.因为InnoDB在后台刷脏页，也就是将内存写入磁盘，所以无论是因为你的查询语句需要内存的时候可能要求淘汰一个脏页，还是由于刷脏页的逻辑会占用IO资源影响到更新语句，都可能会让MySQL抖一下。<br>本讲问题：一个内存配置为128GB. innodb io_ capacity设 置为20000的大规格实例，正常会建议你将redolog设置成4个1GB的文件。但如果你在配置的时候不慎将redo log设置成了1个100M的文件，会发生什么情况呢?又为什么会出现这种情况呢？</p>\n<h1 id=\"第十三讲-为什么表数据删掉一半，表文件大小不变？\"><a href=\"#第十三讲-为什么表数据删掉一半，表文件大小不变？\" class=\"headerlink\" title=\"第十三讲 为什么表数据删掉一半，表文件大小不变？\"></a>第十三讲 为什么表数据删掉一半，表文件大小不变？</h1><p>1.建议设置innodb_file_per_table为on，表示每个InnoDB表数据存储在一个以.ibd为后缀的文件中。<br>2.如果上面说的参数设置为off，表的数据会放在系统共享表空间，这时候如果我们删掉表，空间是不会回收的，而如果是上面的on，表单独存成一个文件，通过drop table系统会删掉这个文件。<br>3.单纯delete表不用的数据，表文件大小不变，还要通过alter table重建表才可以把表变小。<br>4.本文还涉及inplace和online的区别，以及onlineDDL下的重建表的过程。<br>本讲问题：某人用了alter table后发现空间还大了点，是什么原因？</p>\n<h1 id=\"第十四讲-count-这么慢，我该怎么办？\"><a href=\"#第十四讲-count-这么慢，我该怎么办？\" class=\"headerlink\" title=\"第十四讲 count(*)这么慢，我该怎么办？\"></a>第十四讲 count(*)这么慢，我该怎么办？</h1><p>1.MyISAM表虽然count(<em>)快，但是不支持事务;show table status命令虽然快，但是不准确;InnoDB直接count(</em>)会遍历全表，虽然结果准确，但是有性能问题。<br>2.用redis来保存计数可能存在丢失更新的问题，也就是可能不一致。<br>3.把计数值放在MySql中，可以解决这个一致性视图的问题，利用了事务这个特性。<br>本讲问题：我们用事务来保证计数准确，那么这个事务序列中，应该先插入操作记录，还是先更新计数表呢？</p>\n","categories":["学习笔记"],"tags":["MySql"]},{"title":"Pytorch Tips","url":"/2021/04/02/Pytorch-Tips/","content":"<p>代码中的一些记录</p>\n<span id=\"more\"></span> \n<p>1.如果用cv2.imread读取的是灰度图图像，imgB &#x3D; cv2.imread(‘.&#x2F;train_data&#x2F;label&#x2F;‘ + img_name, 0)，请在末尾写上0，否则出来的图像是三个通道<br>2.imgB &#x3D; imgB.transpose(0, 1, 2)表示图像不变   imgB &#x3D; imgB.transpose(2, 0, 1)表示原来的2轴转到0，原来的0轴转到1，原来的1轴转到2，主要是适应pytorch中的一些设置，因为pytorch中[4,1,64,64]表示一个批次4张图片，然后有一个通道，最后两个参数是h,w<br>3.img_train &#x3D; torch.unsqueeze(img_train, 0)对数据进行扩充维度，本身是64*64，可以变成[1,64,64]，0代表在哪里扩充  </p>\n","categories":["学习笔记"]},{"title":"cron定时表达式笔记","url":"/2022/02/14/cron%E5%AE%9A%E6%97%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/","content":"<p>cron用于定时任务，本笔记用于记录相关语法</p>\n<span id=\"more\"></span>\n\n<p><strong>需要注意的是不同软件有些定义略有不同，比如“周”，有些是定义0-6，有些是1-7，具体请做好详细测试再上线！</strong></p>\n<p><strong>字段描述</strong></p>\n<!--more-->\n\n<table>\n<thead>\n<tr>\n<th align=\"center\">序号</th>\n<th align=\"center\">字段</th>\n<th align=\"center\">允许值范围</th>\n<th>允许符号</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">Seconds 秒</td>\n<td align=\"center\">0-59</td>\n<td>, - * &#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\">Minutes 分</td>\n<td align=\"center\">0-59</td>\n<td>, - * &#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">Hours 时</td>\n<td align=\"center\">0-23</td>\n<td>, - * &#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">Day-of-Month 日</td>\n<td align=\"center\">1-31</td>\n<td>,- * ? &#x2F; L W C</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\">Month 月</td>\n<td align=\"center\">1-12 或者 JAN, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV,DEC</td>\n<td>, - * &#x2F;</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\">Day-of-Week 周</td>\n<td align=\"center\"><strong>这里数字不确定</strong> 或者”SUN, MON, TUE, WED, THU, FRI, SAT”</td>\n<td>, - * ? &#x2F; L C #</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">Year(可选) 年</td>\n<td align=\"center\">1970-2099</td>\n<td>, - * &#x2F;</td>\n</tr>\n</tbody></table>\n<p><strong>具体符号解释</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">符号</th>\n<th align=\"center\">解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">,</td>\n<td align=\"center\">表示列出枚举值。例如：在Minutes域使用5,20，则意味着在第5分钟和第20分种触发一次。</td>\n</tr>\n<tr>\n<td align=\"center\">-</td>\n<td align=\"center\">表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次。</td>\n</tr>\n<tr>\n<td align=\"center\">&#x2F;</td>\n<td align=\"center\">表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5&#x2F;20,则意味着第5分钟开始触发，然后每隔20分钟再次触发，如25,45分钟会触发。</td>\n</tr>\n<tr>\n<td align=\"center\">L</td>\n<td align=\"center\">只能出现在<strong>Day of Week(周)和Day of Month(日) 中</strong>，表示最后。week中使用：表示每周最后一天（周六），月中使用表示：每月最后一天。</td>\n</tr>\n<tr>\n<td align=\"center\">?</td>\n<td align=\"center\">只能出现在<strong>Day of Week(周)和Day of Month(日) 中</strong>，匹配区域的任意值，<strong>但是他们会相互影响</strong>，比如。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 0 0 0 20 * ?, 其中最后一位只能用？，而不能使用<em>，如果使用</em>表示不管星期几都会触发，这样就会有矛盾</td>\n</tr>\n<tr>\n<td align=\"center\">W</td>\n<td align=\"center\">只能出现在<strong>Day of Month(月)中</strong>，用来触发工作日，系统将在离指定日期的最近的有效工作日触发事件。例如：5W，触发第五个工作日，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份。<strong>未测试成功这个指令，可能有些系统不支持。</strong></td>\n</tr>\n<tr>\n<td align=\"center\">#</td>\n<td align=\"center\">只能出现在<strong>Day of Week(周)中</strong>，如FRI#3，表示第三个周五</td>\n</tr>\n<tr>\n<td align=\"center\">LW</td>\n<td align=\"center\">这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五</td>\n</tr>\n<tr>\n<td align=\"center\">C</td>\n<td align=\"center\">未找到相关解释</td>\n</tr>\n</tbody></table>\n<p><strong>收集了一些例子</strong><br>“0 0 10,14,16 * * ?” 每天上午10点，下午2点，4点 </p>\n<p>“0 0&#x2F;30 9-17 * * ?” 朝九晚五工作时间内每半小时</p>\n<p>“0 0 12 ? * WED” 表示每个星期三中午12点 </p>\n<p>“0 0 12 * * ?” 每天中午12点触发 </p>\n<p>“0 15 10 ? * *” 每天上午10:15触发 </p>\n<p>“0 15 10 * * ?” 每天上午10:15触发 </p>\n<p>“0 15 10 * * ? *” 每天上午10:15触发 </p>\n<p>“0 15 10 * * ? 2005” 2005年的每天上午10:15触发 </p>\n<p>“0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发 </p>\n<p>“0 0&#x2F;5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发 </p>\n<p>“0 0&#x2F;5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </p>\n<p>“0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发 </p>\n<p>“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发 </p>\n<p>“0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发 </p>\n<p>“0 15 10 15 * ?” 每月15日上午10:15触发 </p>\n<p>“0 15 10 L * ?” 每月最后一日的上午10:15触发 </p>\n<p>“0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发</p>\n<p>“0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发 </p>\n<p>“0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发</p>\n","categories":["Linux"],"tags":["cron","Linux"]},{"title":"Hexo配置","url":"/2020/09/20/hexo%E9%85%8D%E7%BD%AE/","content":"<p>为了方便更换电脑快速配置hexo所写的文档</p>\n<span id=\"more\"></span>\n\n<h1 id=\"安装hexo\"><a href=\"#安装hexo\" class=\"headerlink\" title=\"安装hexo\"></a>安装hexo</h1><figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install -g hexo-cli</span><br><span class=\"line\">hexo init hexo  //在D盘会生成hexo的文件夹</span><br><span class=\"line\">npm install hexo-deployer-git --save //安装deploy上传到github</span><br><span class=\"line\">git clone https://github.com/next-theme/hexo-theme-next themes/next    //next主题安装</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"扩展功能\"><a href=\"#扩展功能\" class=\"headerlink\" title=\"扩展功能\"></a>扩展功能</h1><h2 id=\"豆瓣读书\"><a href=\"#豆瓣读书\" class=\"headerlink\" title=\"豆瓣读书\"></a>豆瓣读书</h2><p><a href=\"https://github.com/mythsman/hexo-douban\">插件地址</a></p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-douban --save-dev</span><br></pre></td></tr></table></figure>\n\n<p>hexo的_config.yml配置如下信息</p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">douban:</span><br><span class=\"line\">  id: 162282689  # 你的豆瓣ID</span><br><span class=\"line\">  builtin: true</span><br><span class=\"line\">  book:</span><br><span class=\"line\"><span class=\"code\">    title: &#x27;那些年，我翻阅过的书&#x27;</span></span><br><span class=\"line\"><span class=\"code\">    quote: &#x27;思想和身体，总有一个在路上&#x27;</span></span><br><span class=\"line\"><span class=\"code\">  #movie:</span></span><br><span class=\"line\"><span class=\"code\">    #title: &#x27;那些年，我追过的电影&#x27;</span></span><br><span class=\"line\"><span class=\"code\">    #quote: &#x27;过去、现在、和未来&#x27;</span></span><br><span class=\"line\"><span class=\"code\">  #game:</span></span><br><span class=\"line\"><span class=\"code\">    #title: &#x27;那些年，我玩过的游戏&#x27;</span></span><br><span class=\"line\"><span class=\"code\">    #quote: &#x27;还记得你曾经的游戏角色吗&#x27;</span></span><br><span class=\"line\"><span class=\"code\">  timeout: 10000</span></span><br></pre></td></tr></table></figure>\n\n<p>进入next主题的language，在zn-CN.yml中添加books：书籍</p>\n<h2 id=\"搜索功能\"><a href=\"#搜索功能\" class=\"headerlink\" title=\"搜索功能\"></a>搜索功能</h2><figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\n\n<p>hexo的_config.yml配置如下信息</p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 10000</span><br><span class=\"line\">  content: true</span><br></pre></td></tr></table></figure>\n\n<p>最后hexo主题配置文件（\\themes\\next_config.yml），修改local_search的enable为true</p>\n<h2 id=\"RSS\"><a href=\"#RSS\" class=\"headerlink\" title=\"RSS\"></a>RSS</h2><figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>hexo的_config.yml配置如下信息</p>\n<figure class=\"highlight md\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\"># rss</span></span><br><span class=\"line\">Plugins: </span><br><span class=\"line\"><span class=\"bullet\">-</span> hexo-generate-feed</span><br><span class=\"line\">feed:</span><br><span class=\"line\"><span class=\"code\">    type: atom</span></span><br><span class=\"line\"><span class=\"code\">    path: atom.xml</span></span><br><span class=\"line\"><span class=\"code\">    limit: 20</span></span><br></pre></td></tr></table></figure>","tags":["hexo"]},{"title":"LeetCode-JAVA","url":"/2021/09/20/LeetCode-JAVA/","content":"<p>按照<a href=\"https://github.com/changgyhub/leetcode_101\">《Leetcode101-A Leetcode Gringding Guide》</a>顺序记录。除此之外，开始正视代码书写规范。</p>\n<span id=\"more\"></span> \n<h1 id=\"ACM模式练习\"><a href=\"#ACM模式练习\" class=\"headerlink\" title=\"ACM模式练习\"></a>ACM模式练习</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">next()、nextInt()、nextLine()都是Scanner内置的方法，他们的区别主要在于对于对空格的处理方式不同，以及返回值不同。</span><br><span class=\"line\">nextLine()方法，空格不作为两个字符串的间隔，而是看作字符串的一部分。</span><br><span class=\"line\">next()和nextInt()方法遇到空格时会停止读取，nextInt()的返回值为int类型，next()、nextLine()的返回值均为String类型。</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-A-B-I\"><a href=\"#1-A-B-I\" class=\"headerlink\" title=\"1.A+B I\"></a>1.A+B I</h2><p>单纯简单计算两个数的和，但是有n组数据</p>\n<p>输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000),输入数据包括多组。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123; <span class=\"comment\">//注意这里没有()，没有String[] args</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            System.out.println(a + b);  <span class=\"comment\">// System.out.println(in.nextInt() + in.nextInt()); //或者可以把三行代码改成这个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-A-B-II\"><a href=\"#2-A-B-II\" class=\"headerlink\" title=\"2.A+B II\"></a>2.A+B II</h2><p>需要先声明要输入多少组数字之和</p>\n<p>输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)<br>接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(a-- != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            System.out.println(b + c);</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-A-B-III\"><a href=\"#3-A-B-III\" class=\"headerlink\" title=\"3.A+B III\"></a>3.A+B III</h2><p>和第一题不一样的是碰到0 0 则结束</p>\n<p>输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a == <span class=\"number\">0</span> &amp;&amp; b == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            System.out.println(a + b);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-计算一系列数的和-I\"><a href=\"#4-计算一系列数的和-I\" class=\"headerlink\" title=\"4.计算一系列数的和 I\"></a>4.计算一系列数的和 I</h2><p>先输入需要计算多少个数，然后求和，遇到第一个数为0则结束</p>\n<p>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count == <span class=\"number\">0</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count-- != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                sum += in.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-计算一系列数的和-II\"><a href=\"#5-计算一系列数的和-II\" class=\"headerlink\" title=\"5.计算一系列数的和 II\"></a>5.计算一系列数的和 II</h2><p>和第四题的区别是先声明需要输入多少组,而第四题是用0来结束的</p>\n<p>输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">group</span> <span class=\"operator\">=</span> in.nextInt(); <span class=\"comment\">//这个是输入需要计算多少组</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(group-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> in.nextInt(); <span class=\"comment\">//每组多少个数字需要计算</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count-- != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                sum += in.nextInt();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-计算一系列数的和-III\"><a href=\"#6-计算一系列数的和-III\" class=\"headerlink\" title=\"6.计算一系列数的和 III\"></a>6.计算一系列数的和 III</h2><p>和4，5的区别是这个没有限制，只需要提供每组多少个数，也就是每行表示一组数据</p>\n<p>输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(count-- != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                sum += in.nextInt(); </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-计算一系列数的和-IV\"><a href=\"#7-计算一系列数的和-IV\" class=\"headerlink\" title=\"7.计算一系列数的和 IV\"></a>7.计算一系列数的和 IV</h2><p>这个题和上面的区别是 没有指定每组数字有多少个</p>\n<p>输入数据有多组, 每行表示一组输入数据。<br>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNextLine())&#123;<span class=\"comment\">//注意这个Next是大写的</span></span><br><span class=\"line\">            String[] str = in.nextLine().split(<span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//在每个空格字符处进行分解</span></span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(Arrays.toString(str));如果输入1 2 3，可以看到是处理成[1,2,3]</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length; i++)&#123;</span><br><span class=\"line\">                sum += Integer.parseInt(str[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(sum);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"8-字符串排序-I\"><a href=\"#8-字符串排序-I\" class=\"headerlink\" title=\"8.字符串排序 I\"></a>8.字符串排序 I</h2><p>只排序一组数据，先输入这组需要排序多少个字符</p>\n<p>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> in.nextInt();</span><br><span class=\"line\">        String[] str = <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>[count];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">            str[i] = in.next();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(str);<span class=\"comment\">//调库侠</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; count; i++)&#123;</span><br><span class=\"line\">            System.out.print(str[i] + <span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意输出格式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"9-字符串排序-II\"><a href=\"#9-字符串排序-II\" class=\"headerlink\" title=\"9.字符串排序 II\"></a>9.字符串排序 II</h2><p>和上一题的区别是不需要输入一组需要排序多少个字符 但是需要排序n组，也就是一次性输入一组的数据</p>\n<p>多个测试用例，每个测试用例一行。<br>每行通过空格隔开，有n个字符，n＜100</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNextLine())&#123;<span class=\"comment\">//注意这个Next是大写的</span></span><br><span class=\"line\">            String[] str = in.nextLine().split(<span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意这个next是小写的</span></span><br><span class=\"line\">            Arrays.sort(str);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length; i++)&#123;</span><br><span class=\"line\">                System.out.print(str[i] + <span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//注意输出格式</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.print(<span class=\"string\">&#x27;\\n&#x27;</span>);<span class=\"comment\">//注意输出格式</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-字符串排序-III\"><a href=\"#10-字符串排序-III\" class=\"headerlink\" title=\"10.字符串排序 III\"></a>10.字符串排序 III</h2><p>这个和上一题的区别是输出格式是逗号隔开，上一题是空格，但是注意的是上一题最后一个字符后面是空格，这一题如果按照上一题的逻辑去做会输出一个逗号，而题目不希望出现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNextLine())&#123;</span><br><span class=\"line\">            String[] str = in.nextLine().split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">            Arrays.sort(str);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length - <span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">                System.out.print(str[i] + <span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(str[str.length - <span class=\"number\">1</span>]);<span class=\"comment\">//避免最后一个后面有个逗号，同时加一个回车</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-A-B-IV\"><a href=\"#11-A-B-IV\" class=\"headerlink\" title=\"11.A+B IV\"></a>11.A+B IV</h2><p>和第一题的区别是数据范围不一样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span>&#123; <span class=\"comment\">//注意这里没有()，没有String[] args</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">in</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(in.hasNext())&#123;</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> in.nextLong();</span><br><span class=\"line\">            <span class=\"type\">long</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> in.nextLong();</span><br><span class=\"line\">            System.out.println(a + b);  <span class=\"comment\">// System.out.println(in.nextLong() + in.nextLong()); //或者可以把三行代码改成这个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"360一道题-acm\"><a href=\"#360一道题-acm\" class=\"headerlink\" title=\"360一道题 acm\"></a>360一道题 acm</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">有一种特殊的DNA，仅仅由核酸A和T组成，长度为n，顺次连接</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">科学家有一种新的手段，可以改变这种DNA。每一次，科学家可以交换该DNA上两个核酸的位置，也可以将某个特定位置的核酸修改为另一种核酸。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">现在有一个DNA，科学家希望将其改造成另一种DNA，希望你计算最少的操作次数。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">ATTTAA</span></span><br><span class=\"line\"><span class=\"comment\">TTAATT</span></span><br><span class=\"line\"><span class=\"comment\">输出3</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">样例解释：</span></span><br><span class=\"line\"><span class=\"comment\">1.首先修改第一个位置的核酸（从A修改为T）</span></span><br><span class=\"line\"><span class=\"comment\">2.交换3和5位置的核酸</span></span><br><span class=\"line\"><span class=\"comment\">3.交换4和6位置的核酸</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">    String a,b;</span><br><span class=\"line\">    a = sc.nextLine();</span><br><span class=\"line\">    b = sc.nextLine();</span><br><span class=\"line\">    <span class=\"comment\">//return dna(a,b);</span></span><br><span class=\"line\">    System.out.println(dna(a,b));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">dna</span><span class=\"params\">(String a, String b)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a.charAt(i) == <span class=\"string\">&#x27;A&#x27;</span> &amp;&amp; b.charAt(i) != <span class=\"string\">&#x27;A&#x27;</span>) &#123;</span><br><span class=\"line\">        c++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a.charAt(i) == <span class=\"string\">&#x27;T&#x27;</span> &amp;&amp; b.charAt(i) != <span class=\"string\">&#x27;T&#x27;</span>) &#123;</span><br><span class=\"line\">        d++;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(c,d);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACM-二叉树输入-前序遍历为例\"><a href=\"#ACM-二叉树输入-前序遍历为例\" class=\"headerlink\" title=\"ACM 二叉树输入 前序遍历为例\"></a>ACM 二叉树输入 前序遍历为例</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hi;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.*;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">tree</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sc.nextInt();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] arr = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            arr[i] = sc.nextInt();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> construct(arr);</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        preorder(root, list);</span><br><span class=\"line\">        System.out.print(list);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preorder</span><span class=\"params\">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;<span class=\"comment\">//前序来举个例子</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        list.add(root.val);</span><br><span class=\"line\">        preorder(root.left, list);</span><br><span class=\"line\">        preorder(root.right, list);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TreeNode</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val;</span><br><span class=\"line\">        TreeNode left;</span><br><span class=\"line\">        TreeNode right;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">TreeNode</span> <span class=\"params\">(<span class=\"type\">int</span> val)</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">TreeNode</span> <span class=\"params\">(<span class=\"type\">int</span> val, TreeNode left, TreeNode right)</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> TreeNode <span class=\"title function_\">construct</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"type\">int</span>[] arr)</span> &#123;</span><br><span class=\"line\">        List&lt;TreeNode&gt; treeNodeList = arr.length &gt; <span class=\"number\">0</span> ? <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(arr.length) : <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                node = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(arr[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            treeNodeList.add(node);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                root = node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i * <span class=\"number\">2</span> + <span class=\"number\">1</span> &lt; arr.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> treeNodeList.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                node.left = treeNodeList.get(<span class=\"number\">2</span> * i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i * <span class=\"number\">2</span> + <span class=\"number\">2</span> &lt; arr.length)<span class=\"comment\">//这个必须加上，不然越界了</span></span><br><span class=\"line\">                node.right = treeNodeList.get(<span class=\"number\">2</span> * i + <span class=\"number\">2</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"ACM-链表-反转链表为例\"><a href=\"#ACM-链表-反转链表为例\" class=\"headerlink\" title=\"ACM 链表 反转链表为例\"></a>ACM 链表 反转链表为例</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> hi;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Scanner;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">listnode</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val;</span><br><span class=\"line\">        ListNode next;</span><br><span class=\"line\">        ListNode(<span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode(<span class=\"type\">int</span> val, ListNode next) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String args[])</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Scanner</span> <span class=\"variable\">sc</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Scanner</span>(System.in);</span><br><span class=\"line\">        String[] param = sc.nextLine().split(<span class=\"string\">&quot; &quot;</span>);<span class=\"comment\">//输入的时候就是1 2 3 4 5</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String x : param) &#123;</span><br><span class=\"line\">            cur.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(Integer.parseInt(x));</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> reverse(dump.next);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (res != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            System.out.print(res.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (res.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                System.out.print(<span class=\"string\">&quot;-&gt;&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res = res.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ListNode <span class=\"title function_\">reverse</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">ListNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> cur.next;</span><br><span class=\"line\">            cur.next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h1><h2 id=\"445-分发饼干-easy\"><a href=\"#445-分发饼干-easy\" class=\"headerlink\" title=\"445 分发饼干 easy\"></a>445 分发饼干 easy</h2><p>依次满足胃口最小的孩子。可以想到先排序，然后再去分配。注意当满足了孩子后,cookie再加一，因为一个饼干只能用一次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//知识点</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">length()：String类的一个方法</span></span><br><span class=\"line\"><span class=\"comment\">字符串.length()</span></span><br><span class=\"line\"><span class=\"comment\">length() 方法用于返回字符串的长度。</span></span><br><span class=\"line\"><span class=\"comment\">长度等于字符串中 16 位 Unicode 代码单元的数量。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">length：类的属性</span></span><br><span class=\"line\"><span class=\"comment\">数组.length</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findContentChildren</span><span class=\"params\">(<span class=\"type\">int</span>[] g, <span class=\"type\">int</span>[] s)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(g);</span><br><span class=\"line\">        Arrays.sort(s);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cookie</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, child = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(child &lt; g.length &amp;&amp; cookie &lt; s.length)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(g[child] &lt;= s[cookie])&#123;</span><br><span class=\"line\">                child++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cookie++;<span class=\"comment\">//饼干只能用一次，满足条件再加1。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> child;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"135-分发糖果-hard\"><a href=\"#135-分发糖果-hard\" class=\"headerlink\" title=\"135 分发糖果 hard\"></a>135 分发糖果 hard</h2><p>首先建立一个数组，然后初始化为1，也就是每个人都先分到一颗糖。然后从左往右边遍历，如果右边的孩子得分高于左边，则右边的孩子糖果数&#x3D;左边的孩子糖果数+1，注意这里不是直接加1.因为分数可能是依次增加，还要求分数高的糖果多。然后从右往左遍历，如果左边的孩子分数大于右边孩子分数并且左边孩子的糖果数不如右边孩子糖果数，则左边孩子糖果数&#x3D;右边孩子糖果数+1，这种情况对应于左边分数大于右边。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//根据书上的思路写的，写法比较冗余。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">candy</span><span class=\"params\">(<span class=\"type\">int</span>[] ratings)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> candys[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ratings.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ratings.length; i++)&#123;</span><br><span class=\"line\">            candys[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ratings.length-<span class=\"number\">1</span>; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ratings[i+<span class=\"number\">1</span>] &gt; ratings[i])&#123;</span><br><span class=\"line\">                candys[i+<span class=\"number\">1</span>] = candys[i] +<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ratings.length-<span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span> ; i--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ratings[i-<span class=\"number\">1</span>] &gt; ratings[i] &amp;&amp; candys[i-<span class=\"number\">1</span>] &lt;=  candys[i])&#123;</span><br><span class=\"line\">                candys[i-<span class=\"number\">1</span>] = candys[i] +<span class=\"number\">1</span> ;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; ratings.length; i++)&#123;</span><br><span class=\"line\">            count += candys[i]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//这个有点不一样，分别创建两个数组，对应满足左右两个规则。然后分别取两个数组的最大值，为什么这样做可以？有个评论写得很清晰,如下。</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">为什么取最大值是正确的思考：</span></span><br><span class=\"line\"><span class=\"comment\">很多人说这个问题显而易见，不值得讨论，但我相信还是有人像我一样不理解，在这里说一下我的想法</span></span><br><span class=\"line\"><span class=\"comment\">我疑惑的问题不是取最大值为啥是最优解，而是取最大值后为啥不影响某一规则的成立。</span></span><br><span class=\"line\"><span class=\"comment\">我们取序列中的任意两点，A B</span></span><br><span class=\"line\"><span class=\"comment\">如果 A &gt; B ,则按照左规则处理后，B不会比A多；按照右规则处理后，A一定比B多，那么A一定会被更新（变大），但L、R规则仍然成立：B不会比A多，A一定比B多；</span></span><br><span class=\"line\"><span class=\"comment\">同理可讨论 A&lt;B;</span></span><br><span class=\"line\"><span class=\"comment\">当 A == B，A、B的值无论如何更新，都不影响 L、R规则</span></span><br><span class=\"line\"><span class=\"comment\">综上，取最大值后不影响某一规则的成立。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">candy</span><span class=\"params\">(<span class=\"type\">int</span>[] ratings)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] left = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ratings.length];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] right = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ratings.length];</span><br><span class=\"line\">        Arrays.fill(left, <span class=\"number\">1</span>);</span><br><span class=\"line\">        Arrays.fill(right, <span class=\"number\">1</span>);<span class=\"comment\">//把right数组全部填充为1，如果长度是长，则right=[1,1,1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; ratings.length; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) left[i] = left[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> left[ratings.length - <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ratings.length - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ratings[i] &gt; ratings[i + <span class=\"number\">1</span>]) right[i] = right[i + <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            count += Math.max(left[i], right[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：jyd</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h2 id=\"435-无重叠区间-medium-可动态规划\"><a href=\"#435-无重叠区间-medium-可动态规划\" class=\"headerlink\" title=\"435 无重叠区间 medium(可动态规划)\"></a>435 无重叠区间 medium(可动态规划)</h2><p>这里学到了Arrays.sort()新写法，开头一直纠结怎么把书上C++的排序用java表达(java用得少)。这里是要移除区间的最小个数，贪心的策略是：在选择要保留区间时，选择的区间结尾越小，余留给其他区间的空间就越大，就能保留更多的区间。首先对尾巴进行递增排序，也就是每个区间的第二个数字排序。然后对prve赋值为第一个区间的尾巴。开始进入for循环，如果第二个区间的头是小于prev，也就是在第一个的区间内，需要进行移除，如果大于了prev，则保留区间，然后prev赋值给第二个区间的尾巴，以此类推。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//首先是知识点笔记，部分来源于网络 Arrays.sort()</span></span><br><span class=\"line\">System.out.println(Arrays.deepToString(intervals));<span class=\"comment\">//这样可以输出二维数组的样子</span></span><br><span class=\"line\">System.out.println(Arrays.toString(intervals));<span class=\"comment\">//输出的貌似是地址，反正是这样的[[I@49993335, [I@20322d26, [I@192b07fd, [I@64bfbc86]</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">方法一、使用Comparable接口：</span></span><br><span class=\"line\"><span class=\"comment\">让待排序对象所在的类实现Comparable接口，并重写Comparable接口中的compareTo() 。方法缺点是只能按照一种规则排序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">方法二、使用Comparator接口 （推荐使用）</span></span><br><span class=\"line\"><span class=\"comment\">如果一个类要实现java.util.Comparator接口：它一定要实现</span></span><br><span class=\"line\"><span class=\"comment\">int compare(T o1, T o2) 函数，而另一个可以不实现（boolean equals(Object obj)） 。</span></span><br><span class=\"line\"><span class=\"comment\">使用编写排序方式类实现Comparator接口，并重写新Comparator接口中的compare()方法。优点：想用什么方式排就用什么方式排。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">原理：观察Arrays.sort()源码如下：</span></span><br><span class=\"line\"><span class=\"comment\">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        if (c == null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            sort(a);</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if (LegacyMergeSort.userRequested)</span></span><br><span class=\"line\"><span class=\"comment\">                legacyMergeSort(a, c);</span></span><br><span class=\"line\"><span class=\"comment\">            else</span></span><br><span class=\"line\"><span class=\"comment\">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">所以，在传入要排序数组时，还可以传入一个Compartor接口（比较器），然后这个接口中要重写一个compare()方法，这个重写的compare()方法就是我们自己规定的比较规则。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">实现Comparator接口，必须实现下面这个函数：</span></span><br><span class=\"line\"><span class=\"comment\">@Override</span></span><br><span class=\"line\"><span class=\"comment\">public int compare(CommentVo o1, CommentVo o2) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">           return o1.getTime().compareTo(o2.getTime());</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">这里o1表示位于前面的对象，o2表示后面的对象</span></span><br><span class=\"line\"><span class=\"comment\">返回-1（或负数），表示不需要交换01和02的位置，o1排在o2前面，asc</span></span><br><span class=\"line\"><span class=\"comment\">返回1（或正数），表示需要交换01和02的位置，o1排在o2后面，desc</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">//所以本题的sort，比较尾巴就是interval1[1]，为了递增，左边尾巴减右边尾巴，负数就不需要交换，正数就交换。</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//这个是贪心策略写法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"type\">int</span>[][] intervals)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(intervals.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Arrays.sort(intervals,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span> []&gt;()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] interval1, <span class=\"type\">int</span>[] interval2)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> interval1[<span class=\"number\">1</span>]-interval2[<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);<span class=\"comment\">//学废了吗？</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">total</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, prev = intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(intervals[i][<span class=\"number\">0</span>] &lt; prev)&#123;</span><br><span class=\"line\">                total++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                prev = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"605-种花问题-easy\"><a href=\"#605-种花问题-easy\" class=\"headerlink\" title=\"605 种花问题 easy\"></a>605 种花问题 easy</h2><p>虽说是easy题，但是发现自己想的bug很多，看到了一个很清晰的解题方法：跳格法。注意题目是不能打破原来的种植规则！。情况1：当index遇到1的时候，也就是至少隔一格才能种花，所以i要跳两格。情况2：当index遇到0时候，如果下一格为0，则可以种花（此时n-1），并且顺便跳两格，这里还有个情况就是如果已经是最后一格了，那就也能种花，一开始会想，万一最后一格的前面一格是1呢？注意这个情况不会发生，因为你是跳格法，你跳的index就代表是可能种花的，只需要考虑后面就行。如果下一个格子为1(比如0100)，则这格不能种花，则i要跳3格才可以种花。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//这个写得比较清晰，但是冗余。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPlaceFlowers</span><span class=\"params\">(<span class=\"type\">int</span>[] flowerbed, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; flowerbed.length &amp;&amp; n &gt;<span class=\"number\">0</span>;)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(flowerbed[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                 i += <span class=\"number\">2</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((flowerbed[i] ==<span class=\"number\">0</span> &amp;&amp; i == flowerbed.length-<span class=\"number\">1</span>) || (flowerbed[i] ==<span class=\"number\">0</span> &amp;&amp; flowerbed[i+<span class=\"number\">1</span>] == <span class=\"number\">0</span>))&#123;</span><br><span class=\"line\">                 n--;</span><br><span class=\"line\">                 i += <span class=\"number\">2</span>;     </span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(flowerbed[i] ==<span class=\"number\">0</span> &amp;&amp; flowerbed[i+<span class=\"number\">1</span>] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                 i +=<span class=\"number\">3</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//这个省略了点。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPlaceFlowers</span><span class=\"params\">(<span class=\"type\">int</span>[] flowerbed, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; flowerbed.length &amp;&amp; n &gt;<span class=\"number\">0</span>;)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(flowerbed[i] == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                 i += <span class=\"number\">2</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i == flowerbed.length-<span class=\"number\">1</span> ||  flowerbed[i+<span class=\"number\">1</span>] == <span class=\"number\">0</span>)&#123;<span class=\"comment\">//因为你的flowerbed[i]不是1就是0，上一步已经判断好了是不是1，所以如果不是1的话自然跳到这里。</span></span><br><span class=\"line\">                 n--;</span><br><span class=\"line\">                 i += <span class=\"number\">2</span>;     </span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 i += <span class=\"number\">3</span>;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"452-用最少数量的箭引爆气球-medium-和435相似\"><a href=\"#452-用最少数量的箭引爆气球-medium-和435相似\" class=\"headerlink\" title=\"452 用最少数量的箭引爆气球 medium(和435相似)\"></a>452 用最少数量的箭引爆气球 medium(和435相似)</h2><p>这个题我的思路是，首先还是对尾巴进行升序排列，然后赋值prev给第一个数的尾巴，开始进行for循环比较第二个数，如果prev大于第二个数的头，也就是这个箭还是可以穿过去，不需要考虑尾巴，因为题目说了头一定比尾巴小。然后如果prev比头小，就说明穿不过去了，这时候就箭的数目加1.以此类推，这个注意count初始值为1，因为本身至少都需要一支箭，可以试试只有一个区间，在循环内counnt是不增加的。这里和435比较：435是不重叠区间，而这里刚好是重叠区间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//看了一遍435后自己写的，注意这里的升序有点和435的不一样，因为会有一个用例存在溢出问题，如果按照435的写。[[-2147483646,-2147483645],[2147483646,2147483647]]，sort后是[[2147483646,2147483647],[-2147483646,-2147483645]]，因为他们相减后会溢出，所以用到小于来比较。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMinArrowShots</span><span class=\"params\">(<span class=\"type\">int</span>[][] points)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(points.length == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(points,<span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span> []&gt;()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] points1, <span class=\"type\">int</span>[] points2)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(points1[<span class=\"number\">1</span>] &lt; points2[<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>,prev = points[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; points.length; i++)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(points[i][<span class=\"number\">0</span>] &gt; prev)&#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                prev = points[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*这个for循环就比较详细，但是没必要，增加运行的时间。</span></span><br><span class=\"line\"><span class=\"comment\">    for(int i = 1; i &lt; points.length; i++)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if(points[i][0] &lt; prev)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">                continue;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">            else if(points[i][0] &gt; prev)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">                count++;</span></span><br><span class=\"line\"><span class=\"comment\">                System.out.println(count);</span></span><br><span class=\"line\"><span class=\"comment\">                prev = points[i][1];</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;           </span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"763-划分字母区间-medium\"><a href=\"#763-划分字母区间-medium\" class=\"headerlink\" title=\"763 划分字母区间 medium\"></a>763 划分字母区间 medium</h2><p>自己想的思路比较复杂，太冗余，而且可能考虑的东西不够全面。官方思路:首先用一个长度为26的数组a把每个字母的最后一个位置进行标记。设置start和end，开始循环字符串，访问每个字母，通过之前a来获取他的最后一个位置endc，令end&#x3D;max（end，endc）。如果循环到i等于end，就说明之前的字母都包括在这个区间内，那就让长度写入partition，并令start&#x3D;end+1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//知识点总结，</span></span><br><span class=\"line\">List&lt;Integer&gt; partition = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">List是一个接口</span></span><br><span class=\"line\"><span class=\"comment\">&lt;&gt;表示了List里面放的对象是什么类型的，上面List里面放的必须是Integer类型的</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">ArrayList类是一个特殊的数组–动态数组。通过添加和删除元素，就可以动态改变数组的长度。</span></span><br><span class=\"line\"><span class=\"comment\">优点：</span></span><br><span class=\"line\"><span class=\"comment\">1、支持自动改变大小 2、可以灵活的插入元素 3、可以灵活的删除元素</span></span><br><span class=\"line\"><span class=\"comment\">局限：</span></span><br><span class=\"line\"><span class=\"comment\">比一般的数组的速度慢一些；</span></span><br><span class=\"line\"><span class=\"comment\">可以调用 List接口里面的内置函数,add,get等方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">last[s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>] = i;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">String s = &quot;www.runoob.com&quot;;</span></span><br><span class=\"line\"><span class=\"comment\">char result = s.charAt(6);</span></span><br><span class=\"line\"><span class=\"comment\">输出为n</span></span><br><span class=\"line\"><span class=\"comment\">所以本题这样的做法，可以把每个字母的最后一个位置记录下来</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">partitionLabels</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">          <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, end = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"type\">int</span>[] last =<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">          List&lt;Integer&gt; partition = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">              last[s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>] = i;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class=\"line\">              end = Math.max(end, last[s.charAt(i) - <span class=\"string\">&#x27;a&#x27;</span>]);</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(i == end)&#123;</span><br><span class=\"line\">                  partition.add(end - start + <span class=\"number\">1</span>);</span><br><span class=\"line\">                  start = end + <span class=\"number\">1</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> partition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"122-买卖股票的最佳时机2-easy-可动态规划\"><a href=\"#122-买卖股票的最佳时机2-easy-可动态规划\" class=\"headerlink\" title=\"122 买卖股票的最佳时机2 easy(可动态规划)\"></a>122 买卖股票的最佳时机2 easy(可动态规划)</h2><p>还是没有独立想出来，想得太复杂，一直纠结怎么用区间来解答。官方解答太多数学公式，总体来说就是只要选择贡献大于0的区间，然后一直累加利润，但是这个做法是不知道第几次买卖的，只能求利润，对于负数，则和0比较就行。秒呀！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">price</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class=\"line\">            price += Math.max(<span class=\"number\">0</span>, prices[i] - prices[i-<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> price;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"406-根据身高重建队列-medium\"><a href=\"#406-根据身高重建队列-medium\" class=\"headerlink\" title=\"406 根据身高重建队列 medium\"></a>406 根据身高重建队列 medium</h2><p><a href=\"https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/\">网友思路</a>：首先遇到这种数对问题，先排序。根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。在本题目中，先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。小陈补充：如果第一个位置降序，第二个位置也降序排，再按照这样写法去插入的话，有部分用例是不能通过的，比如a[[7,0],[6,1],[5,2]]下一个待插入的数是[5,0]，按照算法应该插入到第一个位置，变成a[[5,0],[7,0],[6,1],[5,2]]这时候我们就发现[5,2]已经错误了，因为前面有三个数大于或者等于了。也就是你插入后，你得保证后面没有等于你的数插入，所以，第二个位置的排序，要升序！！！保证同胞小弟位置(第二个位置)先安排好。我们可以这样缕清楚，a里面已经插入的数都是比后面待插入的数大或者相等，如果后面待插入的数第二个位置比a的长度小，那么就是说他来选位置插，反之，他就插到最后面。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//知识点</span></span><br><span class=\"line\"><span class=\"comment\">//这个题可以学到compare对两个位置进行排序的写法，具体看下面的答案这里不多说</span></span><br><span class=\"line\"> List&lt;<span class=\"type\">int</span>[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个的话是双向链表，比创建数组a更加方便，创建数组的话，当你的情况是a的长度大小大于people[i][1]时，你是要插入到a的people[i][1]的位置，这时候你需要进行移动a[people[i][1]]以及后面的每个数据1位，然后才能插进去，这样麻烦。</span></span><br><span class=\"line\"><span class=\"comment\">最后转成list.toArray(new int[list.size()][]);返回即可。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">可以对比763的</span></span><br><span class=\"line\"><span class=\"comment\">List&lt;Integer&gt; partition = new ArrayList&lt;Integer&gt;();</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] reconstructQueue(<span class=\"type\">int</span>[][] people) &#123;</span><br><span class=\"line\">        Arrays.sort(people, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;<span class=\"type\">int</span> []&gt;()&#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(<span class=\"type\">int</span>[] people1, <span class=\"type\">int</span>[] people2)</span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(people1[<span class=\"number\">0</span>] != people2[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> people2[<span class=\"number\">0</span>] - people1[<span class=\"number\">0</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> people1[<span class=\"number\">1</span>] - people2[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        List&lt;<span class=\"type\">int</span>[]&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; people.length; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(list.size() &gt; people[i][<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                list.add(people[i][<span class=\"number\">1</span>],people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                list.add(list.size(),people[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[list.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"665-非递减数列-easy\"><a href=\"#665-非递减数列-easy\" class=\"headerlink\" title=\"665 非递减数列 easy\"></a>665 非递减数列 easy</h2><p>第一次看题看错了，看成只移动一个数。这个题是改变一个数！虽然是easy，但是并不一定easy。<a href=\"https://leetcode-cn.com/problems/non-decreasing-array/solution/yi-ding-yao-rang-ni-nong-dong-wei-shi-ya-u9te/\">网友解答很清晰</a>：本题是要维持一个非递减的数列，所以遇到递减的情况时（nums[i] &gt; nums[i + 1]），要么将前面的元素缩小，要么将后面的元素放大。但是本题唯一的易错点就在这，如果将nums[i]缩小，可能会导致其无法融入前面已经遍历过的非递减子数列；如果将nums[i + 1]放大，可能会导致其后续的继续出现递减；所以要采取贪心的策略，在遍历时，每次需要看连续的三个元素，也就是瞻前顾后，遵循以下两个原则：需要尽可能不放大nums[i + 1]，这样会让后续非递减更困难；如果缩小nums[i]，但不破坏前面的子序列的非递减性；算法步骤:遍历数组，如果遇到递减：还能修改：修改方案1：将nums[i]缩小至nums[i + 1]；修改方案2：将nums[i + 1]放大至nums[i]；不能修改了：直接返回false；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//只能修改一次，让数组递增。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">checkPossibility</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(nums.length == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>] &lt;= nums[<span class=\"number\">1</span>] ? <span class=\"literal\">true</span> : <span class=\"literal\">false</span>;<span class=\"comment\">//一开始第一个数小于第二个数，则拥有一次修改的机会。</span></span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length-<span class=\"number\">1</span> ; i++)&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(nums[i] &gt; nums[i+<span class=\"number\">1</span>])&#123;<span class=\"comment\">//开始出现递减情况。i大于后面一个数了</span></span><br><span class=\"line\">              <span class=\"keyword\">if</span>(flag)&#123;<span class=\"comment\">//如果拥有修改机会</span></span><br><span class=\"line\">                  <span class=\"keyword\">if</span>(nums[i+<span class=\"number\">1</span>] &gt;= nums[i-<span class=\"number\">1</span>])&#123;<span class=\"comment\">//如果i的后面一个数比i的前面一个数大的话，就说明他们是递增，让i缩小的话，也没有破坏非递减性，并且不影响i+1后面的序列。</span></span><br><span class=\"line\">                      nums[i] = nums[i+<span class=\"number\">1</span>];<span class=\"comment\">//这时候就让i缩小</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      nums[i+<span class=\"number\">1</span>] = nums[i];<span class=\"comment\">//这个情况就是i后面的一个数比i前面的一个数小，但是同时i后面的数还小于i，所以只能让i后面的数扩大为i。</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                  flag = <span class=\"literal\">false</span>;<span class=\"comment\">//用掉了唯一的一次修改机会了</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//再出现递减情况，但是已经没有修改机会了，直接返回false。</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//若nums(0) &gt; nums(1)的话，flag是false，且后面没有出现递减，所以已经是可以用修改一次来递增，也就是把第一个数变成第二个数就满足，所以直接返回true。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><h2 id=\"167-两数之和2-easy\"><a href=\"#167-两数之和2-easy\" class=\"headerlink\" title=\"167 两数之和2 easy\"></a>167 两数之和2 easy</h2><p>注意题目给的数组是非递减顺序排列（也就是总体递增，然后可能有两个相邻的数是相等），所以思路上很简单，两个变量去追踪这个数组，一头一尾巴，如果两数之和小于target，左边就需要移动一位，反之则右边需要移动一位。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;<span class=\"comment\">//一开始根据书上思路写的，超时了~~~可能是暴力解法的原因，而且这个代码尚未验证是否正确。</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] numbers, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> numbers.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] ans = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; numbers.length-<span class=\"number\">1</span> &amp;&amp; i &lt; j;)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">if</span>(numbers[i] + numbers[j] == target)</span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               ans[<span class=\"number\">0</span>] = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">               ans[<span class=\"number\">1</span>] = j+<span class=\"number\">1</span>;</span><br><span class=\"line\">              </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[i] + numbers[j] &lt; target)&#123;</span><br><span class=\"line\">               i++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(numbers[i] + numbers[j] &gt; target)&#123;</span><br><span class=\"line\">               j--;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] numbers, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> numbers.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//int[] ans = new int[2];</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt; j)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span>  <span class=\"variable\">sum</span> <span class=\"operator\">=</span> numbers[i] + numbers[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; target)&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i + <span class=\"number\">1</span>, j + <span class=\"number\">1</span>&#125;;<span class=\"comment\">//这样就不用先去定义一个数组了。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"88-合并两个有序数组-easy\"><a href=\"#88-合并两个有序数组-easy\" class=\"headerlink\" title=\"88 合并两个有序数组 easy\"></a>88 合并两个有序数组 easy</h2><p>题目给的是两个非递减数组，思路是用m,n来指向两个数组的尾巴，还有pos来定位。首先要注意是在数组1的基础上去排，不需要额外开辟一个数组。pos定位在数组1的尾巴，开始对比两个数组的尾巴，哪个大就先复制过去。这里最后要注意，如果数组1复制完了，但是数组2还有，务必要记得继续复制。反之如果数组2复制完了，则不需要操作，因为数组1本身就是非递减，而且返回的数组就是他自己。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span> m, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">         <span class=\"type\">int</span> <span class=\"variable\">pos</span> <span class=\"operator\">=</span> m-- + n-- -<span class=\"number\">1</span>;<span class=\"comment\">//这样写的话就少了一步，别忘了数组大小和数组位置是相差1.</span></span><br><span class=\"line\">         <span class=\"keyword\">while</span>(m &gt;= <span class=\"number\">0</span> &amp;&amp; n &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">             nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] :nums2[n--];<span class=\"comment\">//注意是哪个大才会自减减哦。不是每次都自减减。</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">while</span>(n &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">             nums1[pos--] = nums2[n--];<span class=\"comment\">//务必不要忘记如果数组2还没复制完这个事！！！！！此时的数组1已经复制完啦！！！</span></span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"142-环形链表2-medium\"><a href=\"#142-环形链表2-medium\" class=\"headerlink\" title=\"142 环形链表2 medium\"></a>142 环形链表2 medium</h2><p>这个题涉及了一些数学计算，感谢<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/\">网友</a>讲解，这里复述一下：设置两个指针，一个为fast，一个为slow，fast每次走2步，slow每次走1步，设链表为a+b个节点，a为抵达环状的步数，b为环状的节点数。没有环状的链表很容易考虑，这里直接讲有环状的情况，也就是fast和slow会相遇：首先可以得到第一个关系式f&#x3D;2s，这个是slow和fast的步数关系。第二个关系式是f&#x3D;s+nb，因为fast比slow快，所以最终一定能追上，这时候呢，其实fast比slow多走了n个环。根据这两个关系，可以得到<mark>f&#x3D;2nb</mark>,<mark>s&#x3D;nb</mark>。接下来我们考虑，一个指针从头走到环状开头走过的步数<mark>k&#x3D;a+nb</mark>，当n为0，也就是你走了a步到了环状的门口，然后n&#x3D;1的话，你相当于绕了一圈环，然后又到了门口。现在有了三个表达式，从head结点走到入环点需要走:a + nb， 而slow已经走了nb（之前推了相遇的时候他们两个的关系），那么slow再走a步就是入环点了,如何知道slow刚好走了a步？fast从新从head开始和slow指针一起走，再相遇时刚好就是a步。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">detectCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head, slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast == <span class=\"literal\">null</span> || fast.next == <span class=\"literal\">null</span>)&#123;<span class=\"comment\">//注意别忘了是两个条件</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(fast == slow)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slow != fast)&#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"76-最小覆盖子串-hard\"><a href=\"#76-最小覆盖子串-hard\" class=\"headerlink\" title=\"76 最小覆盖子串 hard\"></a>76 最小覆盖子串 hard</h2><p>依旧是<a href=\"https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/993501\">网友</a>的思路，这个题在于需要考虑不少东西，这里简单描述一下：首先是建立一个128的ASCII列表，第一步先记录t中每个字符的数量。定义好l和r初始位置，还有用count去记录还需要的字符数量，这样就不用每次去查看need中哪个字符还大于0。开始while循环，用r去遍历整个S串，经过每个r的位置去提取字符c，首先判断c在need中的情况，如果是大于0，说明这个字符是符合t串的。然后减去一个count，代表已经找到了一个符合的字符，接下来是need中减去字符c的数量，注意，这里也包括不在t中的字符，不在t的中字符减去自然是为负数，代表这个字符是多余的。然后判断count为0的情况，count为0，代表已经找到符合的子串了，但是题目要求的size是最小的，所以可以缩减范围，当l小于r，并且里面有多余的字符，我们首先在need中加回去，然后移动l，然后开始重置size的大小，注意这时候的start变成新的l。接来下是移动l，看看还有没有更小的窗口，注意这里用start去保存这个开始的位置，而不是直接用l，这是有含义的，因为你的r是要遍历整个S串，这样你才知道哪个窗口是最小的，所以只有当size更小时候，我们才去更新更新start值，再加上size大小，就可以找到最小的串位置。这时候你无需当心l和r移动的位置了。务必务必注意，移动l的时候，请记得更新need和count以及l！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">minWindow</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] need = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">128</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span> ; i &lt; t.length() ; i++)&#123;</span><br><span class=\"line\">        need[t.charAt(i)]++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, r = <span class=\"number\">0</span>, start = <span class=\"number\">0</span>, size = Integer.MAX_VALUE, count = t.length();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (r &lt; s.length())&#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> s.charAt(r);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (need[c] &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            count--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        need[c]--;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">while</span>(l &lt; r &amp;&amp; need[s.charAt(l)] &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">               need[s.charAt(l)]++;</span><br><span class=\"line\">               l++;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (r -l + <span class=\"number\">1</span> &lt; size)&#123;</span><br><span class=\"line\">               size = r - l + <span class=\"number\">1</span>;</span><br><span class=\"line\">               start = l;</span><br><span class=\"line\">           &#125; </span><br><span class=\"line\">           need[s.charAt(l)]++;</span><br><span class=\"line\">           count++;</span><br><span class=\"line\">           l++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       r++;</span><br><span class=\"line\">       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size == Integer.MAX_VALUE ? <span class=\"string\">&quot;&quot;</span> : s.substring(start, start + size);</span><br><span class=\"line\">&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"633-平方数之和-medium\"><a href=\"#633-平方数之和-medium\" class=\"headerlink\" title=\"633 平方数之和 medium\"></a>633 平方数之和 medium</h2><p>和167的很像，这里<a href=\"https://leetcode-cn.com/problems/sum-of-square-numbers/solution/shuang-zhi-zhen-de-ben-zhi-er-wei-ju-zhe-ebn3/\">网友</a>非常详细说明为什么i++和j–不会错过答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">judgeSquareSum</span><span class=\"params\">(<span class=\"type\">int</span> c)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j =(<span class=\"type\">long</span>) Math.sqrt(c);<span class=\"comment\">//如果直接写成c，会超时。理论上也是应该对的。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i &lt;= j)&#123;</span><br><span class=\"line\">       <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> i*i + j*j;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>( sum == c )&#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>( sum &lt; c )&#123;</span><br><span class=\"line\">           i++;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           j--;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"680-验证回文字符串2-easy\"><a href=\"#680-验证回文字符串2-easy\" class=\"headerlink\" title=\"680 验证回文字符串2 easy\"></a>680 验证回文字符串2 easy</h2><p>这个题虽然是简单题，但是还是看了<a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/solution/cong-liang-ce-xiang-zhong-jian-zhao-dao-bu-deng-de/403606\">网友</a>思路：用双指针去对比，一个在头l，一个在尾巴r，当遇到不相等的情况，我们可以让l加1个位置，或者让r减去一个位置，因为题目说了可以最多删除一个字符，然后再用一个函数去对比子字符串。这里我一开始想到的是用一个计数器去判断删除的次数，后来发现其实不需要，比如abxbgga，要删除两次才行，你只要仔细看代码，发现只要一次之后不行就直接false了，所以不用考虑加一个计数器的问题，那么删除一个字符是体现在r-1或者l+1上</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">validPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, r = s.length()-<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> judegesub(s, l+<span class=\"number\">1</span>, r) || judegesub(s, l, r-<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">judegesub</span><span class=\"params\">(String s, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        l++;</span><br><span class=\"line\">        r--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"524-通过删除字母匹配到字典里最长单词-medium\"><a href=\"#524-通过删除字母匹配到字典里最长单词-medium\" class=\"headerlink\" title=\"524 通过删除字母匹配到字典里最长单词 medium\"></a>524 通过删除字母匹配到字典里最长单词 medium</h2><p>这个题我一开始考虑的是，首先跟上一个题的区别是，这个题的意思是可以删除好几个元素，然后第二个不同的是，这个题有多个词，是不是要用暴力算法一个个去看？看了官方解答后，发现被上一题绕进去了。大概重复下解法：用双指针思路，i和j分别指向t(字典中的词)和s的第一个字母，注意这里是每个字典的词都会遍历，然后如果匹配，则i和j同时移动一位，如果不匹配，i不动，j+1。直到最后i要是等于这个词的长度的话，就代表全部匹配到。注意这里是长度，长度和单词最后一个字符位置是相差1的。题目中说要长度最长和序号最低的。所以自然有一个长度对比以及序号对比，序号对比是用compareTo函数，这个是对比ASCII对比，也就是序号在前的话是小于0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//知识点</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">findLongestWord</span><span class=\"params\">(String s, List&lt;String&gt; dictionary)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String t : dictionary) &#123;</span><br><span class=\"line\">          System.out.print(t);</span><br><span class=\"line\">          System.out.print(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//输入是[&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]这里会依次输出ale apple monkey plea </span></span><br><span class=\"line\"></span><br><span class=\"line\">关于compareTo:</span><br><span class=\"line\">返回值是整型，它是先比较对应字符的大小(ASCII码顺序)如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的长度差值，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。</span><br><span class=\"line\"></span><br><span class=\"line\">如果参数字符串等于此字符串，则返回值 <span class=\"number\">0</span>；</span><br><span class=\"line\">如果此字符串小于字符串参数，则返回一个小于 <span class=\"number\">0</span> 的值；</span><br><span class=\"line\">如果此字符串大于字符串参数，则返回一个大于 <span class=\"number\">0</span> 的值。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">findLongestWord</span><span class=\"params\">(String s, List&lt;String&gt; dictionary)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String t : dictionary) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt; t.length() &amp;&amp; j &lt; s.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">                    ++i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                ++j;<span class=\"comment\">//注意这里，如果匹配的话，j是在这里++，而不是在上面的if语句，因为这里还有一个就是如果不匹配的话，j也要++，而这时候i不变，所以这个写法可以同时满足两个条件</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == t.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t.length() &gt; res.length() || (t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                    res = t;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><h2 id=\"69-Sqrt-x-easy\"><a href=\"#69-Sqrt-x-easy\" class=\"headerlink\" title=\"69 Sqrt(x) easy\"></a>69 Sqrt(x) easy</h2><p>这个题是看了官方解法，其实思路就是二分法，每次寻找中间值，如果中间值的平方小于输入值，则把左边的边界设置为mid+1，反之如果大于输入值，则把右边界设置为mid-1，这里注意一个问题就是mid * mid前面要加long，不然超过范围。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">mySqrt</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, r = x, ans = -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt;= r) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> l + (r - l) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((<span class=\"type\">long</span>) mid * mid &lt;= x)&#123;</span><br><span class=\"line\">                ans = mid;</span><br><span class=\"line\">                l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"34-在排序数组中查找元素的第一个和最后一个位置-medium\"><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置-medium\" class=\"headerlink\" title=\"34 在排序数组中查找元素的第一个和最后一个位置 medium\"></a>34 在排序数组中查找元素的第一个和最后一个位置 medium</h2><p>这里有一个网友的<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/\">二分法模板</a>，关于这个题，分了两步，首先是寻找第一个target，循环内部条件是num[mid]大于等于target，然后用模板1，寻找最后出现的target，用模板2。至于为什么分开模板1和2，有个网友解释很清楚：因为取左边第一个target时，当nums[mid]&#x3D;&#x3D;target时，中间位置的右边元素一定不是target出现的第一个位置，所以下次搜索区间是[left,mid],right&#x3D;mid;取最后一个target时，当nums[mid]&#x3D;&#x3D;target时，中间位置的左边元素一定不是target出现的最后一个位置，所以下次搜索区间是[mid，right],left&#x3D;mid。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//模板1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">bsearch_1</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check(mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//模板2</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">bsearch_2</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> ( l + r + <span class=\"number\">1</span> ) /<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (check(mid)) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">总结归纳：当l=mid时，mid=(l+r+1)/2，当l=mid+1，mid=(l+r)/2，至于为什么请看网友解释，这个题要多次理解。</span></span><br><span class=\"line\"><span class=\"comment\">这里复制了网友的解释：什么时候用模板1，什么时候用模板2？</span></span><br><span class=\"line\"><span class=\"comment\">假设初始时我们的二分区间为[l,r]，每次二分缩小区间时，如果左边界l要更新为 l = mid，此时我们就要使用模板2，让 mid = (l + r + 1)/ 2，否则while会陷入死循环。如果左边界l更新为l = mid + 1,此时我们就使用模板1，让mid = (l + r)/2。因此，模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l = mid，那么在计算mid时需要加上1，否则如果写完之后发现是l = mid + 1，那么在计算mid时不能加1。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] searchRange(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;-<span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;<span class=\"comment\">//上来就要记住这个。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt;= target) r = mid ;<span class=\"comment\">//比目标值大，则寻找左区间，右边变为mid，左边不动。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;<span class=\"comment\">//比目标值小，寻找右区间，左边变成mid+1，右边不动。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums[r] != target) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;-<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;<span class=\"comment\">//这个特别容易忘记的。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">L</span> <span class=\"operator\">=</span> r;</span><br><span class=\"line\">        l = <span class=\"number\">0</span>; r = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r)&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (l + r + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt;= target) l = mid ;<span class=\"comment\">//比目标值小，寻找右区间，左边变成mid，右边不变。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;<span class=\"comment\">//比目标值大，寻找左区间，右边变成mid-1，左边不变。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;L,r&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"81-搜索旋转排序数组-II-medium\"><a href=\"#81-搜索旋转排序数组-II-medium\" class=\"headerlink\" title=\"81 搜索旋转排序数组 II medium\"></a>81 搜索旋转排序数组 II medium</h2><p>找数组的目标数，这个题就是说本来的数组是增序的，但是现在相当于在中间断开，然后再连起来，就变成一个旋转数组。所以，旋转数组的特性的有一部分是增序的。先依旧找到中点位置，后面解释看代码。这个<a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/\">coder</a>把一些情况得很清楚。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">解题思路：</span></span><br><span class=\"line\"><span class=\"comment\">本题是需要使用二分查找，怎么分是关键，举个例子：</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第一类</span></span><br><span class=\"line\"><span class=\"comment\">1011110111 和 1110111101 这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。</span></span><br><span class=\"line\"><span class=\"comment\">第二类</span></span><br><span class=\"line\"><span class=\"comment\">22 33 44 55 66 77 11 这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；</span></span><br><span class=\"line\"><span class=\"comment\">这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。</span></span><br><span class=\"line\"><span class=\"comment\">第三类</span></span><br><span class=\"line\"><span class=\"comment\">66 77 11 22 33 44 55 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；</span></span><br><span class=\"line\"><span class=\"comment\">这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, end = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (start + end) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[start] == nums[mid])&#123;<span class=\"comment\">//因为数组会存在重复数字，如果中点和左端相等，我们不能确定在左区间全部相等，还是右边区间全部相等，这种情况，可以把start右移动一个，当然这种操作我们不能说是完全的二分法，这个题只是部分地方用到二分法。</span></span><br><span class=\"line\">                start++;<span class=\"comment\">//无法判断哪个区间是增序的</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt;= nums[end]) &#123;<span class=\"comment\">//右区间是增序的</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;<span class=\"comment\">//然后在右区间内判断target，用二分法。target在mid和end中间，这里需要注意，target是要小于等于end。我觉得要这么去想，你想如果都等于mid，那肯定是直接返回true，所以有mid比较这边是开区间</span></span><br><span class=\"line\">                    start = mid + <span class=\"number\">1</span>;<span class=\"comment\">//就让start移动到mid右边</span></span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    end = mid -<span class=\"number\">1</span>;<span class=\"comment\">//反之，让end移动到mid左边</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//这个情况则是左区间增序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123;<span class=\"comment\">//这里需要注意，target是要大于等于start</span></span><br><span class=\"line\">                    end = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    start = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"154-寻找旋转排序数组中的最小值-II-hard\"><a href=\"#154-寻找旋转排序数组中的最小值-II-hard\" class=\"headerlink\" title=\"154 寻找旋转排序数组中的最小值 II hard\"></a>154 寻找旋转排序数组中的最小值 II hard</h2><p>这个题也是旋转数组，和上个题的区别是，1.上个题是找target，这个题是找最小值。2.这个题旋转多次。<a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/\">这个作者解释得不错</a>，把作者思路拷贝到了下面了，注意一下这个题，旋转后每个数字的序号保持原来不变，也就是原来是0位置，旋转后序号还是0。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    -思路-</span></span><br><span class=\"line\"><span class=\"comment\">    旋转数组肯定将nums分为两个有序的数组，分为别nums1和nums2。并且假设nums1中的元素均大于等于nums2中的元素</span></span><br><span class=\"line\"><span class=\"comment\">    那么我们要求的元素就是nums2的首元素</span></span><br><span class=\"line\"><span class=\"comment\">    --步骤--</span></span><br><span class=\"line\"><span class=\"comment\">    如果nums[mid] &gt; nums[right],说明此时的mid严格的在nums1当中。（这时候最小值在[mid,right]上？所以把区间缩到这来，我理解的），那么nums2的首元素设为i的话，就应当是：mid &lt; i &lt;= right。</span></span><br><span class=\"line\"><span class=\"comment\">    取left = mid + 1;附其他解释：当 nums[mid] &gt; nums[right]时，mid一定在第 1 个排序数组中，i 一定满足 mid &lt; i &lt;= right，因此执行 left = mid + 1；</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    如果nums[mid] &lt; nums[right],说明此时的mid严格的在nums2当中。（这时候最小值在[left,mid]上？所以把区间缩到这来，我理解的）也就是：mid &lt;= i &lt; right</span></span><br><span class=\"line\"><span class=\"comment\">    取right = mid(注意这里没有mid-1)；附其他作者解释：当 nums[mid] &lt; nums[right] 时，mid 一定在第 2 个排序数组中，i一定满足 left &lt; i &lt;= mid，因此执行 right = mid；</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    如果nums[mid] == nums[right],细分为三种情况。</span></span><br><span class=\"line\"><span class=\"comment\">        情况一：[1,1,1,1,1,1,1,1]</span></span><br><span class=\"line\"><span class=\"comment\">        情况二：[4,5,6,7,1,1,1,1,1,1]</span></span><br><span class=\"line\"><span class=\"comment\">        情况二：[4,5,6,7,0,1,1,1,1,1]</span></span><br><span class=\"line\"><span class=\"comment\">    取right--便可，这个很关键！！！！</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    另外一个作者解释了为什么这样：</span></span><br><span class=\"line\"><span class=\"comment\">    我们采用 right = right - 1 解决此问题，证明：</span></span><br><span class=\"line\"><span class=\"comment\">    此操作不会使数组越界：因为迭代条件保证了 right &gt; left &gt;= 0；</span></span><br><span class=\"line\"><span class=\"comment\">    此操作不会使最小值丢失：假设 nums[right]是最小值，有两种情况：</span></span><br><span class=\"line\"><span class=\"comment\">    若 nums[right]是唯一最小值：那就不可能满足判断条件 nums[mid] == nums[right]，因为 mid &lt; right（left != right 且 mid = (left + right) // 2 向下取整）；</span></span><br><span class=\"line\"><span class=\"comment\">    若 nums[right]不是唯一最小值，由于 mid &lt; right 而 nums[mid] == nums[right]，即还有最小值存在于 [left, right - 1][left,right−1] 区间，因此不会丢失最小值。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">作者：jyd</span></span><br><span class=\"line\"><span class=\"comment\">链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/</span></span><br><span class=\"line\"><span class=\"comment\">来源：力扣（LeetCode）</span></span><br><span class=\"line\"><span class=\"comment\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMin</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == nums[right]) &#123;</span><br><span class=\"line\">                right--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[right]; <span class=\"comment\">//貌似nums[left]也是可以的。其实看了下，最后left=mid+1也就是等于right，所以这样也就是两种写法都是一样。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"540-有序数组中的单一元素-meidum\"><a href=\"#540-有序数组中的单一元素-meidum\" class=\"headerlink\" title=\"540. 有序数组中的单一元素 meidum\"></a>540. 有序数组中的单一元素 meidum</h2><p>这个题是找到唯一的单身狗，注意题目是升序的，不过貌似与升序没关系。这里先整理下官方的清晰解答：因为这个模块是讲二分法，所以不讲解暴力算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">首先要知道，这个数组一定是奇数个，因为只有一个单身狗！</span></span><br><span class=\"line\"><span class=\"comment\">用 halvesAreEven = (right - mid) % 2 == 0来判断哪一侧元素为奇数，因为单身狗肯定在这一侧。</span></span><br><span class=\"line\"><span class=\"comment\">情况1：mid 和 mid+1是同元素。然后mid元素把两侧都分为偶数个，当我们把mid+1拿掉后，右侧就变成奇数个了，也就是右侧肯定存在单身狗，设置left = mid + 2</span></span><br><span class=\"line\"><span class=\"comment\">情况2；mid 和 mid+1是同元素。然后mid元素把两侧都分为奇数个，当我们把mid+1拿掉后，右侧是偶数个，所以左侧存在单身狗，设置right = mid - 1 </span></span><br><span class=\"line\"><span class=\"comment\">情况3：mid 和 mid-1是同元素。然后mid元素把两侧都分为偶数个，当我们把mid-1拿掉后，左侧就是奇数个了，所以左侧存在单身狗，设置right = mid - 2</span></span><br><span class=\"line\"><span class=\"comment\">情况4：mid 和 mid-1是同元素。然后mid元素把两侧都分为奇数个，当我们把mid-1拿掉后，右侧就存在单身狗，所以left = mid + 1</span></span><br><span class=\"line\"><span class=\"comment\">首先判断mid和左边还是右边的元素相等，然后通过halvesAreEven判断左右两侧是奇还是偶。</span></span><br><span class=\"line\"><span class=\"comment\">这里只举例情况1和2，因为这是放在一起的。现在已经知道了mid和mid+1相等，然后再想，如果mid把两侧分为了偶数个(单纯讲个数，与数组位置无关)，也就是mid的位置是一个偶数(数组从0计算)，然后整个数组肯定是奇数个，也就是最后一个数的位置也是偶数，所以当halvesAreEven为true，就说明符合情况1，反之符合情况2。</span></span><br><span class=\"line\"><span class=\"comment\">注意写代码的时候别忘了mid就是单身狗的情况。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">下面这个方法也是二分，但是仅对偶数索引进行二分搜索，比上面的方法简洁，而且不用单独考虑mid是单身狗的情况，因为else就是包含了mid是单身狗或者左侧存在单身狗。</span></span><br><span class=\"line\"><span class=\"comment\">然后就是简洁点，整理下上面的思路，我们确保mid是偶数的位置，如果是奇数就减去1，然后检查 mid 的元素是否与其后面的索引相同。如果相同，则我们知道 mid 不是单个元素。</span></span><br><span class=\"line\"><span class=\"comment\">且单个元素在 mid 之后。则我们将 left 设置为 mid + 2。</span></span><br><span class=\"line\"><span class=\"comment\">如果不是，则我们知道单个元素位于 mid，或者在 mid 之前。我们将 right 设置为 mid。</span></span><br><span class=\"line\"><span class=\"comment\">一旦 left == right，则当前搜索空间为 1 个元素，那么该元素为单个元素，我们将返回它。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">知识点：int mid = left + (right - left) / 2;</span></span><br><span class=\"line\"><span class=\"comment\">为什么前面还要加left?因为防止超出整型数据溢出。可以看看前面的题有没有这种情况！！</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">singleNonDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (mid % <span class=\"number\">2</span> == <span class=\"number\">1</span> ) mid--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == nums[mid+<span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nums[right];<span class=\"comment\">//left也可以，第一次写的时候写成了mid，先不说结果对不对，这里语法就存在问题，因为mid在while里面，所以系统会检测不到mid，是一个局部变量。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-寻找两个正序数组的中位数-hard\"><a href=\"#4-寻找两个正序数组的中位数-hard\" class=\"headerlink\" title=\"4 寻找两个正序数组的中位数 hard\"></a>4 寻找两个正序数组的中位数 hard</h2><p>这个题虽然看上去是可以合并起来去找，但是，由于有时间复杂度的要求，所以用二分法比较好，坦白说，确实hard。详细解释<a href=\"https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/\">点击这里看解法三</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用的代码是官方的，但是上面说的解释更清楚。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">findMedianSortedArrays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length1</span> <span class=\"operator\">=</span> nums1.length, length2 = nums2.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totallength</span> <span class=\"operator\">=</span> length1 + length2;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totallength % <span class=\"number\">2</span> == <span class=\"number\">1</span>)&#123;<span class=\"comment\">//两个数组长度和为奇数情况</span></span><br><span class=\"line\">           <span class=\"type\">int</span> <span class=\"variable\">midIndex</span> <span class=\"operator\">=</span> totallength / <span class=\"number\">2</span>;<span class=\"comment\">//注意totallength是个数，而不是数组中的序号(从0开始)。</span></span><br><span class=\"line\">           <span class=\"type\">double</span> <span class=\"variable\">median</span> <span class=\"operator\">=</span> getKthElement(nums1, nums2, midIndex + <span class=\"number\">1</span>);</span><br><span class=\"line\">           <span class=\"keyword\">return</span> median;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//两个数组长度合为偶数情况</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">midIndex1</span> <span class=\"operator\">=</span> totallength / <span class=\"number\">2</span> -<span class=\"number\">1</span>, midIndex2 =totallength / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">double</span> <span class=\"variable\">median</span> <span class=\"operator\">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class=\"number\">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class=\"number\">1</span>)) / <span class=\"number\">2.0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> median;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getKthElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//下面是官方写的</span></span><br><span class=\"line\">        <span class=\"comment\">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class=\"line\"><span class=\"comment\">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class=\"line\"><span class=\"comment\">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class=\"line\"><span class=\"comment\">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class=\"line\"><span class=\"comment\">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length1</span> <span class=\"operator\">=</span> nums1.length, length2 = nums2.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index1</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, index2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">kthElement</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;<span class=\"comment\">//边界情况</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index1 == length1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums2[index2 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index2 == length2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> nums1[index1 + k - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (k == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//当k剩下一个的时候，也就是比较剩下哪个数谁比较小。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//正常情况 </span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">half</span> <span class=\"operator\">=</span> k / <span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newIndex1</span> <span class=\"operator\">=</span> Math.min(index1 + half, length1) - <span class=\"number\">1</span>;<span class=\"comment\">// k/2-1</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">newIndex2</span> <span class=\"operator\">=</span> Math.min(index2 + half, length2) - <span class=\"number\">1</span>;<span class=\"comment\">// k/2-1</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">pivot1</span> <span class=\"operator\">=</span> nums1[newIndex1] ,pivot2 = nums2[newIndex2];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class=\"line\">                k = k -(newIndex1 - index1 + <span class=\"number\">1</span>);</span><br><span class=\"line\">                index1 = newIndex1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                k = k -(newIndex2 - index2 + <span class=\"number\">1</span>);<span class=\"comment\">//加1是因为要去掉pivot这个元素</span></span><br><span class=\"line\">                index2 = newIndex2 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//这个是while语句的结束</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//由于这个题实在是费脑，这里详细举例子，按照代码思路一步步来</span></span><br><span class=\"line\">nums1:<span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">9</span></span><br><span class=\"line\">nums2:<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span></span><br><span class=\"line\">开始计算： </span><br><span class=\"line\">length1=<span class=\"number\">4</span>,length2=<span class=\"number\">9</span></span><br><span class=\"line\">totallength=<span class=\"number\">13</span></span><br><span class=\"line\">判断为奇数，midIndex=<span class=\"number\">6</span> 传入到子函数(nums1，nums2,<span class=\"number\">6</span>+<span class=\"number\">1</span>)<span class=\"comment\">//也就是第7个数是中位数</span></span><br><span class=\"line\"></span><br><span class=\"line\">下面是子函数循环情况</span><br><span class=\"line\"></span><br><span class=\"line\">下面说的 排 是指两个数组合并起来，从小到大排第几个的意思</span><br><span class=\"line\">length1=<span class=\"number\">4</span>,length2=<span class=\"number\">9</span></span><br><span class=\"line\">正常情况</span><br><span class=\"line\">第一轮<span class=\"keyword\">while</span></span><br><span class=\"line\">half=<span class=\"number\">7</span>/<span class=\"number\">2</span>=<span class=\"number\">3</span></span><br><span class=\"line\">newIndex1=<span class=\"number\">3</span>-<span class=\"number\">1</span>=<span class=\"number\">2</span>,newIndex2=<span class=\"number\">3</span>-<span class=\"number\">1</span>=<span class=\"number\">2</span><span class=\"comment\">//比较nums1[k/2-1],nums2[k/2-1]的元素，本题也就是nums1[2],nums2[2]</span></span><br><span class=\"line\"></span><br><span class=\"line\">[pivot]元素</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">3</span> [<span class=\"number\">4</span>] <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> [<span class=\"number\">3</span>] <span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>    可以看出nums2[<span class=\"number\">2</span>]的更小，把nums2[<span class=\"number\">2</span>]及其前面元素全部去掉，然后更新index2和k</span><br><span class=\"line\"></span><br><span class=\"line\">这里需要理解为什么更新k和index2，我们要找的数是排序第七个(不是从<span class=\"number\">0</span>计算)的数，然后分别比较两个数组的nums[k/<span class=\"number\">2</span>-<span class=\"number\">1</span>]</span><br><span class=\"line\">nums1 中小于等于 pivot1 的元素有 nums1[<span class=\"number\">0</span> .. k/<span class=\"number\">2</span>-<span class=\"number\">2</span>] 共计 k/<span class=\"number\">2</span>-<span class=\"number\">1</span> 个，本题也就是<span class=\"number\">2</span>个</span><br><span class=\"line\">nums2 中小于等于 pivot2 的元素有 nums1[<span class=\"number\">0</span> .. k/<span class=\"number\">2</span>-<span class=\"number\">2</span>] 共计 k/<span class=\"number\">2</span>-<span class=\"number\">1</span> 个，本题也就是<span class=\"number\">2</span>个</span><br><span class=\"line\">然后取两个数组中比较小的pivot，本题是num2[<span class=\"number\">2</span>],可以推导，两个数组中小于等于 pivot 的元素共计不会超过 (k/<span class=\"number\">2</span>-<span class=\"number\">1</span>) + (k/<span class=\"number\">2</span>-<span class=\"number\">1</span>) &lt;= k-<span class=\"number\">2</span> 个，也就是全部元素合并后小于等于nums2[<span class=\"number\">2</span>]元素的不超过<span class=\"number\">5</span>个，如果按照等式左边是为<span class=\"number\">4</span>个，因为是整除，如果按照等式右边就直接是<span class=\"number\">5</span>个。</span><br><span class=\"line\">这样的话，即便取pivot本身最大也只能是第 k-<span class=\"number\">1</span> 小的元素，也就是<span class=\"number\">6</span>，但是按照上一行的分析，pivot元素是排第<span class=\"number\">5</span>或者第<span class=\"number\">6</span>，本题的话实际是排第<span class=\"number\">5</span>。</span><br><span class=\"line\">总之还不是第七个我们要找的元素。那么可以完全排除nums[<span class=\"number\">2</span>]和左边的元素，这时候就要更新k和index2</span><br><span class=\"line\">k更新：因为本身要找第<span class=\"number\">7</span>个元素，现在已经排除了<span class=\"number\">3</span>个元素了，所以k=<span class=\"number\">7</span>-<span class=\"number\">3</span>=<span class=\"number\">4</span>，也就是在剩下的数组中找排第四个的元素，具体写法是<span class=\"number\">7</span>-（<span class=\"number\">2</span>-<span class=\"number\">0</span>+<span class=\"number\">1</span>)=<span class=\"number\">4</span></span><br><span class=\"line\">index2更新： index2=<span class=\"number\">2</span>+<span class=\"number\">1</span>=<span class=\"number\">3</span>，也就是从nums2[<span class=\"number\">3</span>]开始</span><br><span class=\"line\">index1依旧为<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">第二轮<span class=\"keyword\">while</span>   </span><br><span class=\"line\">half=<span class=\"number\">4</span>/<span class=\"number\">2</span>=<span class=\"number\">2</span></span><br><span class=\"line\">newIndex1=<span class=\"number\">0</span>+<span class=\"number\">2</span>-<span class=\"number\">1</span>=<span class=\"number\">1</span>,newIndex2=<span class=\"number\">3</span>+<span class=\"number\">2</span>-<span class=\"number\">1</span>=<span class=\"number\">4</span></span><br><span class=\"line\">下面标记|，代表左边的元素也就消除。</span><br><span class=\"line\"><span class=\"number\">1</span> [<span class=\"number\">3</span>] <span class=\"number\">4</span> <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> | <span class=\"number\">4</span> [<span class=\"number\">5</span>] <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span></span><br><span class=\"line\">经过比较后，nums1[<span class=\"number\">1</span>]及其左边消除</span><br><span class=\"line\">k更新：因为本身要找第<span class=\"number\">4</span>个元素，现在已经排除了<span class=\"number\">2</span>个元素了，所以k=<span class=\"number\">4</span>-<span class=\"number\">2</span>=<span class=\"number\">2</span>，也就是在剩下的数组中找排第二个的元素，具体写法是<span class=\"number\">4</span>-（<span class=\"number\">1</span>-<span class=\"number\">0</span>+<span class=\"number\">1</span>)=<span class=\"number\">2</span></span><br><span class=\"line\">index1更新： index1=<span class=\"number\">1</span>+<span class=\"number\">1</span>=<span class=\"number\">2</span>，也就是从nums1[<span class=\"number\">2</span>]开始</span><br><span class=\"line\">index2依旧为<span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">第三轮<span class=\"keyword\">while</span></span><br><span class=\"line\">half=<span class=\"number\">2</span>/<span class=\"number\">2</span>=<span class=\"number\">1</span></span><br><span class=\"line\">newIndex1=<span class=\"number\">2</span>+<span class=\"number\">1</span>-<span class=\"number\">1</span>=<span class=\"number\">2</span>,newIndex2=<span class=\"number\">3</span>+<span class=\"number\">1</span>-<span class=\"number\">1</span>=<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">3</span> | [<span class=\"number\">4</span>] <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> | [<span class=\"number\">4</span>] <span class=\"number\">5</span> <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span></span><br><span class=\"line\">这里pivot元素相等，我们就假设上面的<span class=\"number\">4</span>大于下面的<span class=\"number\">4</span>，由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 <span class=\"number\">1</span> 个总会保留 <span class=\"number\">1</span> 个的，所以没有影响。</span><br><span class=\"line\">经过比较后，nums2[<span class=\"number\">3</span>]及其左边消除。</span><br><span class=\"line\">k更新：因为本身要找第<span class=\"number\">2</span>个元素，现在已经排除了<span class=\"number\">1</span>个元素了，所以k=<span class=\"number\">2</span>-<span class=\"number\">1</span>=<span class=\"number\">1</span>，也就是在剩下的数组中找排第二个的元素，具体写法是<span class=\"number\">2</span>-（<span class=\"number\">0</span>-<span class=\"number\">0</span>+<span class=\"number\">1</span>)=<span class=\"number\">1</span></span><br><span class=\"line\">index2更新： index2=<span class=\"number\">3</span>+<span class=\"number\">1</span>=<span class=\"number\">4</span>，也就是从nums2[<span class=\"number\">4</span>]开始</span><br><span class=\"line\">index1依旧为<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">第四轮<span class=\"keyword\">while</span></span><br><span class=\"line\">k已经等于<span class=\"number\">1</span>了，直接找剩下比较小的数就行。</span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">3</span> | [<span class=\"number\">4</span>] <span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> | [<span class=\"number\">5</span>] <span class=\"number\">6</span> <span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span></span><br><span class=\"line\">答案就是<span class=\"number\">4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">当然还有注意边界的情况，本题没有涉及。</span><br><span class=\"line\">所谓边界的问题,也就是有可能其中一个数组过小，然后进行更新的时候会发现越界，这时候也就是这个小的数组数组全部已经小于第K个数据，然后我们之后关注大的数组找到k就行。</span><br></pre></td></tr></table></figure>\n<h1 id=\"常用排序算法\"><a href=\"#常用排序算法\" class=\"headerlink\" title=\"常用排序算法\"></a>常用排序算法</h1><p><img src=\"/images/leetcode-java/4.jpg\" alt=\"排序算法\"></p>\n<h2 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//本代码是可执行代码，后面的排序算法可以直接用在本模板调用。</span></span><br><span class=\"line\"><span class=\"comment\">//快速排序就是每次把第一个数选为枢轴元素，然后左右扫描，右边扫描比它小的交换，左边扫描比它大的交换，最后放到正确的位置，最终左边的元素都比它小，右边的元素都比它大，然后左右递归。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">sort</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> arr[] = &#123;<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>,<span class=\"number\">99</span>,<span class=\"number\">77</span>,<span class=\"number\">44</span>&#125;;<span class=\"comment\">//初始化数组时用new与不用new是没区别的</span></span><br><span class=\"line\">        <span class=\"type\">int</span> temp[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[arr.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> arr.length;</span><br><span class=\"line\">        quick_sort(arr, <span class=\"number\">0</span>, size);<span class=\"comment\">//实现快速排序</span></span><br><span class=\"line\">        <span class=\"comment\">//insertion_sort(arr,size);//实现插入排序</span></span><br><span class=\"line\">        <span class=\"comment\">//merge_sort(arr, 0, size, temp);//实现归并排序</span></span><br><span class=\"line\">        <span class=\"comment\">//bubble_sort(arr, 0, size);//实现冒泡排序</span></span><br><span class=\"line\">        <span class=\"comment\">//select_sort(arr,size);实现选择排序</span></span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));<span class=\"comment\">//输出结果</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">quick_sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr,<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;<span class=\"comment\">//左闭右闭区间，也就是right一开始输入的是size</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left + <span class=\"number\">1</span> &gt;= right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> left, last = right - <span class=\"number\">1</span>, key = arr[first];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &lt;last) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (first &lt; last &amp;&amp; arr[last] &gt;= key) &#123;<span class=\"comment\">//右边扫描</span></span><br><span class=\"line\">                --last;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[first] = arr[last];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (first &lt; last &amp;&amp; arr[first] &lt;= key) &#123;<span class=\"comment\">//左边扫描</span></span><br><span class=\"line\">                ++first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            arr[last] = arr[first];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[first] = key;<span class=\"comment\">//把枢轴元素放到正确的位置</span></span><br><span class=\"line\">        quick_sort(arr, left, first);<span class=\"comment\">//左边递归</span></span><br><span class=\"line\">        quick_sort(arr, first + <span class=\"number\">1</span>, right);<span class=\"comment\">//右边递归</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从第二个数开始，只要比前面小就一直交换。这样每轮的前i个数都是从小到大排好序，就好像插队一样，一直插。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insertion_sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> size)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class=\"number\">1</span>]; j--) &#123;<span class=\"comment\">//别忘了防止越界的问题，j&gt;0。</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[j-<span class=\"number\">1</span>];</span><br><span class=\"line\">            arr[j-<span class=\"number\">1</span>] = arr[j];</span><br><span class=\"line\">            arr[j] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//每次把未排序中最小的数选出来，然后和前面未排序第一个数交换。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">select_sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr,<span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> small;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; right - <span class=\"number\">1</span>; i++) &#123;<span class=\"comment\">//这里写成right也是没有问题的，但是right的话理论上来说多做了一步无用功</span></span><br><span class=\"line\">        small = i;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; right; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[small]) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[j];</span><br><span class=\"line\">                arr[j] = arr[small];</span><br><span class=\"line\">                arr[small] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h2><figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">归并排序采用了分治的思想。将数字分成许多小块，每块排序，然后再把块逐步合并起来。</span></span><br><span class=\"line\"><span class=\"comment\">重点：最终合并的时候需要一个临时数组来存储合并数据。合并的时候左右两边是两个排好序的数组，现在要把它们组合起来。关键点就在于判断每一次放入临时数组的是左侧还是右侧的数据。</span></span><br><span class=\"line\"><span class=\"comment\">first和second代表左右侧</span></span><br><span class=\"line\"><span class=\"comment\">如果左侧比右侧小，而且此时两个数组都没越界，左侧的数输入到temp。</span></span><br><span class=\"line\"><span class=\"comment\">如果左侧越界，那么右侧读入。</span></span><br><span class=\"line\"><span class=\"comment\">如果右侧越界，那么左侧读入。</span></span><br><span class=\"line\"><span class=\"comment\">综合起来，读入左侧数据的条件即为右侧越界或者左侧没越界且左侧比右侧小。</span></span><br><span class=\"line\"><span class=\"comment\">最后再改变nums</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">merge_sort</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right, vector&lt;<span class=\"type\">int</span>&gt; &amp;temp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//C++版本</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left + <span class=\"number\">1</span> &gt;= right) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> mid = left + (right - left) / <span class=\"number\">2</span>;<span class=\"comment\">//寻找中间数的位置</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">merge_sort</span>(nums, left, mid, temp);<span class=\"comment\">//左侧递归</span></span><br><span class=\"line\">    <span class=\"built_in\">merge_sort</span>(nums, mid, right, temp);<span class=\"comment\">//右侧递归</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"type\">int</span> first = left, second = mid, i = left;</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (first &lt; mid || second &lt; right) &#123;   <span class=\"comment\">//first是左侧边界开始，second是右侧边界开始</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (second &gt;= r || (nums[first] &lt;= nums[second] &amp;&amp; first &lt; mid)) &#123;<span class=\"comment\">//右侧越界或者是 左侧没有越界，并且左侧的first位置比右侧的second位置小</span></span><br><span class=\"line\">        temp[i++] = nums[first++];<span class=\"comment\">//那就左侧写入temp</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        temp[i++] = nums[second++];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"keyword\">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class=\"line\">        nums[i] = temp[i];</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">merge_sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr,<span class=\"type\">int</span> left, <span class=\"type\">int</span> right, <span class=\"type\">int</span>[] temp)</span> &#123;<span class=\"comment\">//左闭右开区间哦，所以right进来是size</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left + <span class=\"number\">1</span> &gt;= right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">    merge_sort(arr, left, mid, temp);<span class=\"comment\">//别忘了左闭右开区间</span></span><br><span class=\"line\">    merge_sort(arr, mid, right, temp);</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> left, second = mid, i = left;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (first &lt; mid || second &lt; right) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (second &gt;= right || (arr[first] &lt;= arr[second] &amp;&amp; first &lt; mid)) &#123;</span><br><span class=\"line\">            temp[i++] = arr[first++];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            temp[i++] = arr[second++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = left; i &lt; right; i++) &#123;</span><br><span class=\"line\">        arr[i] = temp[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面画图理解递归是怎么操作的。<br><img src=\"/images/leetcode-java/4-4.jpg\" alt=\"归并排序\"></p>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">bubble_sort</span><span class=\"params\">(<span class=\"type\">int</span>[] arr,<span class=\"type\">int</span> right)</span> &#123;<span class=\"comment\">//每一轮把最大的一个数沉下去，下一轮就可以不用比较前一轮最后一个数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; right; i++) &#123;<span class=\"comment\">//这个是从1开始</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; right - i + <span class=\"number\">1</span>; j++) &#123;<span class=\"comment\">//不用再比较前一轮的最后一个数，size-i+1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[j - <span class=\"number\">1</span>]) &#123;<span class=\"comment\">//因为和前一个比较，所以一开始的i起始位置是1</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[j];</span><br><span class=\"line\">                arr[j] = arr[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"215-数组中的第K个最大元素-medium\"><a href=\"#215-数组中的第K个最大元素-medium\" class=\"headerlink\" title=\"215 数组中的第K个最大元素 medium\"></a>215 数组中的第K个最大元素 medium</h2><p>这个题结合1738来看。思路：寻找第K个大的元素，可以用快速排序法，快速排序就是每次选择一个枢轴元素，然后比他小的在左边，比他大的在右边，最终可以确定枢轴元素的最终位置。对比这个位置和第K大的位置，如果比这个位置小，就在左边递归，反之右边递归。需要注意一个点，就是选择枢轴元素要随机选，不然会遇到极端案例，导致时间复杂度高。当然本题实际执行只考虑了比枢轴元素大的数以及把大的元素放在左边，是为了符合题目第k大的元素，注意本题解法也是一开始把枢轴元素放在最右边。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Math.random()*(n-m)+m，生成大于等于m小于n的随机数</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findKthLargest</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> quickSelect(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>, nums.length - <span class=\"number\">1</span>);<span class=\"comment\">//第k大的位置也就是数组中k-1的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">quickSelect</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> kth, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">curPartition</span> <span class=\"operator\">=</span> partition(arr, left, right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curPartition == kth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr[curPartition];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (curPartition &lt; kth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> quickSelect(arr, curPartition + <span class=\"number\">1</span>, kth, right);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> quickSelect(arr, left, kth, curPartition - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pivotIndex</span> <span class=\"operator\">=</span> left + (<span class=\"type\">int</span>)(Math.random() * (right - left + <span class=\"number\">1</span>));<span class=\"comment\">//生成大于等于left小于等于right的随机数</span></span><br><span class=\"line\">        swap(arr, pivotIndex, right);<span class=\"comment\">//先把随机抽中的数与最右边的数交换。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> left - <span class=\"number\">1</span>;<span class=\"comment\">//把index初始化，一开始应该是-1。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> left; i &lt; right; i++) &#123;<span class=\"comment\">//在区间范围内寻找</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[i] &gt;= arr[right]) &#123;<span class=\"comment\">//因为这个题说找最大的第k个数，所以只需要关注比这个枢轴元素大的数</span></span><br><span class=\"line\">                index += <span class=\"number\">1</span>;<span class=\"comment\">//因为index一开始是-1</span></span><br><span class=\"line\">                swap(arr, index, i);<span class=\"comment\">//出现大于枢轴元素的数，就从左到右开始放。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        index += <span class=\"number\">1</span>;<span class=\"comment\">//index加1，是为了下一步操作，把枢轴元素放到正确的位置</span></span><br><span class=\"line\">        swap(arr, index, right);<span class=\"comment\">//结束这个步骤，枢轴元素左边都是大于它的数，右边都是小于它的数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> index;<span class=\"comment\">//返回随机抽中枢轴元素的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[l];</span><br><span class=\"line\">        arr[l] = arr[r];</span><br><span class=\"line\">        arr[r] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*写法2，自我感觉这种写法更好看</span></span><br><span class=\"line\"><span class=\"comment\">    private int partition(int[] arr, int left, int right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        int pivotIndex = left + (int)(Math.random() * (right - left + 1));</span></span><br><span class=\"line\"><span class=\"comment\">        swap(arr, pivotIndex, right);</span></span><br><span class=\"line\"><span class=\"comment\">        int index = left;//这里改变了</span></span><br><span class=\"line\"><span class=\"comment\">        for (int i = left; i &lt; right; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if (arr[i] &gt;= arr[right]) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                swap(arr, index, i);</span></span><br><span class=\"line\"><span class=\"comment\">                index += 1;//这里改变了</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        //这里删除了</span></span><br><span class=\"line\"><span class=\"comment\">        swap(arr, index, right);</span></span><br><span class=\"line\"><span class=\"comment\">        return index;</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个版本就是我们平时理解的快速排序。但是这个版本每次跑起来的速度和占用内存都不如上面那个好。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findKthLargest</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> quickSelect(nums, <span class=\"number\">0</span>, k - <span class=\"number\">1</span>, nums.length - <span class=\"number\">1</span>);<span class=\"comment\">//第k大的位置也就是数组中k-1的位置</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">quickSelect</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> kth, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">curPartition</span> <span class=\"operator\">=</span> partition(arr, left, right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curPartition == kth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr[curPartition];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (curPartition &lt; kth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> quickSelect(arr, curPartition + <span class=\"number\">1</span>, kth, right);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> quickSelect(arr, left, kth, curPartition - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">partition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pivotIndex</span> <span class=\"operator\">=</span> left + (<span class=\"type\">int</span>)(Math.random() * (right - left + <span class=\"number\">1</span>));<span class=\"comment\">//生成大于等于left小于等于right的随机数</span></span><br><span class=\"line\">        swap(nums, pivotIndex, left);<span class=\"comment\">//先把随机抽中的数与最右边的数交换。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> left, last = right, key = nums[first];<span class=\"comment\">//注意这里是last = right ，而不是right-1，因为上面已经处理好边界是lenght-1</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first &lt; last) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (first &lt; last &amp;&amp; nums[last] &lt;= key) &#123;<span class=\"comment\">//这里是从右边扫描，小于的不管</span></span><br><span class=\"line\">                --last;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[first] = nums[last];<span class=\"comment\">//大于的就把这个数放到前面，这样可以符合题目第K大的条件</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (first &lt; last &amp;&amp; nums[first] &gt;= key) &#123;</span><br><span class=\"line\">                ++first;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            nums[last] = nums[first];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nums[first] = key;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> first;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] arr, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[l];</span><br><span class=\"line\">        arr[l] = arr[r];</span><br><span class=\"line\">        arr[r] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"347-前K个高频元素-桶排序-medium\"><a href=\"#347-前K个高频元素-桶排序-medium\" class=\"headerlink\" title=\"347 前K个高频元素(桶排序) medium\"></a>347 前K个高频元素(桶排序) medium</h2><p>首先用hash来创建一个key，value(频率)对应。然后再创建一个list，把相同频率的放在一个位置。最后从后往前面取出前k个来。也就是桶的思想。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">知识点</span></span><br><span class=\"line\"><span class=\"comment\">1.LinkedHashMap继承于HashMap,是基于HashMap和双向链表实现的</span></span><br><span class=\"line\"><span class=\"comment\">2.HashMap无序，LinkedHashMap有序，分为插入顺序和访问顺序</span></span><br><span class=\"line\"><span class=\"comment\">3.访问顺序操作的时候，put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(也就是先删除再插入)</span></span><br><span class=\"line\"><span class=\"comment\">4.LinkedHashMap存取数据，还是跟HashMap一样使用Entry的方式，双向链表只是为了保证顺序</span></span><br><span class=\"line\"><span class=\"comment\">5.LinkenHashMap线程是不安全的</span></span><br><span class=\"line\"><span class=\"comment\">部分操作：</span></span><br><span class=\"line\"><span class=\"comment\">LinkedHashMap&lt;Integer,Integer&gt; map = new LinkedHashMap&lt;&gt;();//创建map</span></span><br><span class=\"line\"><span class=\"comment\">map.put(key,value)//存入key和value</span></span><br><span class=\"line\"><span class=\"comment\">map.get(key)//取出value</span></span><br><span class=\"line\"><span class=\"comment\">map.keySet()//打印的话是输出key的顺序</span></span><br><span class=\"line\"><span class=\"comment\">map.getOrDefault(Object key, V defaultValue)方法的作用是：当Map集合中有这个key时，就使用这个key值；如果没有就使用默认值defaultValue。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">1.数组也就是Array（[]）：最高效；但是其容量固定且无法动态改变；使用时候 new和不new没有区别</span></span><br><span class=\"line\"><span class=\"comment\">2.ArrayList：容量可动态增长；但牺牲效率；详细见https://www.runoob.com/java/java-arraylist.html</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] topKFrequent(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        LinkedHashMap&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();<span class=\"comment\">//以key,value来保存，本题key就是数字本身，value就是频率</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;<span class=\"comment\">//创建一个map来对应数字和频率</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(nums[i])) &#123;<span class=\"comment\">//如果map中的key存在value</span></span><br><span class=\"line\">                map.put(nums[i], map.get(nums[i]) + <span class=\"number\">1</span>);<span class=\"comment\">//注意不是map.get(nums[i] + 1)。从第二次开始就在基础频率上增加1</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(nums[i],<span class=\"number\">1</span>);<span class=\"comment\">//第一次大家都是空的，直接走这一步创建频率为1。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;Integer&gt;[] ans=<span class=\"keyword\">new</span> <span class=\"title class_\">List</span>[nums.length + <span class=\"number\">1</span>];<span class=\"comment\">//这个处理方式比较随意，会出现很多的null，至于多加1，举个例子把。[2,2]。这个2的频率是2。然后代码下面取的时候是ans[2(频率)]，但是我们知道下标如果是用length的话只有0,1。所以这个基础上加1。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num: map.keySet())&#123;<span class=\"comment\">//把map中的key依次按顺序处理</span></span><br><span class=\"line\">            <span class=\"type\">int</span> i=map.get(num);<span class=\"comment\">//取出这个Key对应的value(频率)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                ans[i]=<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//初始化，ans一开始本来就是空的嘛</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[i].add(num);<span class=\"comment\">//同频率的key添加到同一个位置的ans中</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];<span class=\"comment\">//设置一个数组，长度为k</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//计数器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ans.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; count &lt;k; i--) &#123;<span class=\"comment\">//注意这里是ans.length，而不是nums.length。从后往前面操作，因为题目说是频率的前k个</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans[i] != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//对ans中有数字的操作</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; ans[i].size(); j++) &#123;<span class=\"comment\">//然后取出这个位置中的ans</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (count &lt; k) &#123;</span><br><span class=\"line\">                        res[count++] = ans[i].get(j);<span class=\"comment\">//题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的.也就是如果题目要求k是2。但是频率最高的同时有3个数，这个是不成立的，也就不存在这个样例。所以每放进一个数，count就要增加1.</span></span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个解法稍微改了一点点，可以避免在生成bucket是时候浪费空间，能省一点是一点，但是实际测试的时候大家好像差不多，可能没有出现极端情况。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] topKFrequent(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        LinkedHashMap&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">frequency</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//频率计算</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class=\"line\">                map.put(nums[i], map.get(nums[i]) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                frequency = Math.max(map.get(nums[i]),frequency);<span class=\"comment\">//找到最高频率</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                map.put(nums[i],<span class=\"number\">1</span>);</span><br><span class=\"line\">                frequency = Math.max(map.get(nums[i]),frequency);<span class=\"comment\">//找到最高频率</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;Integer&gt;[] ans=<span class=\"keyword\">new</span> <span class=\"title class_\">List</span>[frequency + <span class=\"number\">1</span>];<span class=\"comment\">//长度只需要频率+1.这样可以避免上面的解法，省空间！！！</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num: map.keySet())&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i=map.get(num);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ans[i]==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                ans[i]=<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans[i].add(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> res[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//计数器</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ans.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; count &lt;k; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ans[i] != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//对ans中有数字的操作</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; ans[i].size(); j++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (count &lt; k) &#123;</span><br><span class=\"line\">                        res[count++] = ans[i].get(j);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"451-根据字符出现频率排序-桶排序-medium\"><a href=\"#451-根据字符出现频率排序-桶排序-medium\" class=\"headerlink\" title=\"451 根据字符出现频率排序(桶排序) medium\"></a>451 根据字符出现频率排序(桶排序) medium</h2><p>这个题主要和上一题对比的话，我觉得主要是一些语法上，比如对字符处理和上一题对数字的处理是不太一样的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">frequencySort</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Map&lt;Character,Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxfreq</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//找出最高的频率</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">frequency</span> <span class=\"operator\">=</span> map.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>;<span class=\"comment\">//有就在频率的基础上加1，没有就默认0。</span></span><br><span class=\"line\">            map.put(c, frequency);<span class=\"comment\">//放入hash中</span></span><br><span class=\"line\">            maxfreq = Math.max(maxfreq, frequency);<span class=\"comment\">//找到频率最大值</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        StringBuffer[] buckets = <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>[maxfreq + <span class=\"number\">1</span>];</span><br><span class=\"line\">         <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= maxfreq; i++) &#123;</span><br><span class=\"line\">            buckets[i] = <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//Map.entrySet() 这个方法返回的是一个Set&lt;Map.Entry&lt;K,V&gt;&gt;,Map.Entry里有相应的getKey和getValue方法</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<span class=\"comment\">//这个写法和上一题的不同之处。上一题都是整数，比较好处理。这个是字符，这样处理比较方便。</span></span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> entry.getKey();<span class=\"comment\">//注意是getkey</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">frequency</span> <span class=\"operator\">=</span> entry.getValue();<span class=\"comment\">//注意是getvalue</span></span><br><span class=\"line\">            buckets[frequency].append(c); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span><span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> maxfreq; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuffer</span> <span class=\"variable\">bucket</span> <span class=\"operator\">=</span> buckets[i];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; bucket.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; k &lt; i; k++) &#123;</span><br><span class=\"line\">                    sb.append(bucket.charAt(j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;             </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"75-颜色分类-medium\"><a href=\"#75-颜色分类-medium\" class=\"headerlink\" title=\"75 颜色分类 medium\"></a>75 颜色分类 medium</h2><p>直接插入排序，但是貌似速度和内存都不占优势？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sortColors</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &gt; <span class=\"number\">0</span> &amp;&amp; nums[j] &lt; nums[j-<span class=\"number\">1</span>]; j--) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> nums[j];</span><br><span class=\"line\">                nums[j] = nums[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                nums[j - <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"一切皆可搜索\"><a href=\"#一切皆可搜索\" class=\"headerlink\" title=\"一切皆可搜索\"></a>一切皆可搜索</h1><h2 id=\"695-岛屿的最大面积-DFS-medium\"><a href=\"#695-岛屿的最大面积-DFS-medium\" class=\"headerlink\" title=\"695 岛屿的最大面积(DFS) medium\"></a>695 岛屿的最大面积(DFS) medium</h2><p>思路是深度优先遍历，分为主函数和辅助函数，主函数就是遍历每个点的位置，辅助函数就是dfs，设置好不满足的条件，满足条件的继续搜索。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxAreaOfIsland</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//最大数量初始化为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;<span class=\"comment\">//表示一共有多少行（也就是每列的长度，可以理解为Y，注意就是YYYYY）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123; <span class=\"comment\">//表示一共有多少列（也就是每行的长度，可以理解为X，注意就是XXXXX）</span></span><br><span class=\"line\">                ans = Math.max(ans, dfs(grid, i, j));<span class=\"comment\">//比较目前的岛屿是否最大，若不是，就替换为最大岛屿</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid, <span class=\"type\">int</span> cur_i, <span class=\"type\">int</span> cur_j)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个非常重要，是深度优先搜索的不满足条件。有超过边界的(i和j小于0；i等于列长度，j等于行长度，注意数组的开始位置是0哦；还有当前是海洋，也就是不是陆地的地方就不搜索)</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt; <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        grid[cur_i][cur_j] = <span class=\"number\">0</span>;<span class=\"comment\">//当上面的条件都跳过了，也就是我们找到了一个陆地，这时候把他置为0，表示我们已经搜索过这个陆地了，然后开始上下左右搜索，不然应该会死循环。</span></span><br><span class=\"line\">        <span class=\"comment\">//这样可以组成 （0,1）（1,0）（-1,0）（0,-1）四种情况。</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_i = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_j = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;<span class=\"comment\">//陆地的数量初始为1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; <span class=\"number\">4</span>; index++) &#123;<span class=\"comment\">//遍历4次，走4个方向</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_inedx_i</span> <span class=\"operator\">=</span> cur_i + index_i[index];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_inedx_j</span> <span class=\"operator\">=</span> cur_j + index_j[index];</span><br><span class=\"line\">            ans += dfs(grid, next_inedx_i, next_inedx_j);<span class=\"comment\">//把连起来的陆地加起来 </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*对于二维数组解释下长度问题</span></span><br><span class=\"line\"><span class=\"comment\">grid.length = 8 (8个一维数组，表示有多少行，也可以表示为每列的长度)</span></span><br><span class=\"line\"><span class=\"comment\">grid[0].length = 13（1个数组中有13个数，表示有多少列，也可以表示为每行的长度）</span></span><br><span class=\"line\"><span class=\"comment\">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,1,1,0,1,0,0,0,0,0,0,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,1,0,0,1,1,0,0,1,0,1,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,1,0,0,1,1,0,0,1,1,1,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,0,0,0,0,0,0,0,0,0,1,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span></span><br><span class=\"line\"><span class=\"comment\">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"547-省份数量-DFS-medium\"><a href=\"#547-省份数量-DFS-medium\" class=\"headerlink\" title=\"547 省份数量(DFS) medium\"></a>547 省份数量(DFS) medium</h2><p>做这个题的时候陷入到上一题的思维了，做题还是太少了！本题中有多少个二维数组中有多少个一维数组就代表多少个城市，每个一维数组里面的位置代表本城市(也就是i和j相同)或者其他城市(i和j不一样)，位置上为1代表有连接，也就是大家最后是属于一个省份的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">思路：设置一个visit数组来表示访问过的城市。</span></span><br><span class=\"line\"><span class=\"comment\">访问第一个点，因为自己本身都是有1的，把visit[0]置为1(表示这个城市已经被访问过了)，这时候就开始深度优先搜索与这个城市相连的城市，然后依次类推，一直没有找到为止，这样就算完成了一个省份的搜索。开始执行下一个visit为0的城市访问。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findCircleNum</span><span class=\"params\">(<span class=\"type\">int</span>[][] isConnected)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">citys</span> <span class=\"operator\">=</span> isConnected.length;<span class=\"comment\">//表示一共有多少个</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[citys];<span class=\"comment\">//全部城市访问都置为0</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//省份数量初始为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; citys; i++) &#123;<span class=\"comment\">//开始搜索啦</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!visited[i]) &#123;<span class=\"comment\">//只针对没有被访问的城市进行搜索</span></span><br><span class=\"line\">                dfs(isConnected, visited, citys, i);</span><br><span class=\"line\">                sum++;<span class=\"comment\">//上面全部搜索完，就相当于找到一个省份</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[][] isConnected,<span class=\"type\">boolean</span>[] visited, <span class=\"type\">int</span> citys, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; citys; j++) &#123;<span class=\"comment\">//i是固定的，然后逐个位置搜索看是否有1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!visited[j] &amp;&amp; isConnected[i][j] == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//满足条件是位置上为1，已经这个城市没有被搜索过</span></span><br><span class=\"line\">                visited[j] = <span class=\"literal\">true</span>;<span class=\"comment\">//满足了上面条件，记得把这个城市置为1，表示已经搜索过了</span></span><br><span class=\"line\">                dfs(isConnected, visited, citys, j);<span class=\"comment\">//开始搜索与i相连的城市，注意这里最后是jjjj。</span></span><br><span class=\"line\">                <span class=\"comment\">//所以，只要说一个城市被搜索过了，这个城市所有的连接情况我们都找到了，也就是他们是属于一个省份的。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"417-太平洋大西洋水流问题-DFS-medium\"><a href=\"#417-太平洋大西洋水流问题-DFS-medium\" class=\"headerlink\" title=\"!417 太平洋大西洋水流问题(DFS) medium\"></a>!417 太平洋大西洋水流问题(DFS) medium</h2><p>一开始看了半天例子，以为那几点是形成河流的样子。ok，现在说下题目意思，是找出所有的点，这个点可以流向太平洋，也能流向大西洋 ，所以看例子的时候，单独看每一个点，然后需要自己画出流动方向。<br>!代表我在<a href=\"https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfsxi-wang-ke-yi-yong-zu-65si/\">Leetcode</a>上写题解了，哈哈。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pacificAtlantic</span><span class=\"params\">(<span class=\"type\">int</span>[][] heights)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> heights.length;<span class=\"comment\">//二维数组的行数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> heights[<span class=\"number\">0</span>].length;<span class=\"comment\">//二维数据的列数</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] can_reach_p = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][m];<span class=\"comment\">//初始化可以到达太平洋的数组</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] can_reach_a = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n][m];<span class=\"comment\">//初试化可以到达大西洋的数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dfs(heights, i, <span class=\"number\">0</span>, can_reach_p);<span class=\"comment\">//搜索左列，也就是靠近太平洋</span></span><br><span class=\"line\">            dfs(heights, i, m - <span class=\"number\">1</span>, can_reach_a);<span class=\"comment\">//搜索右列，也就是靠近大西洋</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">            dfs(heights, <span class=\"number\">0</span>, j, can_reach_p);<span class=\"comment\">//搜索上列，也就是靠近太平洋</span></span><br><span class=\"line\">            dfs(heights, n - <span class=\"number\">1</span>, j, can_reach_a);<span class=\"comment\">//搜索下列，也就是靠近大西洋</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//初始化一个list来保存符合条件的坐标</span></span><br><span class=\"line\">        <span class=\"comment\">//全部坐标进行判断</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (can_reach_a[i][j] &amp;&amp; can_reach_p[i][j]) &#123;<span class=\"comment\">//判断这个坐标是否同时流向太平洋和大西洋</span></span><br><span class=\"line\">                    res.add(List.of(i, j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[][] heights, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">boolean</span>[][] can_reach)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (can_reach[i][j] == <span class=\"literal\">true</span>) &#123;<span class=\"comment\">//如果这个坐标是1，就说明人家早就满足条件了，不需要再进行深度搜索了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        can_reach[i][j] = <span class=\"literal\">true</span>;<span class=\"comment\">//首先把这个坐标给置为1，代表可以达到海洋</span></span><br><span class=\"line\">        <span class=\"comment\">//因为坐标只能进行上下左右移动，也就是(0,1),(0,-1),(1,0),(-1,0)。所以设置成下面这种格式</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_i = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_j = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; <span class=\"number\">4</span>; index++) &#123;<span class=\"comment\">//上下左右4次坐标都要判断</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_index_i</span> <span class=\"operator\">=</span> i + index_i[index];<span class=\"comment\">//设置下一个坐标的i</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_index_j</span> <span class=\"operator\">=</span> j + index_j[index];<span class=\"comment\">//设置下一个坐标的j</span></span><br><span class=\"line\">            <span class=\"comment\">//需要满足下面的条件才能进行深度搜索，不能超过边界，还有下一个坐标要比原来坐标大或者相等。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next_index_i &gt;= <span class=\"number\">0</span> &amp;&amp; next_index_i &lt; heights.length &amp;&amp; next_index_j &gt;= <span class=\"number\">0</span> &amp;&amp; next_index_j &lt; heights[<span class=\"number\">0</span>].length &amp;&amp; heights[i][j] &lt;= heights[next_index_i][next_index_j]) &#123;</span><br><span class=\"line\">                            dfs(heights, next_index_i, next_index_j, can_reach);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"46-全排列-回溯法-medium\"><a href=\"#46-全排列-回溯法-medium\" class=\"headerlink\" title=\"46 全排列(回溯法) medium\"></a>46 全排列(回溯法) medium</h2><p>DFS基本操作：[修改当前节点状态]-&gt;[递归子节点状态]。回溯法：[修改当前节点状态]-&gt;[递归子节点状态]-&gt;[回改当前节点状态]。回溯法是优先搜索的一种特殊状态。一般在排列，组合，选择类问题使用回溯法，这次官方那个视频讲解不错，本题就是按照这个思路来。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">知识点</span><br><span class=\"line\">注意后面的<span class=\"keyword\">new</span>的写法</span><br><span class=\"line\">栈：Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">list里面还有一个list： List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//状态变量：depth，path，used</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] used = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[len];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(&quot;  res:&quot;+res);</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();<span class=\"comment\">//栈的应用</span></span><br><span class=\"line\">        dfs(nums, len, <span class=\"number\">0</span>, path, used, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[] nums,<span class=\"type\">int</span> len, <span class=\"type\">int</span> depth, Deque&lt;Integer&gt; path, <span class=\"type\">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (depth == len) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/*下面这一句超级超级重要，如果改成res.add(path)。最后输出是[[],[],[],[],[],[]]。</span></span><br><span class=\"line\"><span class=\"comment\">            为什么会这样呢？</span></span><br><span class=\"line\"><span class=\"comment\">            变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。</span></span><br><span class=\"line\"><span class=\"comment\">            在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。</span></span><br><span class=\"line\"><span class=\"comment\">            */</span></span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used[i] == <span class=\"literal\">true</span>) &#123; <span class=\"comment\">//如果发现某个位置已经用了，就跳过</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.addLast(nums[i]);<span class=\"comment\">//栈的添加操作</span></span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;<span class=\"comment\">//然后把这个位置设置为已经用了</span></span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(&quot;  递归之前 =&gt; &quot; + path+ &quot;  i: &quot; + i + &quot;  used：  &quot; + Arrays.toString(used));</span></span><br><span class=\"line\">            dfs(nums, len, depth + <span class=\"number\">1</span>, path, used, res);<span class=\"comment\">//进行递归操作</span></span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;<span class=\"comment\">//回改节点状态</span></span><br><span class=\"line\">            path.removeLast();<span class=\"comment\">//回改节点状态，也就是栈的移除操作。</span></span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(&quot;递归之后 =&gt; &quot; + path+ &quot;  i: &quot; + i+ &quot;  used：  &quot; + Arrays.toString(used));</span></span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面引用一张<a href=\"https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/\">别人图片</a>来描述这个算法流程。<br><img src=\"/images/leetcode-java/5-4-1.png\" alt=\"46题全排列1\"><br>然后下面这种图片是一些代码流程细节上的理解，注意当代码运行到dfs里面的时候，会回到for，然后for是重新为0的。<br><img src=\"/images/leetcode-java/5-4-2.png\" alt=\"46题全排列2\"></p>\n<h2 id=\"77-组合-回溯法-medium\"><a href=\"#77-组合-回溯法-medium\" class=\"headerlink\" title=\"77 组合(回溯法) medium\"></a>77 组合(回溯法) medium</h2><p>注意排列是不重复的，组合是的话[1,2]和[2,1]是一个情况，还有不能对自己组合哦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//这个写法受到了上一个的影响，不够简洁，实际上完全没有必要用到used，注意有个地方不一样！！！！在唯一一个注释里面！！！</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] used =<span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n];</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">0</span> || n &lt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            nums[i] = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(nums, n, k, <span class=\"number\">0</span>, path, used, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> begin, Deque&lt;Integer&gt; path, <span class=\"type\">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> begin; i &lt; n; i++ ) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used[i] == <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            used[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            path.addLast(nums[i]);</span><br><span class=\"line\">            dfs(nums, n, k, i + <span class=\"number\">1</span>, path, used, res);<span class=\"comment\">//这里不是begin + 1而是i + 1，不然会有重复的组合，因为我们这个题是组合，组合，组合，不是排列！！！！ 比较一下上一题是depth的含义。</span></span><br><span class=\"line\">            used[i] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//大佬的简洁解法，还有一个解法会更加省时间，但是不好想，也就是剪枝。具体还是看下面的链接。</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayDeque;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Deque;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k &lt;= <span class=\"number\">0</span> || n &lt; k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 从 1 开始是题目的设定</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        dfs(n, k, <span class=\"number\">1</span>, path, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 递归终止条件是：path 的长度等于 k</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 遍历可能的搜索起点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> begin; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 向路径变量里添加一个数</span></span><br><span class=\"line\">            path.addLast(i);</span><br><span class=\"line\">            <span class=\"comment\">// 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素</span></span><br><span class=\"line\">            dfs(n, k, i + <span class=\"number\">1</span>, path, res);</span><br><span class=\"line\">            <span class=\"comment\">// 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span></span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：liweiwei1419</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<p>用下大佬的图理解这个题<br><img src=\"/images/leetcode-java/5-5.png\" alt=\"77组合\"><br>总结：77题和46题回溯法，一定要先画图！！！看看他们不一样的点，dfs判断加入path的条件，以及在for循环中dfs的写法，这些都是值得注意的。</p>\n<h2 id=\"79-单词搜索-回溯法-medium\"><a href=\"#79-单词搜索-回溯法-medium\" class=\"headerlink\" title=\"79 单词搜索(回溯法) medium\"></a>79 单词搜索(回溯法) medium</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exist</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> backtracking(i, j, board, word, visited, <span class=\"number\">0</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">char</span>[][] board, String word, <span class=\"type\">boolean</span>[][] visited, <span class=\"type\">int</span> pos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i][j] != word.charAt(pos) || visited[i][j] ==<span class=\"literal\">true</span>) &#123;<span class=\"comment\">//这两个if判断不能对调,因为首先你得判断配对是不是一样的字符，然后才判断他是不是最后一个字符的位置</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pos == word.length() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_i = &#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, -<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] index_j = &#123;<span class=\"number\">1</span>, -<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; <span class=\"number\">4</span>; index++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_index_i</span> <span class=\"operator\">=</span> i + index_i[index];<span class=\"comment\">//设置下一个坐标的i</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_index_j</span> <span class=\"operator\">=</span> j + index_j[index];<span class=\"comment\">//设置下一个坐标的j</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next_index_i &gt;= <span class=\"number\">0</span> &amp;&amp; next_index_i &lt; board.length &amp;&amp; next_index_j &gt;= <span class=\"number\">0</span> &amp;&amp;  next_index_j &lt; board[<span class=\"number\">0</span>].length) &#123;</span><br><span class=\"line\">                <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> backtracking(next_index_i, next_index_j, board, word, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag) &#123;</span><br><span class=\"line\">                    result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*还可以改成这样，不太喜欢这种写法。</span></span><br><span class=\"line\"><span class=\"comment\">    public boolean backtracking(int i, int j, char[][] board, String word, boolean[][] visited, int pos) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">        //这里改了。</span></span><br><span class=\"line\"><span class=\"comment\">        if (board[i][j] != word.charAt(pos)) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return false;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; else if (pos == word.length() - 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return true;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125; </span></span><br><span class=\"line\"><span class=\"comment\">        visited[i][j] = true;</span></span><br><span class=\"line\"><span class=\"comment\">        int[] index_i = &#123;0, 0, 1, -1&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">        int[] index_j = &#123;1, -1, 0, 0&#125;;</span></span><br><span class=\"line\"><span class=\"comment\">        boolean result = false;</span></span><br><span class=\"line\"><span class=\"comment\">        for (int index = 0; index &lt; 4; index++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            int next_index_i = i + index_i[index];//设置下一个坐标的i</span></span><br><span class=\"line\"><span class=\"comment\">            int next_index_j = j + index_j[index];//设置下一个坐标的j</span></span><br><span class=\"line\"><span class=\"comment\">            if (next_index_i &gt;= 0 &amp;&amp; next_index_i &lt; board.length &amp;&amp; next_index_j &gt;= 0 &amp;&amp;  next_index_j &lt; board[0].length) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                if (visited[next_index_i][next_index_j] == false) &#123;//这里改了，注意这里是next的判断</span></span><br><span class=\"line\"><span class=\"comment\">                    boolean flag = backtracking(next_index_i, next_index_j, board, word, visited, pos + 1);</span></span><br><span class=\"line\"><span class=\"comment\">                    if (flag) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                        result = true;</span></span><br><span class=\"line\"><span class=\"comment\">                        break;</span></span><br><span class=\"line\"><span class=\"comment\">                    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">                &#125;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        visited[i][j] = false;</span></span><br><span class=\"line\"><span class=\"comment\">        return result;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>下面这个是按照书上思路改写的，但是错误，先放着，未来会修改(已修改，看下面)，初步判断是因为find不是全局变量。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">//！！！！这是错误的，错误的！！！正确写法在下一个代码中</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exist</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[m][n];</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">find</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                backtracking(i, j, board, word, find, visited, <span class=\"number\">0</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> find;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">char</span>[][] board, String word, <span class=\"type\">boolean</span> find, <span class=\"type\">boolean</span>[][] visited, <span class=\"type\">int</span> pos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &lt; <span class=\"number\">0</span> ||  j &gt;= board[<span class=\"number\">0</span>].length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (board[i][j] != word.charAt(pos) || visited[i][j] || find) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pos == word.length() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            find = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        backtracking(i + <span class=\"number\">1</span>, j, board, word, find, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backtracking(i - <span class=\"number\">1</span>, j, board, word, find, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backtracking(i, j + <span class=\"number\">1</span>, board, word, find, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backtracking(i, j - <span class=\"number\">1</span>, board, word, find, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//正确写法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> <span class=\"variable\">find</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;<span class=\"comment\">//设为全局变量</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">exist</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, String word)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(board == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] visited = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[board.length][board[<span class=\"number\">0</span>].length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; board.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; board[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                backTracking(i, j, board, word, visited, <span class=\"number\">0</span>);<span class=\"comment\">//不用传find</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> find;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backTracking</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j, <span class=\"type\">char</span>[][] board, String word, <span class=\"type\">boolean</span>[][] visited, <span class=\"type\">int</span> pos)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> || i &gt;= board.length || j &lt; <span class=\"number\">0</span> || j &gt;= board[<span class=\"number\">0</span>].length || visited[i][j] || board[i][j] != word.charAt(pos) || find) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pos == word.length() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            find = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        backTracking(i - <span class=\"number\">1</span>, j, board, word, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backTracking(i + <span class=\"number\">1</span>, j, board, word, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backTracking(i, j - <span class=\"number\">1</span>, board, word, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        backTracking(i, j + <span class=\"number\">1</span>, board, word, visited, pos + <span class=\"number\">1</span>);</span><br><span class=\"line\">        visited[i][j] = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"51-N皇后-回溯法-hard\"><a href=\"#51-N皇后-回溯法-hard\" class=\"headerlink\" title=\"51 N皇后(回溯法) hard\"></a>51 N皇后(回溯法) hard</h2><p>久闻的经典题！题目要求就是任何两个皇后都不能在同一行、同一列以及同一条斜线上。思考：斜线怎么判断？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是别人用java改写labuladong的C++版本，感觉非常好理解。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//这里是全局哦</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">solveNQueens</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span>[][] board = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[n][n];</span><br><span class=\"line\">        <span class=\"comment\">//初始化棋盘</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span>[] c : board) &#123;</span><br><span class=\"line\">            Arrays.fill(c, <span class=\"string\">&#x27;.&#x27;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        backtracking(board, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> row)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//每一行都成功放置好了皇后，注意这里不是board.length - 1，我的理解是，首先你row进来是检查能不能放，所以最后全部放好后，row会+1,，这时候才判断已经全部能放。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (row == board.length) &#123;</span><br><span class=\"line\">            res.add(charToList(board));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board[row].length;<span class=\"comment\">//其实有没有row都一样，都是N*N棋盘。</span></span><br><span class=\"line\">        <span class=\"comment\">//对列进行遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">col</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; col &lt; n; col++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!isValid(board, row, col)) &#123;<span class=\"comment\">//判断能不能放皇后，不能放就跳过</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            board[row][col] = <span class=\"string\">&#x27;Q&#x27;</span>;<span class=\"comment\">//能放就置为Q</span></span><br><span class=\"line\">            backtracking(board, row + <span class=\"number\">1</span>);<span class=\"comment\">//对下一行进行操作</span></span><br><span class=\"line\">            board[row][col] = <span class=\"string\">&#x27;.&#x27;</span>;<span class=\"comment\">//回溯法关键，也就是恢复原来标记</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(<span class=\"type\">char</span>[][] board, <span class=\"type\">int</span> row, <span class=\"type\">int</span> col)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> board.length;</span><br><span class=\"line\">        <span class=\"comment\">//判断列是否能放皇后</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][col] == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断右上方有没有皇后冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> row - <span class=\"number\">1</span>, j = col + <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<span class=\"comment\">//先跳到上一行，列也要加一行，依次类推，注意边界！</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//判断左上方有没有皇后冲突</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> row - <span class=\"number\">1</span>, j = col - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; j &gt;=<span class=\"number\">0</span>; i--, j--) &#123;<span class=\"comment\">//先跳到上一行，列也要减一行，依次类推，注意边界！</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (board[i][j] == <span class=\"string\">&#x27;Q&#x27;</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里为什么不进行左下方和右下方进行判断？因为是一行行进行放，这时候左下和右下必定没有呀</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List <span class=\"title function_\">charToList</span><span class=\"params\">(<span class=\"type\">char</span>[][] board)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span>[] c : board) &#123;</span><br><span class=\"line\">            list.add(String.copyValueOf(c));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">本题有很多需要学习的写法</span><br><span class=\"line\"><span class=\"number\">1.</span><span class=\"keyword\">for</span> (<span class=\"type\">char</span>[] c : board) &#123;</span><br><span class=\"line\">    System.out.print(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">本句输出是<span class=\"number\">1111</span>，也就是说，对于Arrays.fill(c, <span class=\"string\">&#x27;.&#x27;</span>)每次操作，都是[., ., ., .]，一次性把每行的<span class=\"number\">4</span>个位置都填充上，然后一共操作<span class=\"number\">4</span>次而不是<span class=\"number\">16</span>次。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>Arrays.fill(c, <span class=\"string\">&#x27;.&#x27;</span>);<span class=\"comment\">//初始化棋盘这里</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">    System.out.print(Arrays.toString(board[i]));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果是：</span><br><span class=\"line\">[., ., ., .][., ., ., .][., ., ., .][., ., ., .]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span><span class=\"keyword\">for</span> (<span class=\"type\">char</span>[] c : board) &#123;</span><br><span class=\"line\">            list.add(String.copyValueOf(c));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">首先为什么要这么操作，因为输入是一个二维数组来的，最后的输出要符合题目输出，把每一个一维数组加到list中！</span><br><span class=\"line\">这一段的操作是这样看，首先是输入一个已经摆放好皇后的棋盘</span><br><span class=\"line\">String.copyValueOf是返回字符串</span><br><span class=\"line\">然后<span class=\"type\">char</span> c是提取每一行出来，比如第一行.Q..然后add到list中，最后扫描完所有行list是这样[.Q.., ...Q, Q..., ..Q.]，然后再res.add进去。</span><br></pre></td></tr></table></figure>\n<h2 id=\"934-最短的桥-DFS-BFS-medium\"><a href=\"#934-最短的桥-DFS-BFS-medium\" class=\"headerlink\" title=\"934 最短的桥(DFS+BFS) medium\"></a>934 最短的桥(DFS+BFS) medium</h2><p>一般广度优先遍历用于求最短路径或者可达性问题。本题实际上就是求两个岛屿之间的最短距离，先任意找到一个岛，然后用广度优先搜索寻找和另外一个岛屿的最短距离。结合了书和<a href=\"https://leetcode-cn.com/problems/shortest-bridge/solution/java-bfsyu-dfsshi-yong-by-ppppjqute-jvwv/\">该作者</a>的想法。做完这个题其实还是有点不理解，因为首先是找到了第一个岛后就break掉了，那怎么知道其他岛与其他岛会不会有更小的距离呢？经过我的探索，终于知道了，因为题目样例中有且仅有两个岛！！！！！！不会出现第三个岛！！！！务必知道挨着的1是属于一个岛！！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">有个地方需要注意，两个陆地挨着的属于一个岛。比如[[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]]这种情况是一个岛，当然了，这个用例是不能被输入的，因为必须要有两个岛。还有这个题返回的是必须翻转<span class=\"number\">0</span>的数目。</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">shortestBridge</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] direction = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[][]&#123;&#123;<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;-<span class=\"number\">1</span>, <span class=\"number\">0</span>&#125;, &#123;<span class=\"number\">0</span>, <span class=\"number\">1</span>&#125;, &#123;<span class=\"number\">0</span>, -<span class=\"number\">1</span>&#125;&#125;;<span class=\"comment\">//四个方向坐标</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> grid.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;<span class=\"comment\">//初始化距离，这里为什么要设置-1而不是0，因为一进入下面的while后首先是搜索以自己为目标的四周，所以第一次进入while，先ans++，这样就初始化了为0，然后再从我自己扩散出去，而且循环里面是找到了下一个陆地直接返回ans，没有进行加加，一开始提前了ans++。</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        Deque&lt;<span class=\"type\">int</span> []&gt; point = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();<span class=\"comment\">//队列记录坐标</span></span><br><span class=\"line\">        <span class=\"comment\">//dfs寻找第一个岛，并把这个岛全部标记为2，注意想象一下周围一圈都是1，表达是一个岛，会把这一圈的1都标记为2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (flag == <span class=\"literal\">true</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; m ; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    dfs(grid, point, i, j); </span><br><span class=\"line\">                    flag = <span class=\"literal\">true</span>;<span class=\"comment\">//代表找到了岛</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//进行广度搜索，看多少层能到下一个陆地</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!point.isEmpty()) &#123;<span class=\"comment\">//point不为空</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> point.size();</span><br><span class=\"line\">            ans++;<span class=\"comment\">//每扩散一次，距离加1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;<span class=\"comment\">//依次对标记过为2的岛进行操作</span></span><br><span class=\"line\">                <span class=\"comment\">//System.out.print(&quot;hello  &quot;+ ans+&quot;   &quot;+&quot;  &quot;);</span></span><br><span class=\"line\">                <span class=\"type\">int</span>[] node = point.poll();<span class=\"comment\">//取出队列中第一个岛的坐标，并删除队列中该坐标</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">4</span>; j++) &#123;<span class=\"comment\">//上下左右寻找</span></span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">next_x</span> <span class=\"operator\">=</span> node[<span class=\"number\">0</span>] + direction[j][<span class=\"number\">0</span>];</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">next_y</span> <span class=\"operator\">=</span> node[<span class=\"number\">1</span>] + direction[j][<span class=\"number\">1</span>];</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(next_x &lt; <span class=\"number\">0</span> || next_x &gt;= grid.length || next_y &lt; <span class=\"number\">0</span> || next_y &gt;= grid[<span class=\"number\">0</span>].length || grid[next_x][next_y] == <span class=\"number\">2</span>) &#123;<span class=\"comment\">//判断：不能超边界以及不能是访问过的陆地</span></span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (grid[next_x][next_y] == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//找到下一个岛</span></span><br><span class=\"line\">                        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    grid[next_x][next_y] = <span class=\"number\">2</span>;<span class=\"comment\">//走过的地方要标记为2(这些地方可能是水哦)</span></span><br><span class=\"line\">                    point.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;next_x, next_y&#125;);<span class=\"comment\">//把这些坐标都记录起来</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid, Deque&lt;<span class=\"type\">int</span> []&gt; point, <span class=\"type\">int</span> i, <span class=\"type\">int</span> j)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">0</span> || i &gt;= grid.length || j &lt; <span class=\"number\">0</span> || j &gt;= grid[<span class=\"number\">0</span>].length || grid[i][j] == <span class=\"number\">2</span> || grid[i][j] != <span class=\"number\">1</span>) &#123;<span class=\"comment\">//边界判断以及走过的地方不搜索还有不是陆地的不搜索</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        grid[i][j] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        point.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;i, j&#125;);</span><br><span class=\"line\">        dfs(grid, point, i - <span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, point, i + <span class=\"number\">1</span>, j);</span><br><span class=\"line\">        dfs(grid, point, i, j - <span class=\"number\">1</span>);</span><br><span class=\"line\">        dfs(grid, point, i, j + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;举个例子：</span><br><span class=\"line\">现在两个岛是这样的，就是一个L型和中间一块小岛</span><br><span class=\"line\">[[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">下面最左边的<span class=\"number\">9</span>和<span class=\"number\">7</span>代表队列中的元素个数，hello具体位置在上面代码看，表达进入<span class=\"keyword\">for</span>循环，hello右边是ans的大小，最右边是取出来的坐标。可以看到，先把L型岛坐标全部放进队列，然后一个个坐标取出来再再看四周(并且也把四周的点加入到队列)，第一轮发现是没有碰到陆地的，所以到了第二轮，第二轮是<span class=\"number\">7</span>因为L型右边的坐标围起来是<span class=\"number\">7</span>个，然后开始继续找，到了<span class=\"number\">2</span>,<span class=\"number\">1</span>坐标，可以知道右边一个位置是<span class=\"number\">1</span>，这时候已经找到了，返回ans。</span><br><span class=\"line\"><span class=\"number\">9</span>  hello  <span class=\"number\">0</span>     <span class=\"number\">0</span> <span class=\"number\">0</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">1</span> <span class=\"number\">0</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">2</span> <span class=\"number\">0</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">3</span> <span class=\"number\">0</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">4</span> <span class=\"number\">0</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">4</span> <span class=\"number\">1</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">4</span> <span class=\"number\">2</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">4</span> <span class=\"number\">3</span></span><br><span class=\"line\">hello  <span class=\"number\">0</span>     <span class=\"number\">4</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">7</span>  hello  <span class=\"number\">1</span>     <span class=\"number\">0</span> <span class=\"number\">1</span></span><br><span class=\"line\">hello  <span class=\"number\">1</span>     <span class=\"number\">1</span> <span class=\"number\">1</span></span><br><span class=\"line\">hello  <span class=\"number\">1</span>     <span class=\"number\">2</span> <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"126-单词接龙2-回溯-BFS-hard\"><a href=\"#126-单词接龙2-回溯-BFS-hard\" class=\"headerlink\" title=\"126 单词接龙2(回溯+BFS) hard\"></a>126 单词接龙2(回溯+BFS) hard</h2><p>单词只差一个字母的可以连接成节点，思考如何去判断只相差一个字母？回溯也就是深度优先搜索的一个应用，用于找出所有情况，BFS也就是找到最短路径，合起来就是找出所有的最短路径。这个题和上一个题差不多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//官方的解答，学到就是我的🤓</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">findLadders</span><span class=\"params\">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;String&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;String&gt; dict = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;(wordList);<span class=\"comment\">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!dict.contains(endWord)) &#123;<span class=\"comment\">// 特殊用例判断</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dict.remove(beginWord);<span class=\"comment\">//把beginword在字典里删除掉</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 第 1 步：广度优先遍历建图</span></span><br><span class=\"line\">        <span class=\"comment\">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span></span><br><span class=\"line\">        Map&lt;String, Integer&gt; steps = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        steps.put(beginWord, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span></span><br><span class=\"line\">        Map&lt;String, List&lt;String&gt;&gt; from = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">found</span> <span class=\"operator\">=</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">wordlen</span> <span class=\"operator\">=</span> beginWord.length();<span class=\"comment\">//记录单词的长度，以便于对每个字符进行更换</span></span><br><span class=\"line\">        Queue&lt;String&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        queue.offer(beginWord);<span class=\"comment\">//把开始的单词加进去</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty()) &#123;<span class=\"comment\">//不为空就运行</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; i++) &#123;<span class=\"comment\">//对queue里面的单词依次操作</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">currword</span> <span class=\"operator\">=</span> queue.poll();<span class=\"comment\">//先取出queue第一个单词</span></span><br><span class=\"line\">                <span class=\"type\">char</span>[] chararray = currword.toCharArray();<span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; wordlen; j++) &#123;<span class=\"comment\">//对每一个位置的字符进行操作</span></span><br><span class=\"line\">                    <span class=\"type\">char</span> <span class=\"variable\">origin</span> <span class=\"operator\">=</span> chararray[j];<span class=\"comment\">//先保存原来的字符，以便后面进行恢复</span></span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> <span class=\"string\">&#x27;a&#x27;</span>; c &lt;= <span class=\"string\">&#x27;z&#x27;</span>; c++) &#123;<span class=\"comment\">//每个位置都可以替换26次（包括原来的自己啦）</span></span><br><span class=\"line\">                        chararray[j] = c;<span class=\"comment\">//替换成果</span></span><br><span class=\"line\">                        <span class=\"type\">String</span> <span class=\"variable\">nextword</span> <span class=\"operator\">=</span> String.valueOf(chararray);<span class=\"comment\">//char数组转成字符串</span></span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (steps.containsKey(nextword) &amp;&amp; step == steps.get(nextword)) &#123;<span class=\"comment\">//初步理解就是，如果大家都在同一个level的词变换，就进行操作添加这个词</span></span><br><span class=\"line\">                            <span class=\"comment\">//System.out.print(&quot;nextword is &quot;+nextword);</span></span><br><span class=\"line\">                            <span class=\"comment\">//System.out.print(&quot;currword is &quot;+currword);</span></span><br><span class=\"line\">                            from.get(nextword).add(currword);<span class=\"comment\">//如果有这个key的记录, 添加新值</span></span><br><span class=\"line\">                            <span class=\"comment\">//System.out.println(&quot;from is a  &quot;+from);</span></span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (!dict.contains(nextword)) &#123;<span class=\"comment\">//dict中不存在这个单词就跳过</span></span><br><span class=\"line\">                            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                        <span class=\"comment\">//下面这两句思考一下！！！！！</span></span><br><span class=\"line\">                        dict.remove(nextword);<span class=\"comment\">//如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span></span><br><span class=\"line\">                        queue.add(nextword); <span class=\"comment\">// 那么这一层扩展出的单词进入队列</span></span><br><span class=\"line\">                        <span class=\"comment\">// 记录 nextword 从 currWord 而来</span></span><br><span class=\"line\">                        from.putIfAbsent(nextword, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());</span><br><span class=\"line\">                        from.get(nextword).add(currword);</span><br><span class=\"line\">                        <span class=\"comment\">// 记录 nextword 的 step</span></span><br><span class=\"line\">                        steps.put(nextword, step);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (nextword.equals(endWord)) &#123;<span class=\"comment\">//等于最后一个单词就把found设置为true</span></span><br><span class=\"line\">                            found = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        <span class=\"comment\">//System.out.println(&quot;dict is &quot;+dict);</span></span><br><span class=\"line\">                        <span class=\"comment\">//System.out.println(&quot;queue is &quot;+queue);</span></span><br><span class=\"line\">                        <span class=\"comment\">//System.out.println(&quot;from is &quot;+from);</span></span><br><span class=\"line\">                        <span class=\"comment\">//System.out.println(&quot;steps is &quot;+steps);</span></span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    chararray[j] = origin;<span class=\"comment\">//还原单词</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            step++;<span class=\"comment\">//level加1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (found) &#123;<span class=\"comment\">//找到就打断程序</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (found) &#123;</span><br><span class=\"line\">            Deque&lt;String&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">            path.add(endWord);</span><br><span class=\"line\">            backtracking(from, path ,beginWord ,endWord ,res);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注意这个回溯反着来找，从尾巴一直寻找到最开始，就是根据from记录的信息来寻找</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(Map&lt;String, List&lt;String&gt;&gt; from, Deque&lt;String&gt; path, String beginWord, String cur, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur.equals(beginWord)) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String preucrsor : from.get(cur)) &#123;</span><br><span class=\"line\">            path.addFirst(preucrsor);</span><br><span class=\"line\">            backtracking(from, path, beginWord, preucrsor, res);</span><br><span class=\"line\">            path.removeFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">老规矩，看不懂怎么运行就一步步打印出来</span></span><br><span class=\"line\"><span class=\"comment\">dict is [lot, log, dot, cog, dog]</span></span><br><span class=\"line\"><span class=\"comment\">queue is [hot]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;hot=[hit]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;hit=0, hot=1&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">dict is [lot, log, cog, dog]</span></span><br><span class=\"line\"><span class=\"comment\">queue is [dot]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;dot=[hot], hot=[hit]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;hit=0, dot=2, hot=1&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">dict is [log, cog, dog]</span></span><br><span class=\"line\"><span class=\"comment\">queue is [dot, lot]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;lot=[hot], dot=[hot], hot=[hit]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;lot=2, hit=0, dot=2, hot=1&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">dict is [log, cog]</span></span><br><span class=\"line\"><span class=\"comment\">queue is [lot, dog]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;lot=[hot], dot=[hot], hot=[hit], dog=[dot]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;lot=2, hit=0, dot=2, hot=1, dog=3&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">dict is [cog]</span></span><br><span class=\"line\"><span class=\"comment\">queue is [dog, log]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;lot=[hot], log=[lot], dot=[hot], hot=[hit], dog=[dot]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;lot=2, hit=0, log=3, dot=2, hot=1, dog=3&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">dict is []</span></span><br><span class=\"line\"><span class=\"comment\">queue is [log, cog]</span></span><br><span class=\"line\"><span class=\"comment\">from is &#123;lot=[hot], log=[lot], dot=[hot], cog=[dog], hot=[hit], dog=[dot]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">steps is &#123;lot=2, hit=0, log=3, dot=2, cog=4, hot=1, dog=3&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">//这个是第一个if语句中的输出，对于这个例子，一共才运行了一次，仔细观察cog这个值多了一个log</span></span><br><span class=\"line\"><span class=\"comment\">nextword is cog</span></span><br><span class=\"line\"><span class=\"comment\">curword is log</span></span><br><span class=\"line\"><span class=\"comment\">from is a  &#123;lot=[hot], log=[lot], dot=[hot], cog=[dog, log], hot=[hit], dog=[dot]&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">map和hashmap区别?</span><br><span class=\"line\">queue和Deque区别?</span><br><span class=\"line\">add offer等操作区别?</span><br><span class=\"line\">contains和containskey区别?</span><br><span class=\"line\">put和putIfAbsent区别：put在放入数据时，如果放入数据的key已经存在与Map中，最后放入的数据会覆盖之前存在的数据，而putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值。</span><br><span class=\"line\">测试的时候发现下面两种写法都是可以的，可以百度下他们的不同。</span><br><span class=\"line\">Deque&lt;String&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">Deque&lt;String&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h2 id=\"130-被围绕的区域-medium\"><a href=\"#130-被围绕的区域-medium\" class=\"headerlink\" title=\"130 被围绕的区域 medium\"></a>130 被围绕的区域 medium</h2><p>采用深度优先遍历递归，首先要理解就是只有被X包围的区域O才被替换，所以在边界的O是不能被替换的，延伸下去的话，和边界O相连的O也是不能够被替换的，所以这个题目的思想就是，从边界O下手，然后找到和这个边界O相连的O，然后把他们都替换成一个字符#，最后再做一次全局的遍历，把没被替换成O的换成X，把#恢复成O。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public void solve(char[][] board) &#123;</span><br><span class=\"line\">        if (board == null || board.length == 0) &#123;</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int n = board.length, m = board[0].length;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class=\"line\">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">                boolean isEdge = i == 0 || i == n - 1 || j == 0 || j == m - 1;</span><br><span class=\"line\">                if (isEdge &amp;&amp; board[i][j] == &#x27;O&#x27;) &#123; //只需要从边界下手，其他地方不需要</span><br><span class=\"line\">                    dfs(board, i ,j);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">         for (int i = 0; i &lt; n; i++) &#123;  //都遍历完了，再全局遍历进行更换字符</span><br><span class=\"line\">             for (int j = 0; j &lt; m; j++) &#123;</span><br><span class=\"line\">                 if  (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class=\"line\">                     board[i][j] = &#x27;X&#x27;;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">                 if (board[i][j] == &#x27;#&#x27;) &#123;</span><br><span class=\"line\">                     board[i][j] = &#x27;O&#x27;;</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void dfs(char [][]board, int i ,int j) &#123; //深度优先遍历</span><br><span class=\"line\">        if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == &#x27;X&#x27; || board[i][j] == &#x27;#&#x27;) &#123; //边界条件以及本来是X和#的不需要操作</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        board[i][j] = &#x27;#&#x27;;</span><br><span class=\"line\">        dfs(board, i + 1, j);</span><br><span class=\"line\">        dfs(board, i - 1, j);</span><br><span class=\"line\">        dfs(board, i , j + 1);</span><br><span class=\"line\">        dfs(board, i , j - 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"257-二叉树的所有路径-easy\"><a href=\"#257-二叉树的所有路径-easy\" class=\"headerlink\" title=\"257 二叉树的所有路径 easy\"></a>257 二叉树的所有路径 easy</h2><p>深度优先遍历</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for a binary tree node.</span><br><span class=\"line\"> * public class TreeNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     TreeNode left;</span><br><span class=\"line\"> *     TreeNode right;</span><br><span class=\"line\"> *     TreeNode() &#123;&#125;</span><br><span class=\"line\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class=\"line\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class=\"line\"> *         this.val = val;</span><br><span class=\"line\"> *         this.left = left;</span><br><span class=\"line\"> *         this.right = right;</span><br><span class=\"line\"> *     &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();</span><br><span class=\"line\">        constructpath(root, &quot;&quot;, paths);</span><br><span class=\"line\">        return paths;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void constructpath(TreeNode root, String path, List&lt;String&gt; paths) &#123;</span><br><span class=\"line\">        if (root != null) &#123;</span><br><span class=\"line\">            StringBuffer temppath = new StringBuffer(path); //注意这里，每次递归都对变量path进行拷贝构造</span><br><span class=\"line\">            temppath.append(root.val);</span><br><span class=\"line\">            if (root.left == null &amp;&amp; root.right == null) &#123;  //到了叶子节点就代表结束了</span><br><span class=\"line\">                paths.add(temppath.toString());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                temppath.append(&quot;-&gt;&quot;);</span><br><span class=\"line\">                constructpath(root.left, temppath.toString(), paths);</span><br><span class=\"line\">                constructpath(root.right, temppath.toString(), paths);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">对于append和add的用法总结：</span><br><span class=\"line\">1.append</span><br><span class=\"line\">Java里只有StringBuffer和StringBuild才有append方法，Sting里是没有append方法的</span><br><span class=\"line\"></span><br><span class=\"line\">2.add</span><br><span class=\"line\">List集合列表中添加元素</span><br></pre></td></tr></table></figure>\n<h2 id=\"47-全排列2-medium\"><a href=\"#47-全排列2-medium\" class=\"headerlink\" title=\"47 全排列2 medium\"></a>47 全排列2 medium</h2><p>和<a href=\"https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/#46-%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%9E%E6%BA%AF%E6%B3%95-medium\">46</a>的区别是，这个题是有重复数字的，而且重复数字不是有序的，而是打乱的。<a href=\"https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/\">官网的题解更简洁</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class=\"line\">        int len = nums.length;</span><br><span class=\"line\">        boolean[] used = new boolean[len];</span><br><span class=\"line\">        if (len == 0) &#123;</span><br><span class=\"line\">            return res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(nums); //区别1，首先要对数列进行排序</span><br><span class=\"line\">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();</span><br><span class=\"line\">        dfs(nums, len, 0, path, used, res);</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void dfs(int[] nums, int len, int depth, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class=\"line\">        if (depth == len) &#123;</span><br><span class=\"line\">            res.add(new ArrayList(path));</span><br><span class=\"line\">            return;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">            if (used[i] == true || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false)) &#123; //区别2，还要判断和前一个数是不是一样的，这里used[i - 1] == false不好理解，下面单独解释</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.addLast(nums[i]);</span><br><span class=\"line\">            used[i] = true;</span><br><span class=\"line\">            dfs(nums, len, depth + 1, path, used, res);</span><br><span class=\"line\">            used[i] =  false;</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题首先要排序哦</span><br><span class=\"line\">i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]这个很好理解，就是重复的数字不要再进行了，但是used[i - 1] == false这个其实是不好理解的，我在做的时候就在想为什么还要多加这个条件呢？。</span><br><span class=\"line\"></span><br><span class=\"line\">来自网友1的解释（vis和上面used作用一样）：</span><br><span class=\"line\">加上 !vis[i - 1]来去重主要是通过限制一下两个相邻的重复数字的访问顺序</span><br><span class=\"line\">举个栗子，对于两个相同的数11，我们将其命名为1a1b, 1a表示第一个1，1b表示第二个1； 那么，不做去重的话，会有两种重复排列 1a1b, 1b1a， 我们只需要取其中任意一种排列； 为了达到这个目的，限制一下1a, 1b访问顺序即可。 比如我们只取1a1b那个排列的话，只有当visit nums[i-1]之后我们才去visit nums[i]， 也就是如果!visited[i-1]的话则continue</span><br><span class=\"line\"></span><br><span class=\"line\">来自网友2的解释：</span><br><span class=\"line\">for循环保证了从数组中从前往后一个一个取值，再用if判断条件。所以nums[i - 1]一定比nums[i]先被取值和判断。如果nums[i - 1]被取值了，那vis[i - 1]会被置1，只有当递归再回退到这一层时再将它置0。每递归一层都是在寻找数组对应于递归深度位置的值，每一层里用for循环来寻找。所以当vis[i - 1] == 1时，说明nums[i - 1]和nums[i]分别属于两层递归中，也就是我们要用这两个数分别放在数组的两个位置，这时不需要去重。但是当vis[i - 1] == 0时，说明nums[i - 1]和nums[i]属于同一层递归中（只是for循环进入下一层循环），也就是我们要用这两个数放在数组中的同一个位置上，这就是我们要去重的情况。</span><br></pre></td></tr></table></figure>\n<h2 id=\"40-组合总和-II-medium\"><a href=\"#40-组合总和-II-medium\" class=\"headerlink\" title=\"40 组合总和 II medium\"></a>40 组合总和 II medium</h2><p>深度优先遍历，务必注意解集不能包含重复组合，每个数字在每个组合中只能使用一次，<a href=\"https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/\">这个博主解释不错</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> candidates.length;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Arrays.sort(candidates);<span class=\"comment\">//务必要排序</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;(len);<span class=\"comment\">//用双端队列会更好操作，不加len也可以</span></span><br><span class=\"line\">        dfs(candidates, len, <span class=\"number\">0</span>, target, path, res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> len, <span class=\"type\">int</span> begin, <span class=\"type\">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> begin; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target - candidates[i] &lt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果减了小于0，就没必要进行了</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class=\"number\">1</span>]) &#123;<span class=\"comment\">//同一层相同元素只考虑第一个，没有这个操作可能会导致结果集合一样，i&gt;begin是精髓，可以看上面链接中的评论，有详细回答。</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.addLast(candidates[i]);</span><br><span class=\"line\">            dfs(candidates, len, i + <span class=\"number\">1</span>, target - candidates[i], path, res);</span><br><span class=\"line\">            path.removeLast();<span class=\"comment\">//深度遍历思想是继续往下探索如果没有就返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Linklist写法</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> candidates.length;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;Integer&gt;();<span class=\"comment\">//这里不同</span></span><br><span class=\"line\">        dfs(candidates, len, target, <span class=\"number\">0</span>, res, path);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> len,<span class=\"type\">int</span> target, <span class=\"type\">int</span> begin, List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(target == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> begin; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(target - candidates[i] &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.add(candidates[i]);<span class=\"comment\">//这里不同</span></span><br><span class=\"line\">            dfs(candidates, len, target - candidates[i], i + <span class=\"number\">1</span>, res, path);</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"37-解数独-hard-未完成\"><a href=\"#37-解数独-hard-未完成\" class=\"headerlink\" title=\"37 解数独 hard 未完成\"></a>37 解数独 hard 未完成</h2><h2 id=\"310-最小高度树-medium-未完成\"><a href=\"#310-最小高度树-medium-未完成\" class=\"headerlink\" title=\"310 最小高度树 medium 未完成\"></a>310 最小高度树 medium 未完成</h2><h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>dp三要素，定义状态，初始状态，状态转移</p>\n<h2 id=\"70-爬楼梯-easy\"><a href=\"#70-爬楼梯-easy\" class=\"headerlink\" title=\"70 爬楼梯 easy\"></a>70 爬楼梯 easy</h2><p>题目说可以跨一步或者两步，动态规划最重要就是有一个状态转移方程，f(x)&#x3D;f(x−1)+f(x−2)，你可以理解为，我走到x级的时候，我的方案数量就是走到x-1级的所有数量加上我走到x-2级的所有数量。怎么理解呢？比如我知道x-1级的所有方案数量，我再走一步就可以到达x级，同理，x-2级也是这样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">2</span>) &#123;    <span class=\"comment\">//注意力扣是计算1到45级阶梯,0是不算的，然后的话我们的状态转移方程是需要前一级和前前一级的，所以1和2是要已知的。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pre2</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>, pre1 = <span class=\"number\">2</span>, cur = <span class=\"number\">0</span>; <span class=\"comment\">//pre2代表前两级，这里初始的1代表只有一个方案，也就是上第一级楼梯只有一个方案，pre1代表前一级楼梯，可以理解为上第二级楼梯的方案有两种，要么跨两步，要么就是连续走一步。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; n ; i++) &#123;  <span class=\"comment\">//注意别忘了从第三级楼梯开始，这里和n（就是直接为多少级）含义不一样，不要混淆，因为这个for循环是计数用的，i=2代表从第三级开始。</span></span><br><span class=\"line\">            cur = pre1 + pre2; </span><br><span class=\"line\">            pre2 = pre1;</span><br><span class=\"line\">            pre1 = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"198-打家劫舍-medium\"><a href=\"#198-打家劫舍-medium\" class=\"headerlink\" title=\"198 打家劫舍 medium\"></a>198 打家劫舍 medium</h2><p>直接说大于两间房的情况，那么有两种情况1.偷窃第k间房屋，那么就不能偷窃第k-1间房屋，偷窃总金额为前k-2间房屋的最高总金额与第k间房屋的金额之和。2.不偷窃第k间房屋，偷窃总金额为前k−1间房屋的最高总金额。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">first</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>], second = Math.max(nums[<span class=\"number\">0</span>],nums[<span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; len; i++) &#123;<span class=\"comment\">//从第三间房开始,每间房之和该房屋的前两间房的最高总金额有关，因此用一个滚动数组，每个时刻只存储前两间房的最高金额。</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> second;<span class=\"comment\">//一个temp来保存先</span></span><br><span class=\"line\">            second = Math.max(first + nums[i], second);<span class=\"comment\">//这时候开始找最大值</span></span><br><span class=\"line\">            first = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"413-等差数列划分-medium\"><a href=\"#413-等差数列划分-medium\" class=\"headerlink\" title=\"413 等差数列划分 medium\"></a>413 等差数列划分 medium</h2><p>首先要注意至少是三个元素才可以，其次注意子数组也算，比如[1,2,3,4]这个就可以有[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 三个等差数组。下面t++是不太好理解的，可以看官方解释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numberOfArithmeticSlices</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(len == <span class=\"number\">1</span> || len == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">d</span> <span class=\"operator\">=</span> nums[<span class=\"number\">1</span>] - nums[<span class=\"number\">0</span>], t = <span class=\"number\">0</span>, ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i] - nums[i - <span class=\"number\">1</span>] == d) &#123;</span><br><span class=\"line\">                ++t;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                d = nums[i] - nums[i - <span class=\"number\">1</span>];<span class=\"comment\">//否则重新计算d，比如可以试试[1,2,3,8,9,10]，答案是2个</span></span><br><span class=\"line\">                t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans += t;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"64-最小路径和-medium\"><a href=\"#64-最小路径和-medium\" class=\"headerlink\" title=\"64 最小路径和 medium\"></a>64 最小路径和 medium</h2><p>首先要注意，路径只能向下或者向右，其次，返回的是最后路径的大小，而不是路径本身。本方法是创建一个最小路径的矩阵，也就是每个位置记录从左上角到这里最小值，最后返回右下角位置的值即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minPathSum</span><span class=\"params\">(<span class=\"type\">int</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (grid == <span class=\"literal\">null</span> || grid.length == <span class=\"number\">0</span> || grid[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//这道题是二维矩阵的题</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rows</span> <span class=\"operator\">=</span> grid.length, columns = grid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[rows][columns];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = grid[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; rows; i++) &#123;     <span class=\"comment\">//考虑第一行的情况，只能往右边走，所以新构建的dp矩阵是dp左边元素加grip[i][0]的距离，再次说明dp矩阵表示距离</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + grid[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; columns; j++) &#123;   <span class=\"comment\">//考虑第一列的情况</span></span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = dp[<span class=\"number\">0</span>][j - <span class=\"number\">1</span>] + grid[<span class=\"number\">0</span>][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; rows; i++) &#123;    <span class=\"comment\">//考虑里面的元素，请注意，务必先考虑完第一行和第一列的元素才能写这里，否则我们不知道怎么找上一个元素的距离，因为里面的元素也是和左边和上面元素相关</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; columns; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = Math.min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]) + grid[i][j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[rows - <span class=\"number\">1</span>][columns - <span class=\"number\">1</span>];<span class=\"comment\">//构建完后返回最后一个元素的值即可</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"542-01矩阵-medium\"><a href=\"#542-01矩阵-medium\" class=\"headerlink\" title=\"542 01矩阵 medium\"></a>542 01矩阵 medium</h2><p>和上一题一样，构建一个距离矩阵，但是本题又和上一题不太一样哦，是寻找每个元素距离0最近的距离。只有 水平向左移动 和 竖直向上移动，只有 水平向右移动 和 竖直向下移动。本题的思路是这个点周围的邻居到0的最小距离+1就是这个点到0的最短距离。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] updateMatrix(<span class=\"type\">int</span>[][] mat) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> mat.length, n = mat[<span class=\"number\">0</span>].length; </span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dist = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;  <span class=\"comment\">//初始化二维数组全部最最大值</span></span><br><span class=\"line\">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class=\"number\">2</span>);<span class=\"comment\">//填充一维数组只需要Arrays.fill(Object[] ary, Object val)赋值，那么二维数组就需要一个循环。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt; m; i++) &#123;  <span class=\"comment\">//初始化位置为0的元素距离就是0</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (mat[i][j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dist[i][j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//动态规划务必注意要找前一个的状态。至于为什么本题只需要左上和右下，可以看题解的评论，当然了，你也可以选择右上(右上角到左下角遍历)和左下(左下角到右上角遍历)。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"comment\">//从左上角到右下角遍历,为什么左上是从左上角开始遍历，因为这是DP，需要知道前一步的状态。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//检查上邻居,if条件是为了有上邻居，而不至于越界。</span></span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - <span class=\"number\">1</span> &gt;= <span class=\"number\">0</span>) &#123;<span class=\"comment\">//检查左邻居,if条件是为了有左邻居，而不至于越界。</span></span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class=\"line\">        <span class=\"comment\">//从右下角到左上角遍历</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> m - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> n - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i + <span class=\"number\">1</span> &lt; m) &#123;<span class=\"comment\">//检查下邻居</span></span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j + <span class=\"number\">1</span> &lt; n) &#123;<span class=\"comment\">//检查右邻居</span></span><br><span class=\"line\">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class=\"number\">1</span>] + <span class=\"number\">1</span>); </span><br><span class=\"line\">                &#125;                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">为啥只用左上和右下就行？ 用最简单的只有一个<span class=\"number\">0</span>的来示例（来自网友的图）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1111</span></span><br><span class=\"line\"><span class=\"number\">1111</span></span><br><span class=\"line\"><span class=\"number\">1011</span></span><br><span class=\"line\"><span class=\"number\">1111</span></span><br><span class=\"line\"></span><br><span class=\"line\">左上（左邻居和上邻居）之后变成(其中-表示<span class=\"type\">int</span>最大值)</span><br><span class=\"line\">----</span><br><span class=\"line\">----</span><br><span class=\"line\">-<span class=\"number\">012</span></span><br><span class=\"line\">-<span class=\"number\">123</span></span><br><span class=\"line\"></span><br><span class=\"line\">接下来的右下就是取某个点的右上和左下其中比较小的值 加一 就行 现在根据已知的右下角这一坨 已经可以推出其余的全部了 比如左下角那一坨</span><br><span class=\"line\"></span><br><span class=\"line\">----</span><br><span class=\"line\">----</span><br><span class=\"line\"><span class=\"number\">1012</span></span><br><span class=\"line\"><span class=\"number\">2123</span></span><br><span class=\"line\"></span><br><span class=\"line\">右上角那一坨</span><br><span class=\"line\"></span><br><span class=\"line\">-<span class=\"number\">234</span></span><br><span class=\"line\">-<span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"number\">1012</span></span><br><span class=\"line\"><span class=\"number\">2123</span></span><br><span class=\"line\"></span><br><span class=\"line\">还有最终左上角的那一坨</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3234</span></span><br><span class=\"line\"><span class=\"number\">2123</span></span><br><span class=\"line\"><span class=\"number\">1012</span></span><br><span class=\"line\"><span class=\"number\">2123</span></span><br><span class=\"line\"></span><br><span class=\"line\">我自己的一个小例子</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">01</span></span><br><span class=\"line\"></span><br><span class=\"line\">左上后</span><br><span class=\"line\">m0</span><br><span class=\"line\">m1</span><br><span class=\"line\"></span><br><span class=\"line\">右下后</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"221-最大正方形-medium\"><a href=\"#221-最大正方形-medium\" class=\"headerlink\" title=\"221 最大正方形 medium\"></a>221 最大正方形 medium</h2><p>首先需要注意,dp[i][j]是以i，j坐标为右下角的正方形边长。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maximalSquare</span><span class=\"params\">(<span class=\"type\">char</span>[][] matrix)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (matrix == <span class=\"literal\">null</span> || matrix.length == <span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxsize</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span> [][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123; </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span> || j == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//在边界的情况</span></span><br><span class=\"line\">                        dp[i][j] = <span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//不在边界，等于这个坐标的左边，上边，左斜上边的最小值加上1，同时也是本题的动态规划转移方程。</span></span><br><span class=\"line\">                        dp[i][j] = Math.min(Math.min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]), dp[i][j - <span class=\"number\">1</span>]) +<span class=\"number\">1</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">                maxsize = Math.max(maxsize, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxsize * maxsize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面一个图来自网友，解释了为什么用左边，上边，左斜上边的最小值。<br><img src=\"/images/leetcode-java/221.png\"></p>\n<h2 id=\"279-完全平方数-medium\"><a href=\"#279-完全平方数-medium\" class=\"headerlink\" title=\"279 完全平方数 medium\"></a>279 完全平方数 medium</h2><p>推荐看这个<a href=\"https://leetcode.cn/problems/perfect-squares/solution/279-wan-quan-ping-fang-shu-by-chen-wei-f-gwzs/\">作者</a>的讲解，非常好</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numSquares</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//初始化0的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n + <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            dp[i] = i;<span class=\"comment\">//每个位置最差的情况就是i个数，比如dp[12]最大就是12个1来组成</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i - j * j &gt;=<span class=\"number\">0</span> ; j++) &#123;<span class=\"comment\">//你不能f[12]来一个16的平方数，所以i-j*j要大于等于0</span></span><br><span class=\"line\">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这里解释下状态转移方程</span></span><br><span class=\"line\"><span class=\"comment\">比如递推到找f[11]</span></span><br><span class=\"line\"><span class=\"comment\">那么可以拆成f[2] + 1（这个1表示9这个完全平方数，也可以理解为f[11 - 9]再加上一个9就能组成f[11]的数量，这里不要混了，f[n]表示的是一个数量，加9这个平方数就是加一个1，这也是为什么状态转移方程是+1）</span></span><br><span class=\"line\"><span class=\"comment\">还能拆成f[7] + 4这个平方数, f[7]也就是f[11 - 4]，所以f[7]的数量，再加一个1，可以表示成f[11]的数量。</span></span><br><span class=\"line\"><span class=\"comment\">还能拆成f[10] + 1这个平方数，同理不再叙述</span></span><br><span class=\"line\"><span class=\"comment\">然后找他们最小值即可。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//根据书上例子写的，上面那个更好理解</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numSquares</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n ; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;  j * j &lt;= i ; j++) &#123;</span><br><span class=\"line\">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"91-解码方法-medium\"><a href=\"#91-解码方法-medium\" class=\"headerlink\" title=\"91 解码方法 medium\"></a>91 解码方法 medium</h2><p>这个题思考了比较久，题解是根据书上改成java的，虽然比较长，但是好理解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numDecodings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">prev</span> <span class=\"operator\">=</span> s.charAt(<span class=\"number\">0</span>) -<span class=\"number\">48</span>;<span class=\"comment\">//因为s是字符串，我们提取出来的数字是ASCII码，48是0的ASCII码，这样写转成数字，比如&#x27;1&#x27;就转成1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prev == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);<span class=\"comment\">//全部位置首先置为1，如果单独dp[0]为1，会发现s=12有错误，我一开始以为只置第0个数就行。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> s.charAt(i - <span class=\"number\">1</span>) - <span class=\"number\">48</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((prev == <span class=\"number\">0</span> || prev &gt; <span class=\"number\">2</span>) &amp;&amp; cur == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//如果当前为0，并且前一个数是0或者大于2，无法解码,注意if中第一个括号很关键，比如是组合在一起(prev == 0 || prev &gt; 2)</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == <span class=\"number\">1</span> || prev == <span class=\"number\">2</span> &amp;&amp; cur &lt; <span class=\"number\">7</span>) &#123;<span class=\"comment\">//如果前一个数是1或者2，并且当前数小于7，考虑组合问题</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cur!=<span class=\"number\">0</span>) &#123;<span class=\"comment\">//首先当前数不为0，也就是当前数和之前那个数可以组合在一起</span></span><br><span class=\"line\">                    dp[i] = dp[i - <span class=\"number\">2</span>] + dp[i - <span class=\"number\">1</span>];<span class=\"comment\">//</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//当前数虽然等于0，但是前一个数为1或者2，也可以组合成10,20，也就是我们当前数是不能单独解码</span></span><br><span class=\"line\">                    dp[i] = dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//无法进行组合了，只能单独解第二个数</span></span><br><span class=\"line\">                dp[i] = dp[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            prev = cur;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">理解过程</span><br><span class=\"line\">这个题是返回解码方法的总数，</span><br><span class=\"line\">首先定义一个长为n+1的数组，dp[2]就表示前2个数的解码方法总数，所以最后返回dp[n]就代表题目要求的答案了。</span><br><span class=\"line\"></span><br><span class=\"line\">如果第一个数字就是0，那不用问，永远解不出来，规则上01和1是不一样的，没有01这个解码。</span><br><span class=\"line\">其次声明好dp数组，长度为n+1，并且全部位置初始化为1，后面会讲到为什么f[0]也要设置为1。</span><br><span class=\"line\">我们要清楚，声明了prev和cur，就是为了看看当前数和前一个数能不能组合起来解码.</span><br><span class=\"line\">进入判断循环,i从2开始，这是为了配合dp数组，因为我们说了dp[i]表示前i个数的解：</span><br><span class=\"line\">       那么cur就是s[i - 1]了，这是s数组的第二个数，prev我们在前面已经声明了。</span><br><span class=\"line\">       首先就是判断无法解码的情况，也就是cur为0，prev也为0或者prev大于2，既不能自己单独解码，也不能和前面组合解码。</span><br><span class=\"line\">       然后判断可以解码的情况，有组合解码和单独解码</span><br><span class=\"line\">          组合解码又分为11~19,21~26，因为10和20比较特殊，前者既能单独解码，又能组合解码，后者只能单独解码的两位数</span><br><span class=\"line\">          然后单独解码就是只能单独一个解码</span><br><span class=\"line\">       下一轮判断，把cur变成prev</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">为什么f[0]也为1？ 这里摘抄了网友的一个不错的理解：</span><br><span class=\"line\">f[0]代表前0个数字的方案数，这样的状态定义其实是没有实际意义的，但是f[0]的值需要保证边界是对的，即f[1]和f[2]是对的。</span><br><span class=\"line\">比如说，第一个数不为0，那么解码前1个数只有一种方法，将其单独解码，即f[1] = f[1 - 1] = 1。</span><br><span class=\"line\">解码前两个数，如果第1个数和第2个数可以组合起来解码，那么f[2] = f[1] + f[0] = 2 ，否则只能单独解码第2个数，即f[2] = f[1] = 1。</span><br><span class=\"line\">因此，在任何情况下f[0]取1都可以保证f[1]和f[2]是正确的，所以f[0]应该取1。</span><br><span class=\"line\"></span><br><span class=\"line\">然后的话，我们在代码中有一个10和20的特殊解码，dp[i] = dp[i - 2]。因为这里说了如果只能单独解码的话，就f[1] = f[1 - 1] = 1。</span><br><span class=\"line\"></span><br><span class=\"line\">实在不能理解。试试s=20,s=23，尝试自己去理解一下。</span><br></pre></td></tr></table></figure>\n<h2 id=\"139-单词拆分-medium\"><a href=\"#139-单词拆分-medium\" class=\"headerlink\" title=\"139 单词拆分 medium\"></a>139 单词拆分 medium</h2><p>这道题类似于完全平方数分割。然后看到评论题解说用背包问题：单词就是物品，字符串s就是背包，完全背包问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j] == <span class=\"literal\">true</span>) &#123; <span class=\"comment\">//contains比较少用，mark</span></span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">卡哥将得很详细，复制一下记录</span><br><span class=\"line\">单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</span><br><span class=\"line\"></span><br><span class=\"line\">拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span><br><span class=\"line\"></span><br><span class=\"line\">动规五部曲分析如下：</span><br><span class=\"line\"></span><br><span class=\"line\">1.确定dp数组以及下标的含义</span><br><span class=\"line\">dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span><br><span class=\"line\"></span><br><span class=\"line\">2.确定递推公式</span><br><span class=\"line\">如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</span><br><span class=\"line\"></span><br><span class=\"line\">所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</span><br><span class=\"line\"></span><br><span class=\"line\">3.dp数组如何初始化</span><br><span class=\"line\">从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</span><br><span class=\"line\"></span><br><span class=\"line\">那么dp[0]有没有意义呢？</span><br><span class=\"line\"></span><br><span class=\"line\">dp[0]表示如果字符串为空的话，说明出现在字典里。</span><br><span class=\"line\"></span><br><span class=\"line\">但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</span><br><span class=\"line\"></span><br><span class=\"line\">下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</span><br><span class=\"line\"></span><br><span class=\"line\">4.确定遍历顺序</span><br><span class=\"line\">题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</span><br><span class=\"line\"></span><br><span class=\"line\">还要讨论两层for循环的前后循序。</span><br><span class=\"line\"></span><br><span class=\"line\">如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span><br><span class=\"line\"></span><br><span class=\"line\">如果求排列数就是外层for遍历背包，内层for循环遍历物品。</span><br><span class=\"line\"></span><br><span class=\"line\">本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</span><br><span class=\"line\"></span><br><span class=\"line\">那么本题使用求排列的方式，还是求组合的方式都可以。</span><br><span class=\"line\"></span><br><span class=\"line\">即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</span><br><span class=\"line\"></span><br><span class=\"line\">但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</span><br><span class=\"line\"></span><br><span class=\"line\">如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</span><br><span class=\"line\"></span><br><span class=\"line\">所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。</span><br><span class=\"line\"></span><br><span class=\"line\">5.举例推导dp[i]</span><br><span class=\"line\">以输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]为例，dp状态如图：</span><br><span class=\"line\">（在下方）</span><br><span class=\"line\">dp[s.size()]就是最终结果。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ps:</span><br><span class=\"line\">五部曲中第一部是最困难的. 一般都是遵循&quot;题目问什么, 就把`dp[]设置成什么</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">作者：carlsun-2</span><br><span class=\"line\">链接：https://leetcode.cn/problems/word-break/solution/dai-ma-sui-xiang-lu-139-dan-ci-chai-fen-50a1a/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/139.jpg\"></p>\n<h2 id=\"300-最长递增子序列-medium\"><a href=\"#300-最长递增子序列-medium\" class=\"headerlink\" title=\"300 最长递增子序列 medium\"></a>300 最长递增子序列 medium</h2><p>首先说明题目说的升序是严格升序，比如777长递增子序列就只有7，也就是长度只有1。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//跟之前的题目有点不同的是dp声明不需要额外声明多一个，因为本题是返回最大值。同样也是卡尔的题解。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        Arrays.fill(dp,<span class=\"number\">1</span>);<span class=\"comment\">//别忘了初试填充1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;<span class=\"comment\">//这里还有一个循环</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>);<span class=\"comment\">//状态转移方程很重要，注意这里是max，而不是比较dp[i], dp[j] + 1</span></span><br><span class=\"line\">                &#125;               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;<span class=\"comment\">//找出最大值即可</span></span><br><span class=\"line\">            res = Math.max(res,dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">卡哥动态规划五部曲</span><br><span class=\"line\">最长上升子序列是动规的经典题目，这里dp[i]是可以根据dp[j] （j &lt; i）推导出来的，那么依然用动规五部曲来分析详细一波：</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i]的定义</span><br><span class=\"line\">dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>状态转移方程</span><br><span class=\"line\">位置i的最长升序子序列等于j从<span class=\"number\">0</span>到i-<span class=\"number\">1</span>各个位置的最长升序子序列 + <span class=\"number\">1</span> 的最大值。</span><br><span class=\"line\"></span><br><span class=\"line\">所以：<span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">注意这里不是要dp[i] 与 dp[j] + <span class=\"number\">1</span>进行比较，而是我们要取dp[j] + <span class=\"number\">1</span>的最大值。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>dp[i]的初始化</span><br><span class=\"line\">每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是<span class=\"number\">1.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>确定遍历顺序</span><br><span class=\"line\">dp[i] 是有<span class=\"number\">0</span>到i-<span class=\"number\">1</span>各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>举例推导dp数组</span><br><span class=\"line\">输入：[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]，dp数组的变化如下：</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/300.jpg\"></p>\n<h2 id=\"1143-最长公共子序列-medium\"><a href=\"#1143-最长公共子序列-medium\" class=\"headerlink\" title=\"1143 最长公共子序列 medium\"></a>1143 最长公共子序列 medium</h2><p>需要注意的是本题要求：”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。本题单纯是动态规划，不是背包问题哦。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一般如果返回dp数组，就好像申请的长度加+1，这样是为了好处理，</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> text1.length(), m = text2.length();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>][m + <span class=\"number\">1</span>];<span class=\"comment\">//除了定义dp，它还会全部设置为0，像之前有些题是初始化为1，要注意对比</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;<span class=\"comment\">//从1开始</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= m; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;<span class=\"comment\">//上面是从1开始，所以我们对比的第一个数是i-1和j-1</span></span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n][m];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">卡哥的解释比较好懂</span><br><span class=\"line\"><span class=\"number\">1.</span>确定dp数组（dp table）以及下标的含义</span><br><span class=\"line\">dp[i][j]：长度为[<span class=\"number\">0</span>, i - <span class=\"number\">1</span>]的字符串text1与长度为[<span class=\"number\">0</span>, j - <span class=\"number\">1</span>]的字符串text2的最长公共子序列为dp[i][j]</span><br><span class=\"line\"></span><br><span class=\"line\">有同学会问：为什么要定义长度为[<span class=\"number\">0</span>, i - <span class=\"number\">1</span>]的字符串text1，定义为长度为[<span class=\"number\">0</span>, i]的字符串text1不香么？</span><br><span class=\"line\"></span><br><span class=\"line\">这样定义是为了后面代码实现方便，如果非要定义为为长度为[<span class=\"number\">0</span>, i]的字符串text1也可以，大家可以试一试！</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">主要就是两大情况： text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]相同，text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]不相同</span><br><span class=\"line\"></span><br><span class=\"line\">如果text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">如果text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]不相同，那就看看text1[<span class=\"number\">0</span>, i - <span class=\"number\">2</span>]与text2[<span class=\"number\">0</span>, j - <span class=\"number\">1</span>]的最长公共子序列 和 text1[<span class=\"number\">0</span>, i - <span class=\"number\">1</span>]与text2[<span class=\"number\">0</span>, j - <span class=\"number\">2</span>]的最长公共子序列，取最大的。</span><br><span class=\"line\"></span><br><span class=\"line\">即：dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>dp数组如何初始化</span><br><span class=\"line\">先看看dp[i][<span class=\"number\">0</span>]应该是多少呢？</span><br><span class=\"line\"></span><br><span class=\"line\">test1[<span class=\"number\">0</span>, i-<span class=\"number\">1</span>]和空串的最长公共子序列自然是<span class=\"number\">0</span>，所以dp[i][<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">同理dp[<span class=\"number\">0</span>][j]也是<span class=\"number\">0</span>。</span><br><span class=\"line\"></span><br><span class=\"line\">其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为<span class=\"number\">0</span>。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>从递推公式，可以看出，有三个方向可以推出dp[i][j]，如图：</span><br><span class=\"line\">(下面第一张图)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span>举例推导dp数组</span><br><span class=\"line\">以输入：text1 = <span class=\"string\">&quot;abcde&quot;</span>, text2 = <span class=\"string\">&quot;ace&quot;</span> 为例，dp状态如图：</span><br><span class=\"line\">(下面第二张图)</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/1143-1.jpg\"><br><img src=\"/images/leetcode-java/1143-2.jpg\"></p>\n<h2 id=\"416-分割等和子集-medium（0-1背包）\"><a href=\"#416-分割等和子集-medium（0-1背包）\" class=\"headerlink\" title=\"416 分割等和子集 medium（0-1背包）\"></a>416 分割等和子集 medium（0-1背包）</h2><p>本题是0-1背包问题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPartition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums == <span class=\"literal\">null</span> || nums.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num:nums)&#123;</span><br><span class=\"line\">            sum += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[target + <span class=\"number\">1</span>];<span class=\"comment\">//已经默认初始化为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> target; j &gt;= nums[i]; j--) &#123;<span class=\"comment\">//逆向循环，而且注意j &gt;= nums[i]，我自己的理解是当可以放进去时候的操作，注意物品i的重量是nums[i]，其价值也是nums[i]</span></span><br><span class=\"line\">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> target == dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体看<a href=\"https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF\">Carl的解释</a>，写得挺好，需要好好理解转移方程Math.max(dp[j], dp[j - nums[i]] + nums[i]);</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>-<span class=\"number\">1</span>背包问题和完全背包问题的区别的是，一个是物品只能拿一次，一个物品无限拿。</span><br><span class=\"line\">循环上也有区别：</span><br><span class=\"line\"><span class=\"number\">0</span>-<span class=\"number\">1</span>背包问题物品的迭代放外层，里层的体积或价值逆向遍历，物品放外面，循环完就没了，也就是物品只能拿一次。</span><br><span class=\"line\">完全背包对物品的迭代放里层，外层的体积或价值正向遍历，物品放里面，每次外层循环都会重新循环物品，也就是物品是无限拿的。</span><br><span class=\"line\">本题可以对比看看<span class=\"number\">139</span>。</span><br><span class=\"line\">简单说明几点</span><br><span class=\"line\">dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]，我们本题的容量是sum/<span class=\"number\">2</span> + <span class=\"number\">1</span>来确定的，本题上的dp[j]表示背包总容量是j，最大可以凑成j的子集总和为dp[j]</span><br><span class=\"line\"></span><br><span class=\"line\">本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</span><br><span class=\"line\">所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br></pre></td></tr></table></figure>\n<h3 id=\"背包问题全理解\"><a href=\"#背包问题全理解\" class=\"headerlink\" title=\"背包问题全理解\"></a>背包问题全理解</h3><p>下面是背包问题总结（Carl的笔记加上我自己的理解）：</p>\n<p>二维dp数组01背包<br>1.确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。要时刻记着这个dp数组的含义，也就是一共涉及三个数，一个是物品，一个是容量，然后数组里面存的是价值，数组如图展示：<br><img src=\"/images/leetcode-java/bag-1.png\"></p>\n<p>2.确定递推公式<br>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>\n<p>那么可以有两个方向推出来dp[i][j]，</p>\n<p>不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)<br>放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值<br>所以递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>\n<p>这里一开始不能理解dp[i - 1][j - weight[i]] + value[i]，因为我一开始想，万一背包里面本来就有东西，为什么仅仅判断j&gt;weight[i]就说能放进去呢?是我多虑了，因为二维数组覆盖了所有情况呀。<br>举个例子，背包容量是4，刚好我们物品大小也是4，这时候j-4＝0，我们会去检查i-1情况下0的价值，如果背包容量是5，那就去检查j-4&#x3D;1时候的价值，所以不存在说本来有东西，他会跳到上一步检查的。</p>\n<p>3.dp数组如何初始化<br>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</p>\n<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：<br><img src=\"/images/leetcode-java/bag-2.png\"><br>再看其他情况。</p>\n<p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>\n<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>\n<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>\n<p>当j &gt;&#x3D; weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。<br>此时dp数组初始化情况如图所示<br><img src=\"/images/leetcode-java/bag-3.png\"><br>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>\n<p>其实从递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>\n<p>初始-1，初始-2，初始100，都可以！</p>\n<p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p>\n<p>4.确定遍历顺序<br>在如下图中，可以看出，有两个遍历的维度：物品与背包重量<br><img src=\"/images/leetcode-java/bag-4.png\"><br>那么问题来了，先遍历 物品还是先遍历背包重量呢？</p>\n<p>其实都可以！！ 不过这里针对的是二维数组。</p>\n<p>5.举例推导dp数组<br>来看一下对应的dp数组的数值，如图<br><img src=\"/images/leetcode-java/bag-5.jpg\"></p>\n<p>一维dp数组01背包<br>1.确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>\n<p>2.一维dp数组的递推公式<br>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>\n<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>\n<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>\n<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>\n<p>所以递归公式为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>\n<p>3.一维dp数组如何初始化<br>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</p>\n<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>\n<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>\n<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>\n<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>\n<p>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。</p>\n<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>\n<p>4.一维dp数组遍历顺序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; weight.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</p>\n<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>\n<p>为什么呢？</p>\n<p>倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>\n<p>看完之后发现，也就是二维数组必须要顺着，如果用一维数组处理，要倒着，至于为什么这里需要好好看<a href=\"https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85\">卡哥的网站</a>。</p>\n<h2 id=\"474-一和零-medium-（0-1背包）\"><a href=\"#474-一和零-medium-（0-1背包）\" class=\"headerlink\" title=\"474 一和零 medium （0-1背包）\"></a>474 一和零 medium （0-1背包）</h2><p>注意这个不是多重背包问题。本题就是0-1背包问题。具体看<a href=\"https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E6%80%9D%E8%B7%AF\">卡哥解释</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个题相当于有两个维度的背包，m和n。</span></span><br><span class=\"line\"><span class=\"comment\">而不同长度的字符串就是不同大小的待装物品。</span></span><br><span class=\"line\"><span class=\"comment\">这里是求子集的个数。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMaxForm</span><span class=\"params\">(String[] strs, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];<span class=\"comment\">//虽然这个是二维数组，但是不是我们理解那个用二维数组解决的背包问题，这是拥有两个维度的背包，实际上我们是用滚动数组来做的。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;<span class=\"comment\">//先遍历物品</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">onenum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, zeronum = <span class=\"number\">0</span>;<span class=\"comment\">//每次遍历物品都要重新计算</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : str.toCharArray()) &#123;<span class=\"comment\">//这个写法mark</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;0&#x27;</span>) &#123;<span class=\"comment\">//统计每个物品的0和1的数量，注意我们是一个字符串当成一个物品。</span></span><br><span class=\"line\">                    zeronum++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onenum++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值value[i]</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> m; i &gt;= zeronum; i--) &#123;<span class=\"comment\">//请注意这里是在遍历物品的内部循环，然后这个m是背包容量，逆序遍历</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span>  <span class=\"variable\">j</span> <span class=\"operator\">=</span> n; j &gt;= onenum; j--) &#123;<span class=\"comment\">//背包的第二个维度，也是逆序遍历</span></span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i][j], dp[i - zeronum][j - onenum] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"322-零钱兑换-medium（完全背包）\"><a href=\"#322-零钱兑换-medium（完全背包）\" class=\"headerlink\" title=\"322 零钱兑换 medium（完全背包）\"></a>322 零钱兑换 medium（完全背包）</h2><p>每种币的数量是无限，本题属于完全背包问题。注意这个题要取最小的。<a href=\"https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#_322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2\">讲解链接。</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个更好理解，先遍历背包，再遍历物品，和之前不太一样的是，我们取最小的，这点对初始化很重要哦，而且在判断上也要注意一点。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">coinChange</span><span class=\"params\">(<span class=\"type\">int</span>[] coins, <span class=\"type\">int</span> amount)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);<span class=\"comment\">//除了0位置，必须要初始化为最大值，不然你要是都是0，用min的时候就都变成0了，被覆盖掉了</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//同上面一样的初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= amount; i++) &#123;<span class=\"comment\">//先遍历背包</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; coins.length; j++) &#123;<span class=\"comment\">//遍历物品，这种写法就比较好理解用无限硬币</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i- coins[j] &gt;= <span class=\"number\">0</span> &amp;&amp; dp[i - coins[j]] != Integer.MAX_VALUE) &#123;<span class=\"comment\">//后面这个不为max值很重要，不然到最后max值会变成负数，然后有这个判断就可以跳过。只有dp[i-coins[j]]不是初始最大值时，该位才有选择的必要</span></span><br><span class=\"line\">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class=\"number\">1</span>);<span class=\"comment\">//必须要背包容量打于当前的coin大小才进入这一步</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dp[amount] == Integer.MAX_VALUE) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//物品是coin，背包是amount，这个写法是先遍历物品，再遍历背包，我感觉不如上面一个好理解。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">coinChange</span><span class=\"params\">(<span class=\"type\">int</span>[] coins, <span class=\"type\">int</span> amount)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);<span class=\"comment\">//因为求min，所以要把除了0位置的地方赋值为最大值</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//把0位置赋值为0，因为你的钱要是为0，就不可能用任何硬币来组合。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;<span class=\"comment\">//物品外循环</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class=\"comment\">//背包内循环 当然这个题也可以反过来循环，不过if条件要改变。本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((dp[j - coins[i]]) != Integer.MAX_VALUE) &#123;<span class=\"comment\">//只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要</span></span><br><span class=\"line\">                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dp[amount] == Integer.MAX_VALUE) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*这里一开始写内循环是j = 0，但是我们要每个时候都要想dp[j]代表什么含义，当j为0，直接减去coin就是负数了，不过还是没特别理解，多做题把。</span></span><br><span class=\"line\"><span class=\"comment\">dp[j]：凑足总额为j所需钱币的最少个数为dp[j]*/</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"72-编辑距离-hard\"><a href=\"#72-编辑距离-hard\" class=\"headerlink\" title=\"72 编辑距离 hard\"></a>72 编辑距离 hard</h2><p>注意word1变成word2，中间的操作不需要指定多少次，反正直到变成word2，增删替都能无数次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> word1.length(), n  = word2.length();</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp =  <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;i &lt;=m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;=n; j++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][j] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;=m ;i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;=n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1.charAt(i - <span class=\"number\">1</span>) == word2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(Math.min(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]), dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;           </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个需要理解几个点，跟其他动态规划有点不一样，但是又是相似的套路。</span><br><span class=\"line\">1.dp[i][j]含义：dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。</span><br><span class=\"line\">注意是到这个位置结尾的单词，而不是整个单词。</span><br><span class=\"line\">时刻理解dp含义！时刻理解dp含义！时刻理解dp含义！时刻理解dp含义！</span><br><span class=\"line\">2.注意删除操作和增加操作是一回事</span><br><span class=\"line\"></span><br><span class=\"line\">理解 word1 上的删除等价 word2 上的增加, word1 上的增加等价于 word2 上的删除，另外一个博主的理解：dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。</span><br><span class=\"line\"></span><br><span class=\"line\">按照我自己理解把</span><br><span class=\"line\">删除操作：我们这时候要删掉word这个位置的元素，那么我向word1前推一个字符查看那时候的步数，也就是dp[i-1]，j位置不变，然后再加上删除这个操作就可以+1步数。</span><br><span class=\"line\">替换操作：word1和word2这个位置没有删除，没有添加，那就同时推前面一个元素。</span><br><span class=\"line\">增加操作(等价于word2删除)：word1这个位置要增加元素操作，然后我们知道word1的增加等价于word2删除，那就dp[j-1]推前一个位置，i不变。</span><br><span class=\"line\">3.初始化和其他方法很不同，因为我们要理解dp[i][0]的含义，dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。</span><br><span class=\"line\"></span><br><span class=\"line\">那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i，相反dp[0][j]就是对元素进行添加。</span><br><span class=\"line\"></span><br><span class=\"line\">注意上面是i，而不是word1的长度，而不是word1的长度，而不是word1的长度，而不是word1的长度，务必时刻理解dp[i][j]的含义。</span><br></pre></td></tr></table></figure>\n<p>借一张图理解，比如ho和ro那个黄色格子(2,2)的意思就是(1,1)一样的步数，那么(1,1)的理解就是h变成r的过程步数，怎么变不重要，我们只关心步数。<br><img src=\"/images/leetcode-java/72.png\"></p>\n<h2 id=\"650-只有两个键的键盘-medium\"><a href=\"#650-只有两个键的键盘-medium\" class=\"headerlink\" title=\"650 只有两个键的键盘 medium\"></a>650 只有两个键的键盘 medium</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//复制算一次，粘贴算一次</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minSteps</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);<span class=\"comment\">//求min务必要初始化最大值</span></span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//但是1是0，因为笔记本上本来就存在一个A，不需要操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= i / <span class=\"number\">2</span>; j++) &#123;<span class=\"comment\">//也可写成 j &lt;= i，不过除以2更好，要明白复制粘贴的意义，也就是翻倍的意思</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i % j == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//必须要被除尽才可以，这样说明j个A可以通过复制粘贴得到i个A</span></span><br><span class=\"line\">                    dp[i] = Math.min(dp[i], dp[j] + i / j);<span class=\"comment\">//比如6可以除以3，也可以除以2，但是我们要拿最小次数来复制粘贴，当然这里只是打个比方，可能3和2次数一样</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意复制是一次操作，粘贴又是一次操作</span><br><span class=\"line\">总体思路：对每一个格子i（i个A），如果i可以被j除尽，说明j个A可以通过复制粘贴得到i个A，复制粘贴次数为i / j。</span><br><span class=\"line\">每个格子的意义：得到目前数量个A需要的最少操作次数</span><br><span class=\"line\">递推公式：dp[i] = min(dp[i], dp[j] + i / j)dp[i]=min(dp[i],dp[j]+i/j)，其中i % j == 0i</span><br><span class=\"line\">初始化：1个A不需要操作，初始化为0</span><br><span class=\"line\"></span><br><span class=\"line\">作者：Reconcile</span><br><span class=\"line\">链接：https://leetcode.cn/problems/2-keys-keyboard/solution/dong-tai-gui-hua-jie-fa-by-reconcile-t3fr/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这里举个例子，dp[1]~dp[5]的情况是0 2 3 4 5 </span><br><span class=\"line\">到了dp[6]，答案也是5，因为6可以复制3的情况，然后再粘贴，那么3本身需要3次，6/3=2,3+2＝5。也就是i/j是复制粘贴的次数。</span><br><span class=\"line\"></span><br><span class=\"line\">这里理解下为什么是i/j次，比如dp[8]，</span><br><span class=\"line\">如果我们是复制dp[2]的情况，需要8/2=4次，首先复制AA，然后粘贴三次，一共四次操作加上dp[2]操作。</span><br><span class=\"line\">如果复制dp[4]的情况，8/4=2，首先复制AAAA，然后粘贴一次，一共2次操作加上dp[4]操作。</span><br><span class=\"line\">如果复制dp[1]的情况，8/1=8，首先复制A，然后粘贴七次，一共8次操作加上dp[1]操作。</span><br><span class=\"line\">当然，上面的情况要比较然后取最小值。</span><br></pre></td></tr></table></figure>\n<h2 id=\"10-正则表达式匹配-hard-未完成\"><a href=\"#10-正则表达式匹配-hard-未完成\" class=\"headerlink\" title=\"10 正则表达式匹配 hard(未完成)\"></a>10 正则表达式匹配 hard(未完成)</h2><h2 id=\"121-买卖股票的最佳时机-easy\"><a href=\"#121-买卖股票的最佳时机-easy\" class=\"headerlink\" title=\"121 买卖股票的最佳时机 easy\"></a>121 买卖股票的最佳时机 easy</h2><p>这个题目的股票只买卖一次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态回归，符合本章节，但是最简单还是贪心算法，因为这个题目的股票只买卖一次。这个做法没有具体去理解，可以看卡哥解释。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prices == <span class=\"literal\">null</span> || prices.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">length</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"comment\">// dp[i][0]代表第i天持有股票的最大收益</span></span><br><span class=\"line\">        <span class=\"comment\">// dp[i][1]代表第i天不持有股票的最大收益</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[length][<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];<span class=\"comment\">//一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//第0天不持有股票最大收益</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[length - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//贪心算法，最简单这个</span></span><br><span class=\"line\"><span class=\"comment\">//取左边低值，取右边高值即可，因为只买卖一次。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            low = Math.min(low, prices[i]);</span><br><span class=\"line\">            result = Math.max(result, prices[i] - low);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个答案是超时的，但至少是自己想出来的，哎，太暴力了。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (prices[j] - prices[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], prices[j] - prices[i]);</span><br><span class=\"line\">                    result = Math.max(result, dp[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"188-买卖股票的最佳时机-IV\"><a href=\"#188-买卖股票的最佳时机-IV\" class=\"headerlink\" title=\"188 买卖股票的最佳时机 IV\"></a>188 买卖股票的最佳时机 IV</h2><p>这个题目是可以最多交易K次，也就是你交易的次数可以少于k，但是必须在再次购买前出售掉之前的股票，而且利润要最大化。k为1，也就是可以买一次，卖一次，这个算交易一次。k为2，也就是一共可以买2次，卖两次。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prices.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">2</span> * k + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">2</span> * k; i += <span class=\"number\">2</span>) &#123;<span class=\"comment\">//只初始化第0天的买入状态，然后其他是默认0</span></span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;<span class=\"comment\">//第0天上面已经初始化好了，所以直接从第一天开始</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; <span class=\"number\">2</span> * k - <span class=\"number\">1</span>; j += <span class=\"number\">2</span>) &#123;<span class=\"comment\">//状态要从0开始，然后隔两个操作，长度是2k-1是因为我们总的长度是2k+1，然后现在隔2来操作，只有长度为2k-1才不至于越界，因为2k-1+2为2k+1，这是总长度</span></span><br><span class=\"line\">                dp[i][j + <span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j] - prices[i]); <span class=\"comment\">//处理买入股票的状态</span></span><br><span class=\"line\">                dp[i][j + <span class=\"number\">2</span>] = Math.max(dp[i - <span class=\"number\">1</span>][j + <span class=\"number\">2</span>], dp[i - <span class=\"number\">1</span>][j + <span class=\"number\">1</span>] + prices[i]);<span class=\"comment\">//处理卖出股票的状态</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n - <span class=\"number\">1</span>][k * <span class=\"number\">2</span>];<span class=\"comment\">//i的大小是n，那么最后的坐标就是n-1,j的大小是k*2+1，那么坐标就是k*2。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">重点理解</span><br><span class=\"line\">dp长度是dp[price.length][2 * k + 1]</span><br><span class=\"line\">也就是每一天都有2k+1个状态</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">务必清楚dp[i][j]的意思是第i天买入股票的状态是j</span><br><span class=\"line\">最少有3个状态，0代表不操作，1代表第一次买入，2代表第第一次卖出，如果你的k是2，那么也许还有第二次买入，第二次卖出，当然了，你的交易次数最大是k，不一定非要用完k</span><br><span class=\"line\"></span><br><span class=\"line\">首先是初始化，dp[0][i] = -prices[0];表示买入，因为你买入就是钱是负数，然后如果卖出的话，当前价格加上上次买入的状态，就是你的利润，如-1+5=4，一开始我们买入价格是1，置为负数，然后卖出的时候价格是4，就可以得到利润了，还需要注意我们必须买入第二次的时候，第一次已经交易完毕了，不能连续买入而没有卖出，所以，只要是买入状态，就是负数。</span><br><span class=\"line\"></span><br><span class=\"line\">其次是状态的改变：</span><br><span class=\"line\">dp[i][1]状态有两个情况，我们上面说1就是买入状态，但是这里需要更详细说明，1可能是两个操作，买入和不操作状态。</span><br><span class=\"line\">不操作就是延续前一天的状态：dp[i - 1][1]：前一天买入的状态</span><br><span class=\"line\">买入就是dp[i - 1][0] - price[0]：前一天不操作的状态</span><br><span class=\"line\"></span><br><span class=\"line\">dp[i][2]状态有两个情况，我们上面说2就是卖出状态，但是这里需要更详细说明，2可能是两个操作，卖出和不操作状态。</span><br><span class=\"line\">不操作就是延续前一天的状态：dp[i - 1][2]：前一天不操作的状态</span><br><span class=\"line\">卖出就是dp[i - 1][1] + price[i]：前一天买了股票的钱再加上今天卖出的价格</span><br></pre></td></tr></table></figure>\n<h2 id=\"309-最佳买卖股票时机含冷冻期-medium\"><a href=\"#309-最佳买卖股票时机含冷冻期-medium\" class=\"headerlink\" title=\"309 最佳买卖股票时机含冷冻期 medium\"></a>309 最佳买卖股票时机含冷冻期 medium</h2><p>和上一题的区别是，多了一个冷冻期，也就是卖出的第二天不能买入股票，<a href=\"https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E6%80%9D%E8%B7%AF\">卡哥笔记</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> prices.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span> || prices == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][<span class=\"number\">4</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] - prices[i], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] - prices[i]));</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">2</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i];</span><br><span class=\"line\">            dp[i][<span class=\"number\">3</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(dp[n - <span class=\"number\">1</span>][<span class=\"number\">1</span>], Math.max(dp[n - <span class=\"number\">1</span>][<span class=\"number\">2</span>], dp[n - <span class=\"number\">1</span>][<span class=\"number\">3</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">主要是理解四个状态的情况和初始化的情况，具体看卡哥的笔记，这里简单写4个状态的意思</span><br><span class=\"line\">0：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</span><br><span class=\"line\">1：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span><br><span class=\"line\">2：今天卖出了股票</span><br><span class=\"line\">3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</span><br><span class=\"line\">其中1和2都是属于卖出股票的状态，只是分成更细的。</span><br></pre></td></tr></table></figure>\n<h2 id=\"213\"><a href=\"#213\" class=\"headerlink\" title=\"213\"></a>213</h2><h2 id=\"53\"><a href=\"#53\" class=\"headerlink\" title=\"53\"></a>53</h2><h2 id=\"343\"><a href=\"#343\" class=\"headerlink\" title=\"343\"></a>343</h2><h2 id=\"583\"><a href=\"#583\" class=\"headerlink\" title=\"583\"></a>583</h2><h2 id=\"646\"><a href=\"#646\" class=\"headerlink\" title=\"646\"></a>646</h2><h2 id=\"376\"><a href=\"#376\" class=\"headerlink\" title=\"376\"></a>376</h2><h2 id=\"494\"><a href=\"#494\" class=\"headerlink\" title=\"494\"></a>494</h2><h2 id=\"714\"><a href=\"#714\" class=\"headerlink\" title=\"714\"></a>714</h2><h1 id=\"分治法\"><a href=\"#分治法\" class=\"headerlink\" title=\"分治法\"></a>分治法</h1><h2 id=\"241-为运算表达式设计优先级-medium\"><a href=\"#241-为运算表达式设计优先级-medium\" class=\"headerlink\" title=\"241 为运算表达式设计优先级 medium\"></a>241 为运算表达式设计优先级 medium</h2><p><a href=\"https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/xin-ren-xiang-tong-su-yi-dong-java-fen-z-3xhh/\">注意本题只有加减乘三个符号，没有除号，这个博主讲得是最详细容易理解的</a>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//博主的答案，额外有些不明白的地方多加了解释，分治的思想就是把原问题分成子问题，然后再合并起来。</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">diffWaysToCompute</span><span class=\"params\">(String expression)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> divideAndConquer(expression.toCharArray());<span class=\"comment\">//将字符串转换为字符数组</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; <span class=\"title function_\">divideAndConquer</span><span class=\"params\">(<span class=\"type\">char</span>[] expression)</span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//处理一个数字的情况也就是分治划分到最底层的时候</span></span><br><span class=\"line\">        <span class=\"comment\">//isOneNum函数用来判断当前的表达式是否为一个单独的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isOneNum(expression))&#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">//将该数字从char数组转换为一个int型数值</span></span><br><span class=\"line\">             <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class=\"line\">                 num = num*<span class=\"number\">10</span> +expression[i]-<span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//比如98，一开始num为9，下一个循环就是9*10+&#x27;8&#x27;-&#x27;0&#x27;即为98，这里注意下字符要中ASILL码转换</span></span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">             res.add(num);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isDigit(expression[i]))&#123;<span class=\"comment\">//扫描到有运算符的情况</span></span><br><span class=\"line\">                <span class=\"type\">char</span>[] left = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[i];<span class=\"comment\">//生成左边表达式</span></span><br><span class=\"line\">                <span class=\"type\">char</span>[] right = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[expression.length-i-<span class=\"number\">1</span>];<span class=\"comment\">//生成右边表达式</span></span><br><span class=\"line\">                <span class=\"comment\">//切分左右分治所使用的表达式数组</span></span><br><span class=\"line\">                System.arraycopy(expression,<span class=\"number\">0</span>,left,<span class=\"number\">0</span>,i);<span class=\"comment\">//复制左边数组，注意是不含i这个位置的运算符的，具体看下面的例子你就知道，i代表长度</span></span><br><span class=\"line\">                System.arraycopy(expression,i+<span class=\"number\">1</span>,right,<span class=\"number\">0</span>,expression.length-i-<span class=\"number\">1</span>);<span class=\"comment\">//复制右边数组</span></span><br><span class=\"line\">                <span class=\"comment\">//对左边的表达式在进行一次同样的操作  这里是体现分治的思想吧？</span></span><br><span class=\"line\">                List&lt;Integer&gt; leftList = divideAndConquer(left);</span><br><span class=\"line\">                <span class=\"comment\">//对右边的表达式在进行一次同样的操作</span></span><br><span class=\"line\">                List&lt;Integer&gt; rightList = divideAndConquer(right);</span><br><span class=\"line\">                <span class=\"comment\">//计算左右两个表达式在当前用来切分的运算符进行运算后得到的所有可能的结果</span></span><br><span class=\"line\">                List&lt;Integer&gt; tempRes = calculate(leftList,rightList,expression[i]);</span><br><span class=\"line\">                <span class=\"comment\">//将这些结果加入最后的列表中作为这一层分治的最终结果</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (Integer num:tempRes)&#123;</span><br><span class=\"line\">                    res.add(num);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;<span class=\"comment\">//这里容易漏掉</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//calculate函数用来对两个列表的数值逐个进行计算</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;Integer&gt; <span class=\"title function_\">calculate</span><span class=\"params\">(List&lt;Integer&gt; listOne,List&lt;Integer&gt; listTwo,<span class=\"type\">char</span> operator)</span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;listOne.size();i++)&#123;<span class=\"comment\">//一开始不明白这里为什么有两个循环，请看下面的例子就知道了</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j=<span class=\"number\">0</span>;j&lt;listTwo.size();j++)&#123;</span><br><span class=\"line\">                res.add(calculateTwoNums(listOne.get(i),listTwo.get(j),operator));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//简单的计算函数</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Integer <span class=\"title function_\">calculateTwoNums</span><span class=\"params\">(<span class=\"type\">int</span> num1,<span class=\"type\">int</span> num2,<span class=\"type\">char</span> operator)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(operator) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;+&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num1+num2;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;-&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num1-num2;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> num1*num2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//判断是否当前表达式是否为一个数字</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isOneNum</span><span class=\"params\">(<span class=\"type\">char</span>[] expression)</span>&#123;<span class=\"comment\">//把表达式都扫描一遍</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!Character.isDigit(expression[i]))<span class=\"comment\">//只要发现有一个不是数字，就返回false，</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//如果扫描完全部都是数字，就返回true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">System.arraycopy（）是一种本地静态方法，用于将元素从源数组复制到目标数组。</span><br><span class=\"line\">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span><br><span class=\"line\">Object src : 原数组</span><br><span class=\"line\">int srcPos : 从元数据的起始位置开始</span><br><span class=\"line\">Object dest : 目标数组</span><br><span class=\"line\">int destPos : 目标数组的开始起始位置</span><br><span class=\"line\">int length : 要copy的数组的长度</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">以&quot;2*3-4*5&quot;为例子，看看是如何计算的</span><br><span class=\"line\"></span><br><span class=\"line\">第一轮情况</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2    3-4*5</span><br><span class=\"line\">left and right</span><br><span class=\"line\">3    4*5</span><br><span class=\"line\">left and right</span><br><span class=\"line\">4    5</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[4]    *    [5]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[3]    -    [20]</span><br><span class=\"line\"></span><br><span class=\"line\">left and right</span><br><span class=\"line\">3-4    5</span><br><span class=\"line\">left and right</span><br><span class=\"line\">3    4</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[3]    -    [4]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[-1]    *    [5]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[2]    *    [-17, -5]  //也就是(3-4)*5和3-(4*5)，这也解释了为什么calculate为什么是两个循环。第一和第二个结果出来了</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">第二轮情况</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2*3    4*5</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2    3</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[2]    *    [3]</span><br><span class=\"line\"></span><br><span class=\"line\">left and right</span><br><span class=\"line\">4    5</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[4]    *    [5]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[6]    -    [20]   //第三个结果</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">第三轮情况</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2*3-4    5</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2    3-4</span><br><span class=\"line\">left and right</span><br><span class=\"line\">3    4</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[3]    -    [4]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[2]    *    [-1]</span><br><span class=\"line\"></span><br><span class=\"line\">left and right</span><br><span class=\"line\">2*3    4</span><br><span class=\"line\">left and right</span><br><span class=\"line\">2    3</span><br><span class=\"line\"></span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[2]    *    [3]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[6]    -    [4]</span><br><span class=\"line\">leftlist and rightlist</span><br><span class=\"line\">[-2, 2]    *    [5]  //第四和第五个结果</span><br><span class=\"line\"></span><br><span class=\"line\">答案为[-34, -10, -14, -10, 10]</span><br></pre></td></tr></table></figure>\n<h2 id=\"932\"><a href=\"#932\" class=\"headerlink\" title=\"932\"></a>932</h2><h2 id=\"312\"><a href=\"#312\" class=\"headerlink\" title=\"312\"></a>312</h2><h1 id=\"代码随想录\"><a href=\"#代码随想录\" class=\"headerlink\" title=\"代码随想录\"></a>代码随想录</h1><p><a href=\"https://programmercarl.com/\">代码随想录</a>正式开刷！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;Integer&gt; a = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">a.get(i)<span class=\"comment\">//获取第i个元素</span></span><br><span class=\"line\">a.size()</span><br><span class=\"line\">result.add(Arrays.asList(nums[i], nums[left], nums[right])) result是List&lt;List&lt;Integer&gt;&gt; 这样最后的结果类似于[[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]]，也就是里面的List&lt;Integer&gt;省略，这个出现在<span class=\"number\">15</span>,<span class=\"number\">18</span>题</span><br><span class=\"line\"></span><br><span class=\"line\">String s</span><br><span class=\"line\">s.charAt(i)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">sb.toString()</span><br><span class=\"line\"></span><br><span class=\"line\">Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">queue.offer(x)<span class=\"comment\">//添加x进去</span></span><br><span class=\"line\">queue.poll()<span class=\"comment\">//取出最后一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">map.put(key, value)</span><br><span class=\"line\">map.containsKey(key)<span class=\"comment\">//是否存在该元素</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><h3 id=\"704-二分查找-easy\"><a href=\"#704-二分查找-easy\" class=\"headerlink\" title=\"704 二分查找 easy\"></a>704 二分查找 easy</h3><p>前提是有序，以及没有重复的值，才可以用下面这个算法。<br>下面这个写法是左闭右闭区间，也就是target在这个区间内，所以必须要用小于等于。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">search</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt;= right) &#123; <span class=\"comment\">//这里要注意是小于等于，比如我们用[5] target=5来举例，l和r都是0，这样就不会进入循环了，所以必须要小于等于。</span></span><br><span class=\"line\">            <span class=\"type\">int</span>  <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + ((right - left) / <span class=\"number\">2</span>); <span class=\"comment\">//凡是取中间值，必须记住这个公式，如果直接(l+r)/2，可能会溢出。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] == target) <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &gt; target) &#123;</span><br><span class=\"line\">                right = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (nums[mid] &lt; target)&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"27-移除元素-easy\"><a href=\"#27-移除元素-easy\" class=\"headerlink\" title=\"27 移除元素 easy\"></a>27 移除元素 easy</h3><p>注意数组只能覆盖掉哦，所以用到双指针的思路。数组的元素是不能删的，只能覆盖！数组的元素是不能删的，只能覆盖！数组的元素是不能删的，只能覆盖！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个题先考虑如果刚好第一个元素就是目标元素，我们应该怎么操作，这时候fast还在第一格，所以不能替换，那么就是先到下一个元素，再替换</span></span><br><span class=\"line\"><span class=\"comment\">那么，所以if应该设置为如果不是这个target的时候再操作</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">removeElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[fast] != val) &#123;</span><br><span class=\"line\">                nums[slow] = nums[fast];</span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">大概思路就是有两个指针，一个快指针一个慢指针</span></span><br><span class=\"line\"><span class=\"comment\">一开始的slow和fast指针都是0，直到遇上val后，这时候fast会比slow多跳一格，也就是slow还是不变，因为我们看代码，只有不等时，slow才会加</span></span><br><span class=\"line\"><span class=\"comment\">那么等到下一次不为val后，我们fast指向的值，就覆盖到之前val的位置上（因为slow指着呢），那么最后slow的指针，也就是最终的长度啦</span></span><br><span class=\"line\"><span class=\"comment\">所以这个题不要来想着怎么去移除元素，而是覆盖元素，运用双指针</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"977-有序数组的平方-easy\"><a href=\"#977-有序数组的平方-easy\" class=\"headerlink\" title=\"977 有序数组的平方 easy\"></a>977 有序数组的平方 easy</h3><p>这题给的数组是非递减数组，有负数，如果用暴力算平方然后排序时间复杂度很高，所以没有意思，下面用的是双指针的办法。本题用while的话</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">首先我们要知道，这是非递减数组，也就是平方之后的最大值，要么是第一个，要么是最后一个，所以可以用双指针的想法去做。</span></span><br><span class=\"line\"><span class=\"comment\">i指向第一个，j指向最后一个，然后判断谁的平方大，大的那个就存到result的最后一个位置，也就是倒着存。</span></span><br><span class=\"line\"><span class=\"comment\">如果是i情况，操作完把i++</span></span><br><span class=\"line\"><span class=\"comment\">如果是j情况，操作完把j--</span></span><br><span class=\"line\"><span class=\"comment\">同时n都要进行相减</span></span><br><span class=\"line\"><span class=\"comment\">因为i和j要看情况要相减，所以在for循环的时候我们发现第三栏空出来没有写了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortedSquares(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;<span class=\"comment\">//别忘了数组最后一个的位置是n-1，而不是n</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>,j = n; i &lt;= j;) &#123;<span class=\"comment\">//用小于等于是因为，当他们i和j共同指向这个数后，继续循环对这个数进行操作，不然用小于的话，到了这个数就不进行操作了。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((nums[i] * nums[i]) &gt; (nums[j]*nums[j])) &#123;</span><br><span class=\"line\">                result[n--] = nums[i] * nums[i++];<span class=\"comment\">//注意前面一个不能i++，因为我们后面还要用到nums[i]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result[n--] = nums[j] * nums[j--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>while的写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] sortedSquares(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;<span class=\"comment\">//别忘了数组最后一个的位置是n-1，而不是n</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt;= j) &#123;<span class=\"comment\">//用小于等于是因为，当他们i和j共同指向这个数后，继续循环对这个数进行操作，不然用小于的话，到了这个数就不进行操作了。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((nums[i] * nums[i]) &gt; (nums[j]*nums[j])) &#123;</span><br><span class=\"line\">                result[n--] = nums[i] * nums[i++];<span class=\"comment\">//注意前面一个不能i++，因为我们后面还要用到nums[i]</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//这里不能再用条件判断，不然会超时，指不用再判断&lt;</span></span><br><span class=\"line\">                result[n--] = nums[j] * nums[j--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"209-长度最小的子数组-medium\"><a href=\"#209-长度最小的子数组-medium\" class=\"headerlink\" title=\"209 长度最小的子数组 medium\"></a>209 长度最小的子数组 medium</h3><p>注意是最小哦，举个例子，比如target&#x3D;7，nums&#x3D; [2,3,1,2,4,3],那么连续子数组[1,2,4]和[4,3]都符合，但是要取最小那个，也就是长度为2。本题有点类似于双指针，但是卡哥表达是滑动窗口。还有需要注意，题目是找出<strong>大于等于</strong>target的，一开始还看成等于的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">具体是这么理解的，两个指针，右指针一直走，这时候sum也在累加，一旦sum大于或者出现等于的情况，就把left右移动一位，同时别忘记删除原来的那个left的数字</span></span><br><span class=\"line\"><span class=\"comment\">可以用暴力，但是时间复杂度高，下面这个虽然有while，卡哥解释：不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, <span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class=\"line\">            sum += nums[right];</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (sum &gt;= target) &#123;<span class=\"comment\">//题目要求，加个while是为了寻找更小的长度</span></span><br><span class=\"line\">                result = Math.min(result, right - left + <span class=\"number\">1</span>);<span class=\"comment\">//统计长度就是r-l+1</span></span><br><span class=\"line\">                sum -= nums[left++];<span class=\"comment\">//删除原来的left位置上的数字以及left++，如果移动一位还是大于，那就继续while移动，当然了，这时候right是不变的，因为我们还在for循环中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result == Integer.MAX_VALUE ? <span class=\"number\">0</span> : result;<span class=\"comment\">//如果result还是原来的max数，就说明找不到符合的条件，返回0，否则返回result</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"59-螺旋矩阵2-medium\"><a href=\"#59-螺旋矩阵2-medium\" class=\"headerlink\" title=\"59 螺旋矩阵2 medium\"></a>59 螺旋矩阵2 medium</h3><p>思路就是一圈圈循环，然后注意控制区间，本题答案是左闭右开写法，这题没涉及什么算法，就是繁琐。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] generateMatrix(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">loop</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//循环的圈数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> i,j;<span class=\"comment\">//注意必须设置为全局变量</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;<span class=\"comment\">//填入的数字，从1开始，一直到n*n</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n][n];</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop++ &lt; n / <span class=\"number\">2</span>) &#123;<span class=\"comment\">//这里解释下为什么圈是是n/2，我们想想一个圈的内圈，会上下左右都少一格，也就是x少2，y少2，比如6，第一圈是x是6，第二圈就是4，第三圈就是2，这里代表元素个数，那么用6/2就是总圈数，遇到奇数下面会处理。</span></span><br><span class=\"line\">            <span class=\"comment\">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class=\"line\">            <span class=\"comment\">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class=\"line\">            <span class=\"comment\">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (j = start; j &lt; n - loop; j++) &#123;<span class=\"comment\">//左开右闭，所以用n-loop来控制，可以看下面卡哥的图就清楚了</span></span><br><span class=\"line\">                res[start][j] = count++;<span class=\"comment\">//模拟上侧从左到右</span></span><br><span class=\"line\">            &#125;<span class=\"comment\">//只有这里是start，下面都是res[i][j]</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = start; i &lt; n - loop; i++) &#123;<span class=\"comment\">//模拟右侧从上到下</span></span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//以3为例，第一圈循环到这里是时候,i和j都变成2了，loop是1，j进入循环内，j首先还是2</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//这里为什么要大于等于loop，我是这么想的，这时候处理右下角的数字，以4为例子，右下角坐标是(3,3)，目前是第一圈，左下角是(3,0),截止点是1(loop),第二圈的左下角是(2,1)，截止点是2(loop)，所以可以大于等于loop，循环完之后就不满足这个条件，就退出去了</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;j &gt;= loop; j--) &#123;<span class=\"comment\">// 模拟下侧从右到左</span></span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &gt;= loop; i--) &#123;<span class=\"comment\">// 模拟左侧从下到上</span></span><br><span class=\"line\">                res[i][j] = count++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            start++;<span class=\"comment\">//别忘了循环完一圈后，开始下一圈了，所以要改变起始点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//n为奇数的时候，最后会剩下一格，在while中是没有处理的</span></span><br><span class=\"line\">            res[start][start] = count;<span class=\"comment\">//当然了，也可以为n*n</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>卡哥这个图很生动<br><img src=\"/images/leetcode-java/c-59.png\"></p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>务必熟悉定义链表</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\">    ListNode() &#123;&#125;;<span class=\"comment\">//&#123;&#125;容易漏</span></span><br><span class=\"line\">    ListNode(<span class=\"type\">int</span> val, ListNode next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">一些总结：</span><br><span class=\"line\">cur一般指向head，pre一般指向<span class=\"literal\">null</span>，如果有虚拟节点，就指向dump，这样保证了head（cur的指向）之前是pre</span><br><span class=\"line\"><span class=\"number\">203</span>：移除元素需要设置虚拟节点，pre和cur，循环的时候<span class=\"keyword\">while</span>（cur！=<span class=\"literal\">null</span>），那么为什么不是cur.next！=<span class=\"literal\">null</span>呢，因为如果你现在到最后一个元素，next必然是空，那么这时候就不会循环，但是如果最后一个元素就是目标val，需要进行操作，而不会进入到循环中</span><br><span class=\"line\">另外，如果一直遇到val，pre不变位置，而是一直指向cur的next，然后cur一直移动</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">206</span>:对应反转链表，虚拟节点不好操作，因为你最后要反的，但是pre和cur是要的，pre的话这里没有dump，就先设置为<span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"number\">19</span>:删除倒数第n个节点，虚拟节点的设置，以及fast和slow需要初试化在dump上而不是head上，因为可能[<span class=\"number\">1</span>]<span class=\"number\">1</span>，如果这样的话，一开始在节点上就不能操作，所以都设置在head的前面</span><br><span class=\"line\">另外，循环是用fast.next!=<span class=\"literal\">null</span>，如果是这样，fast最后是在最后一个元素上，如果直接用fast，则会在<span class=\"literal\">null</span>元素上。然后slow会在需要删除节点的前面一个位置，最后进行改变指针即可</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"203-移除链表元素-easy\"><a href=\"#203-移除链表元素-easy\" class=\"headerlink\" title=\"203 移除链表元素 easy\"></a>203 移除链表元素 easy</h3><p>这个是带虚拟头节点的，方便操作,然后设置一个pre和cur指针，如果cur遇到val，就修改pre的next指向，否则pre指向cur，然后cur一直移动。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> pre.next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.val == val) &#123;</span><br><span class=\"line\">                pre.next = cur.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pre = cur;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意下如何声明链表，因为可能是ACM模式，本解答是在原链表上进行移除，也就是不带虚拟头节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;//下一个节点</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;// 节点的构造函数(无参)</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;// 节点的构造函数(有一个参数)</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;// 节点的构造函数(有两个参数)</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeElements</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (head != <span class=\"literal\">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class=\"line\">            head = head.next;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//当头节点就是目标时，直接把head移动到下一个即可，用while是因为可能遇到[7,7,7] val=7这种情况，就需要一直移动</span></span><br><span class=\"line\"></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//当head为空的时，就直接返回null，但是这一句不能写在上面一句之前，比如还是上面那个例子，while后会变成空，然后到了这句就直接返回null，但是如果先写这一句，while执行完后却不会返回null</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//当val不是头节点的时候</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> head;<span class=\"comment\">//声明pre和cur</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> pre.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.val == val) &#123;<span class=\"comment\">//当cur为目标时候，把pre的next直接指向cur的next即可</span></span><br><span class=\"line\">                pre.next = cur.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                pre = cur;<span class=\"comment\">//不是目标的时候，继续走下一个元素</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"707-设计链表-medium\"><a href=\"#707-设计链表-medium\" class=\"headerlink\" title=\"707 设计链表 medium\"></a>707 设计链表 medium</h3><p>本答案的链表设计是有虚拟头节点的，这样是为了所有节点可以用一样的操作，不然要分为头节点和其他节点，使用单链表，这个题比较容易漏掉size的数值变化增长。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里的index起始是0，，也就是我们插入的节点位置就是他的下标位置，所以最大的index是size-1</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ListNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\">    ListNode() &#123;&#125;;</span><br><span class=\"line\">    ListNode(<span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ListNode(<span class=\"type\">int</span> val, ListNode next) &#123;<span class=\"comment\">//题目不需要这个也行，但是我为了练习多写的</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\">    ListNode head;<span class=\"comment\">//务必注意head是全局变量哦</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyLinkedList</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        head = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;<span class=\"comment\">//获取index必须要在size的范围内</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">currentNode</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= index; i++) &#123;<span class=\"comment\">//因为我们有一个虚拟头节点，所以要&lt;=index，只有getindex的情况才这样哦，add和delete都不需要</span></span><br><span class=\"line\">            currentNode = currentNode.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode.val;<span class=\"comment\">//返回的值哦</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addAtHead</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        addAtIndex(<span class=\"number\">0</span>, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addAtTail</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        addAtIndex(size, val);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//本题的要求，输入负数则在头部插入</span></span><br><span class=\"line\">            index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size ++;<span class=\"comment\">//这个比较容易漏</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pred</span> <span class=\"operator\">=</span> head;<span class=\"comment\">//找到要插入节点的前驱</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">toAdd</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(val);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//先让新增的点连接后面，再连接前面。</span></span><br><span class=\"line\">        toAdd.next = pred.next;<span class=\"comment\">//不能和下面一句顺序反过来，不然toAdd的next就断掉了</span></span><br><span class=\"line\">        pred.next = toAdd;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">deleteAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        size--;<span class=\"comment\">//这个比较容易漏</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pred</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; index; i++) &#123;</span><br><span class=\"line\">            pred = pred.next;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        pred.next = pred.next.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_1 = obj.get(index);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.addAtHead(val);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.addAtTail(val);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.addAtIndex(index,val);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.deleteAtIndex(index);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这里之前有个疑问，为什么每次操作链表都要先声明一个listnode？</span><br><span class=\"line\"><span class=\"type\">ListNode</span> <span class=\"variable\">currentNode</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">这样操作的话是cur在动，而head没有动</span><br><span class=\"line\">假设你直接用head操作，这样你第一次getindex是可以的，但是第二次getindex的话，head的位置早就变了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"206-反转链表-easy\"><a href=\"#206-反转链表-easy\" class=\"headerlink\" title=\"206 反转链表 easy\"></a>206 反转链表 easy</h3><p>直接在链表的基础上进行反转，也就是改变next的指向，让其反过来，思路就是设置一个pre和cur，然后用temp保存cur的next，再把cur反转到pre。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">reverseList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//需要有个temp来保存cur的next指针</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//如果cur.next ！= null 会少了设置最后一个节点</span></span><br><span class=\"line\">            temp = cur.next;<span class=\"comment\">//先保存</span></span><br><span class=\"line\">            cur.next = pre;<span class=\"comment\">//指向调转</span></span><br><span class=\"line\">            pre = cur;<span class=\"comment\">//继续移动</span></span><br><span class=\"line\">            cur = temp;<span class=\"comment\">//继续移动</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"24-两两交换链表中的节点-meduim\"><a href=\"#24-两两交换链表中的节点-meduim\" class=\"headerlink\" title=\"24 两两交换链表中的节点 meduim\"></a>24 两两交换链表中的节点 meduim</h3><p>这个题用了虚拟节点，必须要画图，这样才好理解，定义pre和cur，以两个为一组操作，然后先保存下一组的第一个数，接着操作第一组，改变指针指向。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">swapPairs</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span> &amp;&amp; cur.next != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//保证有两个节点</span></span><br><span class=\"line\">            temp = cur.next.next;</span><br><span class=\"line\">            pre.next = cur.next;</span><br><span class=\"line\">            pre.next.next = cur;</span><br><span class=\"line\">            cur.next = temp;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/24.jpg\"><br>和上一个解答的区别是，这个直接用head代替cur，但是一般我们都是用一个新的cur来写，所以我感觉上面一个风格更适合我。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">swapPairs</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (pre.next != <span class=\"literal\">null</span> &amp;&amp; pre.next.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">ListNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> head.next.next;<span class=\"comment\">//先保存一下节点</span></span><br><span class=\"line\">            pre.next = head.next;<span class=\"comment\">//对应步骤一</span></span><br><span class=\"line\">            pre.next.next = head;<span class=\"comment\">//对应步骤二</span></span><br><span class=\"line\">            head.next = temp;<span class=\"comment\">//对应步骤三</span></span><br><span class=\"line\">            pre = head;<span class=\"comment\">//移动一位</span></span><br><span class=\"line\">            head = head.next;<span class=\"comment\">//移动一位</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;<span class=\"comment\">//注意dump是虚拟节点，所以是dump的next</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/c-24.png\"></p>\n<h3 id=\"19-删除链表的倒数第-N-个结点-medium\"><a href=\"#19-删除链表的倒数第-N-个结点-medium\" class=\"headerlink\" title=\"19 删除链表的倒数第 N 个结点 medium\"></a>19 删除链表的倒数第 N 个结点 medium</h3><p>这个题一开始想不通怎么去处理倒数这个条件。这就用到了双指针啦，也就是先让fast先跑n步（卡哥说n+1但是我计算后觉得还是n），然后slow和fast同时跑，直到fast移动到末尾（是null哦，不是最后一个元素，也就是最后一个元素的下一个），这时候slow的指向就是待删除的元素，那么在跑的时候，我们再定义一个pre，就可以删除slow元素了。<br>第二次做这个题意识到，这个必须要用一个虚拟节点，不然很难处理[1]1这个情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\"></span><br><span class=\"line\">         </span><br><span class=\"line\">         </span><br><span class=\"line\">        <span class=\"comment\">/*for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            fast = fast.next;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;*/</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//上面两种写法都可以</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;<span class=\"comment\">//用于保存slow的前面一个元素，方便删除</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            pre = slow;<span class=\"comment\">//这个必须写第一个顺序，不能写在后面。</span></span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = slow.next;<span class=\"comment\">//slow指向的元素就是我们需要删除的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast.next != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//和上面题解的区别</span></span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        slow.next = slow.next.next;<span class=\"comment\">//和上面题解的区别</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"面试题-02-07-链表相交-easy-同160题\"><a href=\"#面试题-02-07-链表相交-easy-同160题\" class=\"headerlink\" title=\"面试题 02.07. 链表相交 easy 同160题\"></a>面试题 02.07. 链表相交 easy 同160题</h3><p><a href=\"https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/\">题目链接</a>，这个题需要注意交点不是数值相等，而是指针相等。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">总体的思路就是定义两个cur，首先是计算他们的长度，然后把长的一个链表放前面，如curA，然后把他们尾部对齐，接着寻找相同的指针即可。</span></span><br><span class=\"line\"><span class=\"comment\">需要注意的是，计算完长度后，请马上让cur重新指向头。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">curA</span> <span class=\"operator\">=</span> headA;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">curB</span> <span class=\"operator\">=</span> headB;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">lenA</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, lenB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            curA = curA.next;</span><br><span class=\"line\">            lenA++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curB != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            curB = curB.next;</span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curA = headA;</span><br><span class=\"line\">        curB = headB;<span class=\"comment\">//这里很关键，计算完长度请马上指向头</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//让curA保持为最长那个，这样方便操作，所以如果B的更长，那就交换一下</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lenB &gt; lenA) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> lenA;</span><br><span class=\"line\">            lenA = lenB;</span><br><span class=\"line\">            lenB = temp;</span><br><span class=\"line\">            <span class=\"type\">ListNode</span> <span class=\"variable\">tem</span> <span class=\"operator\">=</span> curA;<span class=\"comment\">//不能重复用temp</span></span><br><span class=\"line\">            curA = curB;</span><br><span class=\"line\">            curB = tem; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//这个操作的目的是，让curA移动到和curB对齐的地方</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">gap</span> <span class=\"operator\">=</span> lenA - lenB;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gap-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            curA = curA.next;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curA == curB) &#123;<span class=\"comment\">//这里不能写成curA.val == curB.val，但是可以通过不少例子，下面举一个例子说明为什么不可以</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA.next;</span><br><span class=\"line\">            curB = curB.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//这个不能忘了</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">8</span><br><span class=\"line\">[4,1,8,4,5]</span><br><span class=\"line\">[5,0,1,8,4,5]</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\"></span><br><span class=\"line\">上面的输入，对齐后是</span><br><span class=\"line\">[5,0,1,8,4,5]</span><br><span class=\"line\">  [4,1,8,4,5]</span><br><span class=\"line\">根据输入，完美可以知道应该是返回8这个节点，但是如果我们用了curA.val == curB.val，则会返回1，这个是错误的</span><br></pre></td></tr></table></figure>\n<p>卡哥的图，主要理解curA移动到和curB对齐的地方这个操作<br><img src=\"/images/leetcode-java/c-02.07.png\"></p>\n<h3 id=\"环形链表\"><a href=\"#环形链表\" class=\"headerlink\" title=\"环形链表\"></a>环形链表</h3><h4 id=\"141-环形链表-easy\"><a href=\"#141-环形链表-easy\" class=\"headerlink\" title=\"141 环形链表 easy\"></a>141 环形链表 easy</h4><p>判断一个链表是否有环，很简单，设置快慢指针，如果最终快指针追上慢指针，说明有环。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">null</span> &amp;&amp; fast.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (slow == fast) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"142-环形链表II-medium\"><a href=\"#142-环形链表II-medium\" class=\"headerlink\" title=\"142 环形链表II medium\"></a>142 环形链表II medium</h4><p>之前做过又忘记！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">detectCycle</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">null</span> &amp;&amp; fast.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == slow) &#123;</span><br><span class=\"line\">                <span class=\"type\">ListNode</span> <span class=\"variable\">index1</span> <span class=\"operator\">=</span> fast;</span><br><span class=\"line\">                <span class=\"type\">ListNode</span> <span class=\"variable\">index2</span> <span class=\"operator\">=</span> head;<span class=\"comment\">//第二次写这个题，居然写成slow</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (index1 != index2) &#123;</span><br><span class=\"line\">                    index1 = index1.next;</span><br><span class=\"line\">                    index2 = index2.next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> index1;<span class=\"comment\">//也可以返回2</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//第二次做这个题忘记返回null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\">卡哥的详细解释</a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">卡哥的答案确实比较详细，这里简单总结下</span><br><span class=\"line\">一个快指针，一个慢指针，快指针走两步，慢指针走一步。</span><br><span class=\"line\">这样子，其实快指针是在慢慢一步步靠近慢指针，如果有环的话，一定会相遇。</span><br><span class=\"line\">当他们相遇的时候，这时候我们重新声明两个指针，一个指向fast，一个指向头，然后他们一步步走，最终相遇的时候，就是入口，这里面涉及一些公式推导，去卡哥网站上看吧。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这里解释下卡哥这句话</span><br><span class=\"line\">那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。</span><br><span class=\"line\">因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n</span><br><span class=\"line\"></span><br><span class=\"line\">(n + n) / 2 = n ，k &lt; n，所以(k + n) / 2 一定小于n。</span><br><span class=\"line\">也就是说你的fast已经走到了环入口三，而slow还没走到环入口三，并且一开始fast在环入口2的前面，也就是他们已经相遇过了。</span><br></pre></td></tr></table></figure>\n<h2 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h2><h3 id=\"242-有效的字母异位词-easy\"><a href=\"#242-有效的字母异位词-easy\" class=\"headerlink\" title=\"242 有效的字母异位词 easy\"></a>242 有效的字母异位词 easy</h3><p>若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">用一个26长度是int数组来记录s的字母个数</span></span><br><span class=\"line\"><span class=\"comment\">然后用t的字母减去相应个数</span></span><br><span class=\"line\"><span class=\"comment\">最后如果发现record数组都是0，那证明就是异味词，否则不是</span></span><br><span class=\"line\"><span class=\"comment\">String中用s.toCharArray</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isAnagram</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] record = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c:s.toCharArray()) &#123;</span><br><span class=\"line\">            record[c - <span class=\"string\">&#x27;a&#x27;</span>] += <span class=\"number\">1</span>;<span class=\"comment\">//toCharArray将字符串转换为字符数组，比如单独输出a 然后a - &#x27;a&#x27; = 0,那么在0的位置上加1，b的话就在1的位置上加1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c:t.toCharArray()) &#123;</span><br><span class=\"line\">            record[c - <span class=\"string\">&#x27;a&#x27;</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/*for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            if (record[i] != 0 ) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                return false;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//下面这个写法更简洁</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : record) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>349 两个数组的交集 easy<br>set可以去重，通过两个set就可以找到交集。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] intersection(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set1 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Integer&gt; set2 = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums1) &#123;</span><br><span class=\"line\">            set1.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums2) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (set1.contains(i)) &#123;</span><br><span class=\"line\">                set2.add(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[set2.size()];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : set2) &#123;<span class=\"comment\">//把结果转成数组</span></span><br><span class=\"line\">            result[index++] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>202 快乐数 easy<br>这个题其实就是按照题目思路去走即可，需要知道如何拆出数字来获取，比如个位数用mod，然后其他位置依次循环除以10。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isHappy</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();<span class=\"comment\">//这个题的求和过程中可能会有数字重复出现，所以要用hash的set去重</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n != <span class=\"number\">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class=\"line\">            result.add(n);</span><br><span class=\"line\">            n = getnextnum(n);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n == <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"title function_\">getnextnum</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;<span class=\"comment\">//比如19</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> n % <span class=\"number\">10</span>;<span class=\"comment\">//先获得9</span></span><br><span class=\"line\">            sum += temp * temp;<span class=\"comment\">//81</span></span><br><span class=\"line\">            n = n / <span class=\"number\">10</span>;<span class=\"comment\">//然后获得1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-两数之和-easy\"><a href=\"#1-两数之和-easy\" class=\"headerlink\" title=\"1 两数之和 easy\"></a>1 两数之和 easy</h3><p>一开始就行想着暴力解法，虽然过了，用了两个循环，但是看了卡哥的解释还是太年轻了,这里有个细节，一定要先判断，然后再put元素进去，否则遇到[3,3] targer&#x3D;6 这种情况，res答案就会变成[1,1]，而不是[0,1]</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这里只用了一个循环就可以完成这个任务，用到了map</span></span><br><span class=\"line\"><span class=\"comment\">map&lt;key,value&gt;</span></span><br><span class=\"line\"><span class=\"comment\">放到这个题就是key存nums[i]，value存位置信息。</span></span><br><span class=\"line\"><span class=\"comment\">一开始是存前面的数和位置，到了后面target相减后，如果在map中有匹配的数，那就说明已经找到符合题目的数了。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> target -nums[i];<span class=\"comment\">//相减后的数</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(temp)) &#123;<span class=\"comment\">//如果相减后的数在map中，就说明成功了</span></span><br><span class=\"line\">                result[<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">                result[<span class=\"number\">1</span>] = map.get(temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            map.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"454-四数相加2-medium\"><a href=\"#454-四数相加2-medium\" class=\"headerlink\" title=\"454 四数相加2 medium\"></a>454 四数相加2 medium</h3><p>第一次看到这么巧妙的做法，看来还是练题太少了。这个题不用考虑重复的四个元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个题用到了map来保存前两个数的和以及出现的次数，然后后面两个数用0去相减他们的和得到一个值，</span></span><br><span class=\"line\"><span class=\"comment\">如果这个值在map中存在，那就提取次数，最后累加次数就是答案。</span></span><br><span class=\"line\"><span class=\"comment\">这里一开始不明白为什么用map来保留次数，比如前两个数组是[1,1],[1,1]，那么map中就是(2:4)，也就是和为2的有4个，至于是什么组合我们不用管</span></span><br><span class=\"line\"><span class=\"comment\">因为题目只需要知道最后有多少次</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fourSumCount</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span>[] nums3, <span class=\"type\">int</span>[] nums4)</span> &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i :nums1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j : nums2) &#123;</span><br><span class=\"line\">                temp = i + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(temp)) &#123;</span><br><span class=\"line\">                    map.put(temp, map.get(temp) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    map.put(temp, <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j : nums4) &#123;</span><br><span class=\"line\">                temp = i + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(<span class=\"number\">0</span> - temp)) &#123;</span><br><span class=\"line\">                    res += map.get(<span class=\"number\">0</span> - temp);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让语句写更少一些，主要在map的修改上。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fourSumCount</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span>[] nums3, <span class=\"type\">int</span>[] nums4)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums1) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j : nums2) &#123;</span><br><span class=\"line\">                temp = i + j;</span><br><span class=\"line\">                map.put(temp, map.getOrDefault(temp, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums3) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j : nums4) &#123;</span><br><span class=\"line\">                temp = i + j;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (map.containsKey(<span class=\"number\">0</span> - temp)) &#123;</span><br><span class=\"line\">                    res += map.get(<span class=\"number\">0</span> - temp);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"383-赎金信-easy\"><a href=\"#383-赎金信-easy\" class=\"headerlink\" title=\"383 赎金信 easy\"></a>383 赎金信 easy</h3><p>一开始想得挺复杂，看到卡哥提点都是小写字母，可以用一个26大小的char数组保存这句话，就写出来了，没想到和卡哥答案一样，嘻嘻。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canConstruct</span><span class=\"params\">(String ransomNote, String magazine)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> i : magazine.toCharArray()) &#123;<span class=\"comment\">//注意题目是后者的个数要覆盖前者的个数哦，所以先提取magazine</span></span><br><span class=\"line\">            result[i - <span class=\"string\">&#x27;a&#x27;</span>] += <span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> i : ransomNote.toCharArray()) &#123;</span><br><span class=\"line\">            result[i - <span class=\"string\">&#x27;a&#x27;</span>] -= <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : result) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"15-三数之和-medium-非哈希法\"><a href=\"#15-三数之和-medium-非哈希法\" class=\"headerlink\" title=\"15 三数之和 medium(非哈希法)\"></a>15 三数之和 medium(非哈希法)</h3><p>哈希法太复杂，这里是双指针，而且和454的区别是，454是4个数组，这个题是一个数组，而且不能是重复的三元组，这个题要多看看，可能第二遍又忘记了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个题用双指针更加方便</span></span><br><span class=\"line\"><span class=\"comment\">不过一开始是指向i,left,right</span></span><br><span class=\"line\"><span class=\"comment\">left的初始化是i+1</span></span><br><span class=\"line\"><span class=\"comment\">这里有个关键是，必须先进行排序。</span></span><br><span class=\"line\"><span class=\"comment\">学习Arrays.asList</span></span><br><span class=\"line\"><span class=\"comment\">记不住就</span></span><br><span class=\"line\"><span class=\"comment\">                    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class=\"line\"><span class=\"comment\">                    res.add(nums[i]);</span></span><br><span class=\"line\"><span class=\"comment\">                    res.add(nums[left]);</span></span><br><span class=\"line\"><span class=\"comment\">                    res.add(nums[right]);</span></span><br><span class=\"line\"><span class=\"comment\">                    result.add(res);</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">threeSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//因为已经排序了，如果第一个就大于0，那后面就不可能和为0了</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> result;<span class=\"comment\">//这个题我试了下，用nums[0]也可以，不过要放在for内，如果在sort下面写nums[0] &gt; 0判断，可能不行，因为用例可以是空的[]，这样就没有nums[0]。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123;<span class=\"comment\">//加个大于0，是因为怕一开始的情况，0-1=-1就不成立啦</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"comment\">//去重操作，不能直接写成nums[i] == nums[i + 1]，因为会漏掉比如-1,-1,2这种情况，也就是一开始就筛掉了</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (right &gt; left) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> nums[i] + nums[left] + nums[right];</span><br><span class=\"line\">                <span class=\"comment\">//不可以在这里写去重条件，也就是最下面else那个，如果这里写的话，万一用例是0,0,0，那么就直接筛掉了，而在下面写，是为了保证已经添加了元祖，再进行去重。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    left++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));<span class=\"comment\">//添加元祖，然后再去重</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//去重条件，注意righ-1，下面是left + 1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) right--;</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) left++;   <span class=\"comment\">//注意这里是left+1            </span></span><br><span class=\"line\">                    right--;</span><br><span class=\"line\">                    left++;</span><br><span class=\"line\"></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"18-四数之和-medium\"><a href=\"#18-四数之和-medium\" class=\"headerlink\" title=\"18 四数之和 medium\"></a>18 四数之和 medium</h3><p>和上一题的区别是，这个是四元组，而且和不是为0，是任意值target。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">具体的区别有，首先不再判断第一个数大于0就continue，因为这个题是任意值。</span></span><br><span class=\"line\"><span class=\"comment\">只需要多加一个for循环，再多一个j，同理如果是5元组，6元组也如此。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">fourSum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i - <span class=\"number\">1</span>] == nums[i]) &#123;<span class=\"comment\">//i要去重</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; i + <span class=\"number\">1</span> &amp;&amp; nums[j - <span class=\"number\">1</span>] == nums[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;<span class=\"comment\">//多加一个循环，同时这里需要去重，j也要去重。</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> j + <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (right &gt; left) &#123;</span><br><span class=\"line\">                    <span class=\"type\">long</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> (<span class=\"type\">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<span class=\"comment\">//因为这个题是任意值，所以用例有个越界的，转成long。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (sum &gt; target) &#123;</span><br><span class=\"line\">                        right--;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (sum &lt; target) &#123;</span><br><span class=\"line\">                        left++;</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class=\"line\">                        </span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class=\"number\">1</span>]) right--;</span><br><span class=\"line\">                        <span class=\"keyword\">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class=\"number\">1</span>]) left++;</span><br><span class=\"line\"></span><br><span class=\"line\">                        left++;</span><br><span class=\"line\">                        right--;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><h3 id=\"344-反转字符串-easy\"><a href=\"#344-反转字符串-easy\" class=\"headerlink\" title=\"344 反转字符串 easy\"></a>344 反转字符串 easy</h3><p>简简单单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>[] s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> temp;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length / <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            temp = s[i];</span><br><span class=\"line\">            s[i] = s[s.length - <span class=\"number\">1</span> -i];</span><br><span class=\"line\">            s[s.length - <span class=\"number\">1</span> - i] = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一样的效果，只是一个for，一个是用while。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverseString</span><span class=\"params\">(<span class=\"type\">char</span>[] s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> temp;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, right = s.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            temp = s[left];</span><br><span class=\"line\">            s[left] = s[right];</span><br><span class=\"line\">            s[right] = temp;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"541-反转字符串2-easy\"><a href=\"#541-反转字符串2-easy\" class=\"headerlink\" title=\"541 反转字符串2 easy\"></a>541 反转字符串2 easy</h3><p>比较繁琐，需要定义判断多种情况。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">每2k长度进行一次操作，也就是固定一段去处理字符串。</span></span><br><span class=\"line\"><span class=\"comment\">这里题目要求，剩余长度大于少于k，则全部反转，剩余长度小于2k，则反转前k个，所以可以i+k去处理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseStr</span><span class=\"params\">(String s, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">char</span>[] arr = s.toCharArray();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i += k * <span class=\"number\">2</span>) &#123;<span class=\"comment\">//每隔2k来处理，然后找到起点</span></span><br><span class=\"line\">            reverse(arr, i, Math.min(i + k, n) - <span class=\"number\">1</span>);<span class=\"comment\">//这里用min是怕越界，如果直接用if判断i+k &lt; n又会漏了一些情况，秒！</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">reverse</span><span class=\"params\">(<span class=\"type\">char</span>[] arr, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; right) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> arr[left];</span><br><span class=\"line\">            arr[left] = arr[right];</span><br><span class=\"line\">            arr[right] = temp;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;            </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"剑指-Offer-05-替换空格-easy\"><a href=\"#剑指-Offer-05-替换空格-easy\" class=\"headerlink\" title=\"剑指 Offer 05. 替换空格 easy\"></a>剑指 Offer 05. 替换空格 easy</h3><p><a href=\"https://leetcode.cn/problems/ti-huan-kong-ge-lcof/\">题目链接</a>，一开始想法的替换空格，但是忘记一个事，%20是三个字符，所以要申请空间，干脆用SrtingBuilder。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">其实return s.replace(&quot; &quot;,&quot;%20&quot;);即可，但是这是算法题哦</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">replaceSpace</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//第一次用StringBuilder，最后要转成String，也就是直接复制原来s到StringBuilder中</span></span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;  s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">                sb.append(<span class=\"string\">&quot;%20&quot;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                sb.append(s.charAt(i));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"151-颠倒字符串中的单词-medium\"><a href=\"#151-颠倒字符串中的单词-medium\" class=\"headerlink\" title=\"151 颠倒字符串中的单词 medium\"></a>151 颠倒字符串中的单词 medium</h3><p>这个题比较多繁琐的东西，下面详细讲。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseWords</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> RemoveSpace(s);</span><br><span class=\"line\">        ReverseString(sb, <span class=\"number\">0</span>, sb.length() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        ReverseEachWords(sb);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> StringBuilder <span class=\"title function_\">RemoveSpace</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, end = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.charAt(start) == <span class=\"string\">&#x27; &#x27;</span>) start++;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (s.charAt(end) == <span class=\"string\">&#x27; &#x27;</span>) end--;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt;= end) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> s.charAt(start);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c != <span class=\"string\">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class=\"number\">1</span>) != <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">                sb.append(c);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ReverseString</span><span class=\"params\">(StringBuilder sb, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; end) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> sb.charAt(start);</span><br><span class=\"line\">            sb.setCharAt(start, sb.charAt(end));</span><br><span class=\"line\">            sb.setCharAt(end, temp);</span><br><span class=\"line\">            start++;</span><br><span class=\"line\">            end--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ReverseEachWords</span><span class=\"params\">(StringBuilder sb)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> sb.length();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (start &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class=\"string\">&#x27; &#x27;</span>) &#123;</span><br><span class=\"line\">                end++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ReverseString(sb, start, end - <span class=\"number\">1</span>);</span><br><span class=\"line\">            start = end + <span class=\"number\">1</span>;</span><br><span class=\"line\">            end = start + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">总体思路是</span><br><span class=\"line\">1.去除多余的空格</span><br><span class=\"line\">比如[ the     sky   ]，去除后是[the sky]，要去掉多余的两边空格，以及中间只需要保留一个空格。</span><br><span class=\"line\">函数里面while (start &lt;= end)，这里有个等于号，如果没有的话，会漏掉最后一个字符，因为我们是用start去提取字符，自然start要到最后</span><br><span class=\"line\">重点看if (c != &#x27; &#x27; || sb.charAt(sb.length() - 1) != &#x27; &#x27;)</span><br><span class=\"line\">这句前面部分，是为了保证非空格元素添加进去，而后面则是为了去除两个单词之间多余的空格</span><br><span class=\"line\">举个例子[the  sky]，中间有两个空格，start为4的时候，为第一个空格，此时sb是the，如果看前面第一个条件，是不允许添加的，但是这个是或，后面那个条件sb提取出来的是e，所以，这时候位置4的空格可以添加进去，</span><br><span class=\"line\">这时候sb是[the ]，然后开始第五个位置，同样，前面第一个条件不通过，第二个条件也不通过，因为此时sb最后一个字符是空格，这样的话，两个单词之间，就可以做到保留一个空格</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">2.翻转字符串</span><br><span class=\"line\">这个没啥好说的，就是字面意思</span><br><span class=\"line\"></span><br><span class=\"line\">3.翻转单词</span><br><span class=\"line\">这个就有意思了，我们检测到空格位置，就说明检测完一个单词，然后再把这个单词放进翻转字符串，即可完成，这里别忘了，翻转字符串的end是位置，不是长度，</span><br><span class=\"line\">所以ReverseString(sb, start, end - 1);这个容易漏掉end-1</span><br></pre></td></tr></table></figure>\n<h3 id=\"剑指-Offer-58-II-左旋转字符串-easy\"><a href=\"#剑指-Offer-58-II-左旋转字符串-easy\" class=\"headerlink\" title=\"剑指 Offer 58 - II. 左旋转字符串 easy\"></a>剑指 Offer 58 - II. 左旋转字符串 easy</h3><p><a href=\"https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\">题目链接</a>，感觉卡哥写的还复杂。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//自己写的，感觉还行，后来看了下官方题解，居然一样！</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">reverseLeftWords</span><span class=\"params\">(String s, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            sb.append(s.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            sb.append(s.charAt(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"28-实现-strStr-easy-KMP\"><a href=\"#28-实现-strStr-easy-KMP\" class=\"headerlink\" title=\"28 实现 strStr() easy(KMP)\"></a>28 实现 strStr() easy(KMP)</h3><p>别看是easy题，这是KMP算法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">KMP算法的目的就是解决字符串匹配，其实挺神奇的，不过具体的数学原理是啥，有点懵，先把一些概念解释清楚</span><br><span class=\"line\">首先理解前缀和后缀，以及前缀表</span><br><span class=\"line\">以要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf这个为例子。</span><br><span class=\"line\">我们要构建模式串(needle)的前缀表。</span><br><span class=\"line\"><span class=\"number\">1.</span>前缀的理解，概念是指不包含最后一个字符的所有以第一个字符开头的连续子串</span><br><span class=\"line\">a</span><br><span class=\"line\">aa</span><br><span class=\"line\">aab</span><br><span class=\"line\">aaba</span><br><span class=\"line\">aabaa</span><br><span class=\"line\">上面五个都是前缀，不包含最后一个字符哦</span><br><span class=\"line\"><span class=\"number\">2.</span>后缀的理解，指不包含第一个字符的所有以最后一个字符结尾的连续子串。</span><br><span class=\"line\">f</span><br><span class=\"line\">af</span><br><span class=\"line\">aaf</span><br><span class=\"line\">baaf</span><br><span class=\"line\">abaaf</span><br><span class=\"line\">上面五个都是后缀，不包含第一个字符哦</span><br><span class=\"line\"><span class=\"number\">3.</span>前缀表，也就是最长相等前后缀（均用不减<span class=\"number\">1</span>的操作，有些KMP的next数组用减<span class=\"number\">1</span>）。</span><br><span class=\"line\">a <span class=\"number\">0</span></span><br><span class=\"line\">aa <span class=\"number\">1</span>  这里前缀a，后缀a，相等的长度就是<span class=\"number\">1</span></span><br><span class=\"line\">aab <span class=\"number\">0</span></span><br><span class=\"line\">aaba <span class=\"number\">1</span> 只有前缀a和后缀a相等</span><br><span class=\"line\">aabaa <span class=\"number\">2</span> 前缀aa和后缀aa相等</span><br><span class=\"line\">aabaaf <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">0</span>就是我们模式串的前缀表。</span><br><span class=\"line\"></span><br><span class=\"line\">再举一个例子asdfasdfasdf</span><br><span class=\"line\">next表是[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">前缀asdfasdf</span><br><span class=\"line\">后缀asdfasdf</span><br><span class=\"line\">也就是前缀和后缀是有重叠位置的时候</span><br><span class=\"line\">所以这里是强化下我们的概念，前缀是不包含最后一个字符，后缀是不包含第一个字符，所以他们即便是重叠的，都没关系，我们重点关注的是概念！</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">大致的解题思路是</span><br><span class=\"line\"><span class=\"number\">1.</span>首先构建好前缀表</span><br><span class=\"line\"><span class=\"number\">2.</span>循环文本串，然后循环匹配，如果不匹配，则寻找之前匹配的位置，如果匹配，j++，最后如果出现了文本串则根据题目要求返回相应值。</span><br></pre></td></tr></table></figure>\n<p>下面这个图很好解释了为什么当我们遇到不匹配的字符后，因为next数组记录了相等前后缀长度，遇到不匹配的字符后，j回退到next[j-1]，这个next[j-1]就是他们之前的最长相等前后缀长度，也就是回退到这个位置的时候，模式串从0到这个位置的字符，是和主串i位置之前的字符相等，之前字符的长度，就是模式串从0到这个位置的字符的长度，这是核心理解。至于next数组为什么那么求，目前还没有深刻的理解，但是至少理解了，为什么要回退这个步骤。<br><img src=\"/images/leetcode-java/kmp.jpg\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">strStr</span><span class=\"params\">(String haystack, String needle)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[needle.length()];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        getNext(next, needle);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; haystack.length(); i++) &#123;<span class=\"comment\">//这里是从0开始的哦</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) &#123;</span><br><span class=\"line\">                j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == needle.length()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i  - needle.length() + <span class=\"number\">1</span>;<span class=\"comment\">//因为我们是要找主串上的起始位置，所以 是用i去减，而不是j</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getNext</span><span class=\"params\">(<span class=\"type\">int</span>[] next, String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//这句可写可不写，因为初始化的时候都是0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; s.length(); i++) &#123;<span class=\"comment\">//i是从1开是的，因为你只有一个字母的时候，肯定是0，所以第一个不用考虑，直接从第二个位置开始</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; s.charAt(i) != s.charAt(j))&#123;</span><br><span class=\"line\">                j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"459-重复的子字符串-easy-KMP\"><a href=\"#459-重复的子字符串-easy-KMP\" class=\"headerlink\" title=\"459 重复的子字符串 easy(KMP)\"></a>459 重复的子字符串 easy(KMP)</h3><p>重点理解周期长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">repeatedSubstringPattern</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length()];</span><br><span class=\"line\">        getNext(next, s);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n % (n - next[n - <span class=\"number\">1</span>]) == <span class=\"number\">0</span> &amp;&amp; next[n - <span class=\"number\">1</span>] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getNext</span><span class=\"params\">(<span class=\"type\">int</span>[] next, String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(j &gt; <span class=\"number\">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j)) j++;</span><br><span class=\"line\">            next[i] = j;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题也是kmp的题目，寻找重复的子串</span><br><span class=\"line\">注意理解一个概念：</span><br><span class=\"line\">数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</span><br><span class=\"line\">所以我们求完next数组后</span><br><span class=\"line\">n % (n - next[n - <span class=\"number\">1</span>]) == <span class=\"number\">0</span> n是长度，next[n - <span class=\"number\">1</span>]也就是最长的相同前后缀的长度</span><br><span class=\"line\">next[n - <span class=\"number\">1</span>] != <span class=\"number\">0</span>这个是为了保证，next数组最后一个长度不是<span class=\"number\">0</span>，否则判断出错，下面举个例子</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;abac&quot;</span>的next数组是[<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]，如果没有next[n - <span class=\"number\">1</span>] != <span class=\"number\">0</span>这个条件，那就是<span class=\"number\">4</span> % (<span class=\"number\">4</span> - <span class=\"number\">0</span>) == <span class=\"number\">0</span>就返回了<span class=\"literal\">true</span>，实际上是<span class=\"literal\">false</span>，所以要保证最长相同前后缀长度不为<span class=\"number\">0</span>先</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot;aaaa&quot;</span>的next数组是[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]，那么<span class=\"number\">4</span> %(<span class=\"number\">4</span> - <span class=\"number\">3</span>) ==<span class=\"number\">0</span>返回<span class=\"literal\">true</span>，<span class=\"number\">4</span>-<span class=\"number\">3</span>=<span class=\"number\">1</span>也就是说这个周期长度是<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h2><h3 id=\"232-用栈实现队列-easy\"><a href=\"#232-用栈实现队列-easy\" class=\"headerlink\" title=\"232 用栈实现队列 easy\"></a>232 用栈实现队列 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\">    Stack&lt;Integer&gt; Stackin;<span class=\"comment\">//首先全局定义</span></span><br><span class=\"line\">    Stack&lt;Integer&gt; Stackout;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        Stackin = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();<span class=\"comment\">//别忘了new</span></span><br><span class=\"line\">        Stackout = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        Stackin.push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        dumpStackin();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Stackout.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">peek</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        dumpStackin();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Stackout.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Stackin.isEmpty() &amp;&amp; Stackout.isEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dumpStackin</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Stackout.isEmpty()) <span class=\"keyword\">return</span>;<span class=\"comment\">//先检查出栈，如果出栈不为空，则直接使用出栈队列，也就是返回一个号空</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!Stackin.isEmpty()) &#123;<span class=\"comment\">//如果入栈不为空，要把入栈的全部移动到出栈，注意入栈此时要删除元素</span></span><br><span class=\"line\">            Stackout.push(Stackin.pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题是用两个栈来实现队列的操作</span><br><span class=\"line\">队列：先进先出 栈：先进后出</span><br><span class=\"line\">pop：移除元素并返回该元素</span><br><span class=\"line\">peak：返回队列开头元素</span><br><span class=\"line\">push：添加元素</span><br><span class=\"line\">那么用栈去完成队列的功能，需要两个栈，一个为作为入栈，一个作为出栈。</span><br><span class=\"line\"></span><br><span class=\"line\">入栈：直接就是push元素进去</span><br><span class=\"line\">pop：检查出栈有无元素，有的话直接操作出栈的元素，如果出栈是空的话，那么将入栈的目前所有的元素全部移动到出栈中，再操作出栈pop</span><br><span class=\"line\">peak：和pop一样的道理</span><br><span class=\"line\">pip和peak都是java内置的，所以直接调用，我们主要是负责把入栈的元素移动到出栈中，这样才可以实现队列先进先出的功能</span><br><span class=\"line\">那么判断栈是否为空，只要两个都是空，那么就是空栈</span><br></pre></td></tr></table></figure>\n<h3 id=\"225-用队列实现栈-easy\"><a href=\"#225-用队列实现栈-easy\" class=\"headerlink\" title=\"225 用队列实现栈 easy\"></a>225 用队列实现栈 easy</h3><p>题目要求必须要用两个队列<br>pop移除并返回栈顶元素<br>top返回栈顶元素</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">关于LinkedList一些api</span></span><br><span class=\"line\"><span class=\"comment\">peekFirst()此方法用于检索链表的第一个元素，初始元素或开始元素，但不会从列表中删除第一个元素。</span></span><br><span class=\"line\"><span class=\"comment\">peekLast()方法用于返回此双端队列表示的队列的最后一个元素，但不删除该元素。</span></span><br><span class=\"line\"><span class=\"comment\">pollLast()检索并删除此列表的最后一个元素，如果此列表为空，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\">pollFirst()检索并删除此列表的第一个元素，如果此列表为空，则返回null。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">可以用queue，也可以用deque</span></span><br><span class=\"line\"><span class=\"comment\">用了两个deque，核心在pop上，弹出元素的时候，思路就是先把que1除了最后一个元素，然后将其他元素全部移到que2中</span></span><br><span class=\"line\"><span class=\"comment\">这时候que1只剩下一个元素，这个元素就是需要的值，然后再将que2变成que1即可。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyStack</span> &#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; que1;</span><br><span class=\"line\">    Deque&lt;Integer&gt; que2;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        que1 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        que2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        que1.addLast(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> que1.size();</span><br><span class=\"line\">        n--;<span class=\"comment\">//除了最后一个元素，其余元素都要移到que2中</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (n-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            que2.addLast(que1.peekFirst());</span><br><span class=\"line\">            que1.pollFirst();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> que1.pollFirst();</span><br><span class=\"line\">        que1 = que2;</span><br><span class=\"line\">        que2 = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que1.peekLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que1.isEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyStack obj = new MyStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>下面是用双端队列，抖机灵用的，只用一个队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyStack</span> &#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; que;<span class=\"comment\">//双端队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">MyStack</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        que = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        que.addLast(x);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">pop</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//栈顶：最后一个入栈的元素</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> que.pollLast();<span class=\"comment\">//栈的是先进后出，队列是先进先出，所以从队列最后返回也就是对应栈的先进后出</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">top</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.peekLast();<span class=\"comment\">//和上面一样的道理，只不过不需要删除元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">empty</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.isEmpty();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyStack obj = new MyStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"20-有效的括号-easy\"><a href=\"#20-有效的括号-easy\" class=\"headerlink\" title=\"20 有效的括号 easy\"></a>20 有效的括号 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">定义一个栈（其实双端队列也行）</span></span><br><span class=\"line\"><span class=\"comment\">然后扫描字符串s，如果是(,就在栈中放)，如果是[，就在栈中放]，如果是&#123;，就在栈中放&#125;。</span></span><br><span class=\"line\"><span class=\"comment\">然后如果扫描到),],&#125;如果这时候的栈顶是该元素，就删除，如果不是，说明不匹配了，直接返回false，还有一种情况是，栈是空的，也是不匹配的情况</span></span><br><span class=\"line\"><span class=\"comment\">最后检查栈是不是为空，为空就说明全部匹配上了</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValid</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        Stack&lt;Character&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;(&#x27;</span>) &#123;</span><br><span class=\"line\">                que.push(<span class=\"string\">&#x27;)&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;[&#x27;</span>) &#123;</span><br><span class=\"line\">                que.push(<span class=\"string\">&#x27;]&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s.charAt(i) == <span class=\"string\">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class=\"line\">                que.push(<span class=\"string\">&#x27;&#125;&#x27;</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (que.isEmpty() || que.peek() != s.charAt(i)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (que.peek() == s.charAt(i)) &#123;</span><br><span class=\"line\">                que.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1047-删除字符串中的所有相邻重复项-easy\"><a href=\"#1047-删除字符串中的所有相邻重复项-easy\" class=\"headerlink\" title=\"1047 删除字符串中的所有相邻重复项 easy\"></a>1047 删除字符串中的所有相邻重复项 easy</h3><p>这个可以看卡哥的动画，瞬间就可以明白</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">定义一个双端队列</span></span><br><span class=\"line\"><span class=\"comment\">如果队列是空的或者队列的顶元素和当前s[i]不一样，就把s[i]押进队列中，</span></span><br><span class=\"line\"><span class=\"comment\">如果当前s[i]和顶元素一样的话，就删除该队列中该元素，这也就是&quot;对对碰消失&quot;的核心</span></span><br><span class=\"line\"><span class=\"comment\">最后就是把里面的元素提取出来整合到字符串中</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">removeDuplicates</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        ArrayDeque&lt;Character&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">ch</span> <span class=\"operator\">=</span> s.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (que.isEmpty() || que.peek() != ch) &#123;</span><br><span class=\"line\">                que.push(ch);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                que.pop();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//队列最后是[a,c]的话，首先弹出c,然后再弹出a，所以pop后加上result才能正确拼接</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!que.isEmpty()) &#123;</span><br><span class=\"line\">            result = que.pop() + result;<span class=\"comment\">//有个不留意的地方，第一次写成result += que.pop()； 相当于result = result + que.pop()，这是错误的，加错了。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"150-逆波兰表达式求值-medium\"><a href=\"#150-逆波兰表达式求值-medium\" class=\"headerlink\" title=\"150 逆波兰表达式求值 medium\"></a>150 逆波兰表达式求值 medium</h3><p>这个题看动画就秒懂了，这个是后缀表达式，可以依次顺序来计算结果。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">一个小知识点： &quot;&quot;是String类型，&#x27;&#x27;是char类型</span></span><br><span class=\"line\"><span class=\"comment\">思路就是，如果检测到有符号，就说明需要运算，就弹出之前的两个值进行运行，然后再把结果push到队列中即可。</span></span><br><span class=\"line\"><span class=\"comment\">但是注意先弹出的元素是后运算的，比如 6 3 /,先弹出3，然后弹出6，所以你要定义好两个变量去保存，别搞乱顺序运算</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">evalRPN</span><span class=\"params\">(String[] tokens)</span> &#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ch:tokens) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;+&quot;</span>.equals(ch) || <span class=\"string\">&quot;-&quot;</span>.equals(ch) || <span class=\"string\">&quot;*&quot;</span>.equals(ch)|| <span class=\"string\">&quot;/&quot;</span>.equals(ch))&#123;<span class=\"comment\">//力扣的问题，不能用==，只能用equals</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp1</span> <span class=\"operator\">=</span> que.pop();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp2</span> <span class=\"operator\">=</span> que.pop();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (<span class=\"string\">&quot;+&quot;</span>.equals(ch)) &#123;</span><br><span class=\"line\">                    que.push(temp2 + temp1);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;-&quot;</span>.equals(ch))  &#123;</span><br><span class=\"line\">                    que.push(temp2 - temp1);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;*&quot;</span>.equals(ch))  &#123;</span><br><span class=\"line\">                    que.push(temp2 * temp1);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;/&quot;</span>.equals(ch))  &#123;</span><br><span class=\"line\">                    que.push(temp2 / temp1);</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    que.push(Integer.valueOf(ch));</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">就是上面解法的简化版，但是需要注意减法和除法，而上面则不需要顾虑太多</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">evalRPN</span><span class=\"params\">(String[] tokens)</span> &#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String ch:tokens) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"string\">&quot;+&quot;</span>.equals(ch)) &#123;</span><br><span class=\"line\">                que.push(que.pop() + que.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;-&quot;</span>.equals(ch))  &#123;</span><br><span class=\"line\">                que.push(-que.pop() + que.pop());<span class=\"comment\">//这里需要前面加个负号</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;*&quot;</span>.equals(ch))  &#123;</span><br><span class=\"line\">                que.push(que.pop() * que.pop());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"string\">&quot;/&quot;</span>.equals(ch))  &#123;<span class=\"comment\">//除法要注意</span></span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp1</span> <span class=\"operator\">=</span> que.pop();</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">temp2</span> <span class=\"operator\">=</span> que.pop();</span><br><span class=\"line\">                que.push(temp2 / temp1);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                que.push(Integer.valueOf(ch));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.pop();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"239-滑动窗口最大值-hard\"><a href=\"#239-滑动窗口最大值-hard\" class=\"headerlink\" title=\"239 滑动窗口最大值 hard\"></a>239 滑动窗口最大值 hard</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">巩固知识</span><br><span class=\"line\">add/offer/offerLast添加队尾，三个方法等价；</span><br><span class=\"line\">push/offerFirst添加队头，两个方法等价。</span><br><span class=\"line\">remove/pop/poll/pollFirst删除队头，四个方法等价；</span><br><span class=\"line\">pollLast删除队尾。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add/remove源自集合，添加到队尾 / 从队头删除；</span><br><span class=\"line\">offer/poll源自队列 添加到队尾/ 从队头删除；</span><br><span class=\"line\">push/pop源自栈   添加到队头/ 从队头删除；</span><br><span class=\"line\">offerFirst/offerLast/pollFirst/pollLast源自双端队列（两端都可以进也都可以出），offerFirst添加到队头，offerLast添加到队尾，pollFirst从队头删除，pollLast从队尾删除。</span><br><span class=\"line\"></span><br><span class=\"line\">peek()方法用于返回此双端队列表示的队列的头元素，但不删除该元素。</span><br><span class=\"line\"></span><br><span class=\"line\">java最好别用Stack来实现栈的功能，官方说的，不推荐使用，所以可以用deque来做栈</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个题是用单调队列来完成的</span></span><br><span class=\"line\"><span class=\"comment\">队列中只用于保存位置，而不是保存nums的具体值，这样的原因是，可以用于判断是否超过了滑动窗口的范围。</span></span><br><span class=\"line\"><span class=\"comment\">队列的头代表的位置始终是值最大的</span></span><br><span class=\"line\"><span class=\"comment\">具体操作：</span></span><br><span class=\"line\"><span class=\"comment\">首先判断队列中的范围是否超过滑动窗口的范围，如果超过了，则要移除，因为先进入队列的位置是最早的，所以看队列的头来判断</span></span><br><span class=\"line\"><span class=\"comment\">然后判断nums[i]是否比队列尾巴所代表的nums值要大，如果大了，就移除队尾的元素，但是小于可以插进去队列，这也说明队列是单调的，单调递减</span></span><br><span class=\"line\"><span class=\"comment\">最后就是把结果放入res中</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] maxSlidingWindow(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        ArrayDeque&lt;Integer&gt; deque = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> nums.length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n - k + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class=\"number\">1</span>) &#123;<span class=\"comment\">//判断队头是否超过滑动窗口的范围</span></span><br><span class=\"line\">                deque.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<span class=\"comment\">//保证单调，判断队尾是否小于下一个值，如果是，就不断移除队列尾元素，直到符合要求</span></span><br><span class=\"line\">                deque.pollLast();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            deque.offer(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt;= k - <span class=\"number\">1</span>) &#123;<span class=\"comment\">//比如k=3，i从2开始就可以取出元素放了，然后每移动一次都放一次</span></span><br><span class=\"line\">                res[x++] = nums[deque.peek()];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"347-前k个高频元素-medium\"><a href=\"#347-前k个高频元素-medium\" class=\"headerlink\" title=\"347 前k个高频元素 medium\"></a>347 前k个高频元素 medium</h3><p>之前做过，但是发现之前的方法有点复杂，下面是小顶堆的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] topKFrequent(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[k];</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums) &#123;</span><br><span class=\"line\">            map.put(num, map.getOrDefault(num, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\"></span><br><span class=\"line\">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class=\"line\">            queue.offer(entry);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (queue.size() &gt; k) &#123;</span><br><span class=\"line\">                queue.poll();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; k; i++) &#123;</span><br><span class=\"line\">            result[i] = queue.poll().getKey();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">思路是首先是先用map来存储key和value，value就是统计次数。</span><br><span class=\"line\">set来保存这个键值后构建小顶堆，小顶堆poll掉的是小数，留下来的是大数，然后判断队列中的大数是否超过k</span><br><span class=\"line\">超过k就poll掉，最后用一个数组来保留结果。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">下面是一些语法记录：以[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], k = <span class=\"number\">2</span>为例子</span><br><span class=\"line\">map不能直接使用迭代器，所以用set</span><br><span class=\"line\">map有一个方法叫做entrySet(),这方法可以将Map的键值对的映射关系作为set集合的元素存储到Set集合当中，而这种映射关系的类型就是Entry的类型。</span><br><span class=\"line\">Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。</span><br><span class=\"line\">Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\">上面这句话打印出来的entries是[<span class=\"number\">1</span>=<span class=\"number\">3</span>, <span class=\"number\">2</span>=<span class=\"number\">2</span>, <span class=\"number\">3</span>=<span class=\"number\">1</span>]</span><br><span class=\"line\">当然了，直接打印map.entrySet()打印出来也是[<span class=\"number\">1</span>=<span class=\"number\">3</span>, <span class=\"number\">2</span>=<span class=\"number\">2</span>, <span class=\"number\">3</span>=<span class=\"number\">1</span>]，用set还是为了能够迭代</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">构建小顶堆的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class=\"line\">如果是大顶堆则是<span class=\"keyword\">new</span> <span class=\"title class_\">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2.getValue() - o1.getValue());</span><br><span class=\"line\">PriorityQueue（优先队列）</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add和remove是一对，源自Collection；</span><br><span class=\"line\">offer和poll是一对，源自Queue；</span><br><span class=\"line\">push和pop是一对，源自Deque，其本质是栈（Stack类由于某些历史原因，官方已不建议使用，使用Deque代替）；</span><br><span class=\"line\">offerFirst/offerLast和pollFirst/pollLast是一对，源自Deque，其本质是双端队列。</span><br></pre></td></tr></table></figure>\n<h2 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h2><p>递归三部曲：<br>1.确定递归函数的参数和返回值<br>2.确定终止条件<br>3.确定单层递归的逻辑</p>\n<p>务必熟悉定义二叉树</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TreeNode</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">    TreeNode left;</span><br><span class=\"line\">    TreeNode right;</span><br><span class=\"line\">    TreeNode() &#123;&#125;;<span class=\"comment\">//&#123;&#125;容易漏</span></span><br><span class=\"line\">    TreeNode(<span class=\"type\">int</span> val) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    TreeNode(<span class=\"type\">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.val = val;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这里注意下递归中reurn的问题</span></span><br><span class=\"line\"><span class=\"comment\">如果是TreeNode 一般return null;</span></span><br><span class=\"line\"><span class=\"comment\">如果是获得元素的值，这里的return代表终止运行程序，也不能return 0哦，直接终止即可，看530。</span></span><br><span class=\"line\"><span class=\"comment\">如果求深度，就return 0 看104</span></span><br><span class=\"line\"><span class=\"comment\">如果判断是话 就return true 看98</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"94-144-145-二叉数递归遍历（递归法）-easy\"><a href=\"#94-144-145-二叉数递归遍历（递归法）-easy\" class=\"headerlink\" title=\"94&#x2F;144&#x2F;145 二叉数递归遍历（递归法） easy\"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（递归法） easy</h3><p>递归遍历三步骤：1.确定输入的参数和返回值（定义递归函数入口） 2.确定终止条件 3.确定递归逻辑（函数内容）</p>\n<p>144 前序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        preOrder(root, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preOrder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        result.add(root.val);</span><br><span class=\"line\">        preOrder(root.left, result);</span><br><span class=\"line\">        preOrder(root.right, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>94 中序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result =  <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        inOrder(root, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">inOrder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inOrder(root.left, result);</span><br><span class=\"line\">        result.add(root.val);</span><br><span class=\"line\">        inOrder(root.right, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>145 后序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result =  <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        postOrder(root, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">postOrder</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        postOrder(root.left, result);</span><br><span class=\"line\">        postOrder(root.right, result);</span><br><span class=\"line\">        result.add(root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"94-144-145-二叉数递归遍历（迭代法）-easy\"><a href=\"#94-144-145-二叉数递归遍历（迭代法）-easy\" class=\"headerlink\" title=\"94&#x2F;144&#x2F;145 二叉数递归遍历（迭代法） easy\"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（迭代法） easy</h3><p>144 前序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">前序遍历是中-左-右，迭代法用栈来解决 入栈的顺序是中-右-左</span></span><br><span class=\"line\"><span class=\"comment\">需要注意的是，栈是先进后出，所以如果要达到中左右的效果，需要右边先进栈，这样就可以后出。</span></span><br><span class=\"line\"><span class=\"comment\">还需要注意stack的类型是TreeNode哦</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();<span class=\"comment\">//去掉ArrayList&lt;Integer&gt;中的Integer也可以的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span>  stack.pop();</span><br><span class=\"line\">             result.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//这里务必注意不能写成else if，比如[3,1,2]，如果这样写答案为[3,2],因为if else只会判断一次，这样就把left给丢掉了</span></span><br><span class=\"line\">                stack.push(node.left);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>94 中序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">中序遍历：左-中-右</span></span><br><span class=\"line\"><span class=\"comment\">迭代法就是先把左节点全部压进栈中，然后等空了就弹出来顺便取值，然后再压右节点进去</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty() || root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                root = stack.pop();</span><br><span class=\"line\">                result.add(root.val);</span><br><span class=\"line\">                root = root.right;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>145 后序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果。</span></span><br><span class=\"line\"><span class=\"comment\">和前序迭代法很相似，只有两个地方不同：1.压栈顺序2.结果翻转</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();<span class=\"comment\">//去掉ArrayList&lt;Integer&gt;中的Integer也可以的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span>  stack.pop();</span><br><span class=\"line\">             result.add(node.val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node.left);<span class=\"comment\">//先压左边</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node.right);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(result);<span class=\"comment\">//最后要翻转</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"94-144-145-二叉数递归遍历（统一迭代法）-easy\"><a href=\"#94-144-145-二叉数递归遍历（统一迭代法）-easy\" class=\"headerlink\" title=\"94&#x2F;144&#x2F;145 二叉数递归遍历（统一迭代法） easy\"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（统一迭代法） easy</h3><p>因为迭代法的写法是针对每种遍历顺序定制的，没有统一的规律，所以才有统一迭代法。<br>144 前序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">前序遍历：中-左-右   在本方法的压栈顺序为：右-左-中</span></span><br><span class=\"line\"><span class=\"comment\">中序遍历：左-中-右   在本方法的压栈顺序为：右-中-左 </span></span><br><span class=\"line\"><span class=\"comment\">后序遍历：左-右-中   在本方法的压栈顺序为：中-右-左</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">这里有个细节的地方就是添加了中节点后还添加了一个null节点，那么读取的时候，会不会读到null呢</span></span><br><span class=\"line\"><span class=\"comment\">答案是会的，但是当我们读到null时候（每次while都会重新读取栈顶），就会触发else这里，然后继续pop取值，这时候就是一个新的node，然后加入该节点的val进入结果中 </span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">push和pop是一对</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次做的反思，首先没有考虑到倒着顺序进行进栈和压栈</span></span><br><span class=\"line\"><span class=\"comment\">其次，在内部node的处理上，还是还是习惯写成root，感觉自己就像背题一样而没有去理解题目</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);<span class=\"comment\">//压入root</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> stack.pop();<span class=\"comment\">//提取栈顶元素并删除</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) stack.push(node.right);<span class=\"comment\">//添加右节点（空节点不入栈）</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) stack.push(node.left);<span class=\"comment\">//添加左节点（空节点不入栈）</span></span><br><span class=\"line\">                stack.push(node);<span class=\"comment\">// 添加中节点</span></span><br><span class=\"line\">                stack.push(<span class=\"literal\">null</span>);<span class=\"comment\">// 中节点访问过，但是还没有处理，加入空节点做为标记。                </span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                result.add(node.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为不推荐用stack，这里用LinkedList替代</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">LinkedList中的pop()和poll()的区别</span></span><br><span class=\"line\"><span class=\"comment\">poll是队列数据结构实现类的方法，从队首获取元素，同时获取的这个元素将从原队列删除</span></span><br><span class=\"line\"><span class=\"comment\">pop是栈结构的实现类的方法，表示返回栈顶的元素，同时该元素从栈中删除，当栈中没有元素时，调用该方法会发生异常</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">同样，还有push，offer和add区别</span></span><br><span class=\"line\"><span class=\"comment\">push是把LinkedList当做栈来用</span></span><br><span class=\"line\"><span class=\"comment\">offer和add是当做链表或者队列来用</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();<span class=\"comment\">//List是没有push方法的，所以前面是LinkedList&lt;TreeNode&gt;</span></span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) stack.push(temp.right);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) stack.push(temp.left);</span><br><span class=\"line\">                stack.push(temp);</span><br><span class=\"line\">                stack.push(<span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                temp = stack.pop();</span><br><span class=\"line\">                result.add(temp.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>94 中序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) stack.push(node.right);</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                stack.push(<span class=\"literal\">null</span>);  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) stack.push(node.left);              </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                result.add(node.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>145 后序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">Stack</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!stack.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                stack.push(node);</span><br><span class=\"line\">                stack.push(<span class=\"literal\">null</span>); </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) stack.push(node.right);    </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) stack.push(node.left);           </span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                node = stack.pop();</span><br><span class=\"line\">                result.add(node.val);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"102-二叉树的层序遍历-medium\"><a href=\"#102-二叉树的层序遍历-medium\" class=\"headerlink\" title=\"102 二叉树的层序遍历 medium\"></a>102 二叉树的层序遍历 medium</h3><p>用队列先进先出的特性，对每层保存然后poll出来，顺序就是层序遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">具体解法：</span></span><br><span class=\"line\"><span class=\"comment\">对每一层进行操作，那么怎么判断是这层呢</span></span><br><span class=\"line\"><span class=\"comment\">用len来判断，当队列加完这层后，再用len计算长度，然后一个个出列，处理完一层，再处理一层，这样就做到层序遍历。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">levelOrder</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class=\"comment\">//注意我们输出的格式如[[[1],[2,3],[4,5,6]]]</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();<span class=\"comment\">//队列存的是TreeNode</span></span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            List&lt;Integer&gt; ietmList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();<span class=\"comment\">//先定义</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> queue.size();<span class=\"comment\">//记录长度</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//while哦，一直加节点</span></span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> queue.poll();<span class=\"comment\">//第二次做的时候，把这个放到了while上面，不应该！</span></span><br><span class=\"line\">                ietmList.add(temp.val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) queue.offer(temp.left);<span class=\"comment\">//这里是temp不是root</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) queue.offer(temp.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            result.add(ietmList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"226-翻转二叉树-easy\"><a href=\"#226-翻转二叉树-easy\" class=\"headerlink\" title=\"226 翻转二叉树 easy\"></a>226 翻转二叉树 easy</h3><p>递归法，可以对比下前序遍历的递归（后序也可以，但是不可以用中序）。<br>做这个题一开始用List去保存，哎，年轻。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">invertTree</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//root也可以</span></span><br><span class=\"line\">        swapTree(root);</span><br><span class=\"line\">        invertTree(root.left);</span><br><span class=\"line\">        invertTree(root.right);<span class=\"comment\">//第二次写，居然写成swapTree，实质上还是没有理解好递归,处理根的时候，就是交换，然后左右就是递归</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swapTree</span><span class=\"params\">(TreeNode node)</span> &#123;<span class=\"comment\">//第二次写的时候写了TreeNode left，TreeNode right两个参数，其实不需要，按照遍历递归，先处理左边，再处理右边</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> node.left;</span><br><span class=\"line\">        node.left = node.right;</span><br><span class=\"line\">        node.right = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>层序遍历，可以好好看看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">invertTree</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                swapTree(temp);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) queue.offer(temp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) queue.offer(temp.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swapTree</span><span class=\"params\">(TreeNode node)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> node.left;</span><br><span class=\"line\">        node.left = node.right;</span><br><span class=\"line\">        node.right = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"101-对称二叉树-easy\"><a href=\"#101-对称二叉树-easy\" class=\"headerlink\" title=\"101 对称二叉树 easy\"></a>101 对称二叉树 easy</h3><p>判断是不是对称二叉树，返回true或者false，用了递归法内外是否一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">对称，那么就是判断内外是否一样</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">先判断节点空的三种情况：都空，左空，右空。</span></span><br><span class=\"line\"><span class=\"comment\">然后都不空了，判断值是否相等，但是这里只能判断不等的情况返回false，不能写成相等情况返回true，理由如下：</span></span><br><span class=\"line\"><span class=\"comment\">此时就是：左右节点都不为空，且数值相同的情况，已经被我们过滤完了，此时才做递归，做下一层的判断</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">所以如果你是判断了相同的，但是可能不同的没有过滤就进入递归了</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">再一次做还是错误，首先是大概有印象是用内外，但是没有用到函数compare，导致一直写错</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSymmetric</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> compare(root.left, root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">compare</span><span class=\"params\">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span> &amp;&amp; right == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span> &amp;&amp; right != <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left != <span class=\"literal\">null</span> &amp;&amp; right == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left.val != right.val) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//注意不能写成if (left.val == right.val) return true; </span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">outSide</span> <span class=\"operator\">=</span> compare(left.left, right.right);</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">inSide</span> <span class=\"operator\">=</span> compare(left.right, right.left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> outSide &amp;&amp; inSide;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"104-二叉树最大深度-easy\"><a href=\"#104-二叉树最大深度-easy\" class=\"headerlink\" title=\"104 二叉树最大深度 easy\"></a>104 二叉树最大深度 easy</h3><p>使用递归法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1.确定参数</span></span><br><span class=\"line\"><span class=\"comment\">2.确定终止条件</span></span><br><span class=\"line\"><span class=\"comment\">3.递归逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> maxDepth(root.left);<span class=\"comment\">//左</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> maxDepth(root.right);<span class=\"comment\">//右</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">depth</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> + Math.max(left, right);<span class=\"comment\">//中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"111-二叉树的最小深度-easy\"><a href=\"#111-二叉树的最小深度-easy\" class=\"headerlink\" title=\"111 二叉树的最小深度 easy\"></a>111 二叉树的最小深度 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个最小深度和最大深度是有区别的</span></span><br><span class=\"line\"><span class=\"comment\">比如，如果左子树都是空的，右子树一直叠加，那么最小深度，是算右子树那边的</span></span><br><span class=\"line\"><span class=\"comment\">那么就需要做出一个判断</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次做的时候，没有考虑到要同时满足条件再返回1+right或者left</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDepth</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> minDepth(root.left);<span class=\"comment\">//左</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> minDepth(root.right);<span class=\"comment\">//右</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//左边空，右边不空，则返回右边长度，可以直接写成if (root.left == null)</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + left;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">depth</span> <span class=\"operator\">=</span> <span class=\"number\">1</span> + Math.min(left, right);<span class=\"comment\">//找到最小值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"222-完全二叉树的节点个数-medium\"><a href=\"#222-完全二叉树的节点个数-medium\" class=\"headerlink\" title=\"222 完全二叉树的节点个数 medium\"></a>222 完全二叉树的节点个数 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">层序遍历即可，这个是自己想到的，然后套用前面的代码修改</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">countNodes</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (len-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                result += <span class=\"number\">1</span>;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) queue.offer(temp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) queue.offer(temp.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"110-平衡二叉树-easy\"><a href=\"#110-平衡二叉树-easy\" class=\"headerlink\" title=\"110 平衡二叉树 easy\"></a>110 平衡二叉树 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">关于深度和高度，这只是力扣中的定义，其他教科书可能不一样</span></span><br><span class=\"line\"><span class=\"comment\">二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</span></span><br><span class=\"line\"><span class=\"comment\">二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">关于这个题，首先要了解平衡二叉树的概念，然后如果已经检测到左右子树相差大于1，剩下都是返回-1，否则返回的是正常高度。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次做存在的问题：</span></span><br><span class=\"line\"><span class=\"comment\">1.没有想到用一个辅助getheight函数，注意这个题是返回一个true还是false，而我们当然要用高度来判断</span></span><br><span class=\"line\"><span class=\"comment\">2.遗忘左-右绝对值的问题</span></span><br><span class=\"line\"><span class=\"comment\">3.需要注意如果已经不平衡的情况</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isBalanced</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getHeight(root) != -<span class=\"number\">1</span>;<span class=\"comment\">//不为-1，就返回true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getHeight</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> getHeight(root.left);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> getHeight(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//如果已经不平衡了，就返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//如果已经不平衡了，就返回-1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math.abs(left - right) &gt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//Math.abs函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> + Math.max(left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"257-二叉树的所有路径-easy-1\"><a href=\"#257-二叉树的所有路径-easy-1\" class=\"headerlink\" title=\"257 二叉树的所有路径 easy\"></a>257 二叉树的所有路径 easy</h3><p><a href=\"#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy\">代码此链接</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">以前做过，为什么又忘记，这次复查到的问题：</span><br><span class=\"line\">constructpath(root, <span class=\"string\">&quot;&quot;</span>, paths);<span class=\"comment\">//中间的参数，不能有空格，</span></span><br><span class=\"line\">StringBuffer是append，还有需要toString()</span><br><span class=\"line\">ArrayList是add</span><br><span class=\"line\">递归函数里面的<span class=\"keyword\">if</span> <span class=\"keyword\">else</span>是套在第一个<span class=\"keyword\">if</span>中的</span><br><span class=\"line\">递归：<span class=\"number\">1.</span>确定参数<span class=\"number\">2.</span>终止条件<span class=\"number\">3.</span>确定递归逻辑</span><br></pre></td></tr></table></figure>\n<p>这个代码主要是为了方便理解回溯</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">binaryTreePaths</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;String&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        preorderdfs(root, res, path);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preorderdfs</span><span class=\"params\">(TreeNode root, List&lt;String&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class=\"line\">        path.add(root.val);<span class=\"comment\">//容易漏</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuffer</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; path.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                sb.append(path.get(i)).append(<span class=\"string\">&quot;-&gt;&quot;</span>);<span class=\"comment\">//注意这里是先加节点，然后继续加&quot;-&gt;&quot;</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(path.get(path.size() - <span class=\"number\">1</span>));<span class=\"comment\">//因为最后一个的后面不需要加&quot;-&gt;&quot;，所以单独拿出来</span></span><br><span class=\"line\">            res.add(sb.toString());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            preorderdfs(root.left, res, path);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            preorderdfs(root.right, res, path);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>全局变量的写法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();<span class=\"comment\">//第二次居然写成List&lt;List&lt;String&gt;&gt;</span></span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">binaryTreePaths</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        backtrack(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        path.add(root.val);<span class=\"comment\">//第二次写漏了</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">StringBuilder</span> <span class=\"variable\">sb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; path.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">                sb.append(path.get(i)).append(<span class=\"string\">&quot;-&gt;&quot;</span>);<span class=\"comment\">//不要写成sb.append(path.get(i).append(&quot;-&gt;&quot;));append要放在外面</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            sb.append(path.get(path.size() - <span class=\"number\">1</span>));</span><br><span class=\"line\">            result.add(sb.toString());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            backtrack(root.left);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            backtrack(root.right);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"404-左叶子之和-easy\"><a href=\"#404-左叶子之和-easy\" class=\"headerlink\" title=\"404 左叶子之和 easy\"></a>404 左叶子之和 easy</h3><p>有点像求深度那个题，也是左右中的顺序，不同点是判断左叶子节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> sumOfLeftLeaves(root.left);<span class=\"comment\">//左子树的情况</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> sumOfLeftLeaves(root.right);<span class=\"comment\">//右子树的情况</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span> &amp;&amp; root.left.left == <span class=\"literal\">null</span> &amp;&amp; root.left.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            mid = root.left.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> left + right + mid;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">迭代法，这个和层序遍历还是有一点点差别的，没有len之后进行循环，这个要注意</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span> &amp;&amp; node.left.left == <span class=\"literal\">null</span> &amp;&amp; node.left.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                sum += node.left.val;               </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.left != <span class=\"literal\">null</span>) queue.offer(node.left);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.right != <span class=\"literal\">null</span>) queue.offer(node.right);            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"513-找树左下角的值-medium\"><a href=\"#513-找树左下角的值-medium\" class=\"headerlink\" title=\"513 找树左下角的值 medium\"></a>513 找树左下角的值 medium</h3><p>用层序遍历的思路即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个代码是根据层序遍历后自己写的，但是写的不好，可以看第二个代码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findBottomLeftValue</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">flag</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (len &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (flag == <span class=\"number\">0</span>) result = temp.val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) queue.offer(temp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) queue.offer(temp.right);</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len == <span class=\"number\">0</span>) &#123;<span class=\"comment\">//我这里设置了一个标志，当len为0，代表循环准备进入下一层</span></span><br><span class=\"line\">                    flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>迭代法一直没调试好while，就是类似于层序遍历</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findBottomLeftValue</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class=\"line\">        queue.offer(root);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> queue.size();<span class=\"comment\">//需要注意的是，len不用再--</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;<span class=\"comment\">//这里用for就会简洁很多</span></span><br><span class=\"line\">                <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> queue.poll();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) result = temp.val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.left != <span class=\"literal\">null</span>) queue.offer(temp.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp.right != <span class=\"literal\">null</span>) queue.offer(temp.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;   </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"路径总和\"><a href=\"#路径总和\" class=\"headerlink\" title=\"路径总和\"></a>路径总和</h3><h4 id=\"112-路径总和-easy\"><a href=\"#112-路径总和-easy\" class=\"headerlink\" title=\"112 路径总和 easy\"></a>112 路径总和 easy</h4><p>这个题目表达的不太清楚，实际上是判断路径有没有符合targetsum，只要有一个符合就返回true。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">用减法来一步步走，走到最后叶子节点，如果此时target和叶节点相等，就说明找到了，这个题目只需要找到一个即可。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> targetSum == root.val;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"113-路径总和2-easy\"><a href=\"#113-路径总和2-easy\" class=\"headerlink\" title=\"113 路径总和2 easy\"></a>113 路径总和2 easy</h4><p>这个题要结合<a href=\"#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy-1\">257</a>，还有就是257的返回值和这个题不一样，257需要箭头指向，也就是类型是String，具体看是如何处理的，和112的区别是需要把target值都符合的添加进来，这三个题都要好好敲一遍。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum)</span> &#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; res = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        List&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        preorderdfs(root, targetSum, res, path);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">preorderdfs</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class=\"line\">        path.add(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (targetSum == root.val) &#123;</span><br><span class=\"line\">                res.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            preorderdfs(root.left, targetSum - root.val, res, path);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.right != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            preorderdfs(root.right, targetSum - root.val, res, path);</span><br><span class=\"line\">            path.remove(path.size() - <span class=\"number\">1</span>);<span class=\"comment\">//回溯</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过中序和前序-后序构建二叉树\"><a href=\"#通过中序和前序-后序构建二叉树\" class=\"headerlink\" title=\"通过中序和前序&#x2F;后序构建二叉树\"></a>通过中序和前序&#x2F;后序构建二叉树</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先要务必清楚要有中序遍历，前序和后序是不能组成二叉树的。</span><br><span class=\"line\">这里只讲后序和中序构造二叉树。</span><br><span class=\"line\">后序是：左右根</span><br><span class=\"line\">中序是：左根右</span><br><span class=\"line\">所以我们先从后序的最后一个数字可以定位根节点，然后在中序中找到这个值，就可以区分左子树和右子树啦</span><br><span class=\"line\">也就是定义一个helper，这是用中序来构建二叉树。</span><br><span class=\"line\"></span><br><span class=\"line\">以后序遍历为例子的思路：</span><br><span class=\"line\">首先把中序的值按照&lt;值，序号&gt;来存到map中，因为后面我们要用后序数组的值来寻找中序数组的序号，所以用&lt;值&gt;可以找到中序的&lt;下标序号&gt;</span><br><span class=\"line\">然后在主方法中，先找到后序根的值，然后用map来定位到中序的index，然后新建root即可，注意后序的话要先构建右子树，再构建左子树</span><br></pre></td></tr></table></figure>\n<h4 id=\"105-从前序与中序遍历序列构造二叉树-medium\"><a href=\"#105-从前序与中序遍历序列构造二叉树-medium\" class=\"headerlink\" title=\"105 从前序与中序遍历序列构造二叉树 medium\"></a>105 从前序与中序遍历序列构造二叉树 medium</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] preorder;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] inorder;</span><br><span class=\"line\">    <span class=\"type\">int</span> pre_idx;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">helper</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootval</span> <span class=\"operator\">=</span> preorder[pre_idx];</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootval);</span><br><span class=\"line\">        pre_idx++;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> map.get(rootval);</span><br><span class=\"line\">        root.left = helper(left, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = helper(index + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] preorder, <span class=\"type\">int</span>[] inorder)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.preorder = preorder;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.inorder = inorder;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pre_idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer val : inorder) &#123;</span><br><span class=\"line\">            map.put(val, idx++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>, preorder.length - <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"106-从中序与后序遍历序列构造二叉树-medium\"><a href=\"#106-从中序与后序遍历序列构造二叉树-medium\" class=\"headerlink\" title=\"106 从中序与后序遍历序列构造二叉树 medium\"></a>106 从中序与后序遍历序列构造二叉树 medium</h4><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span>[] inorder;<span class=\"comment\">//成员变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span>[] postorder;</span><br><span class=\"line\">    <span class=\"type\">int</span> post_idx;</span><br><span class=\"line\">    Map&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">helper</span><span class=\"params\">(<span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rootval</span> <span class=\"operator\">=</span> postorder[post_idx];</span><br><span class=\"line\">        post_idx--;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(rootval);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> map.get(rootval);</span><br><span class=\"line\">        root.right = helper(index + <span class=\"number\">1</span>, right);<span class=\"comment\">//注意这里有需要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。</span></span><br><span class=\"line\">        root.left = helper(left, index - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">buildTree</span><span class=\"params\">(<span class=\"type\">int</span>[] inorder, <span class=\"type\">int</span>[] postorder)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.inorder = inorder;<span class=\"comment\">//使用this关键字指成员变量的值</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.postorder = postorder;</span><br><span class=\"line\">        post_idx = postorder.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">idx</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Integer val : inorder) &#123;</span><br><span class=\"line\">            map.put(val, idx++);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(<span class=\"number\">0</span>, inorder.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"654-最大二叉树-medium\"><a href=\"#654-最大二叉树-medium\" class=\"headerlink\" title=\"654 最大二叉树 medium\"></a>654 最大二叉树 medium</h3><p>首先就是找到最大的值的下标，然后切成左边和右边，用前序遍历递归构造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">左闭右闭区间，和上面的106题目一样</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> construct(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">construct</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l &gt; r) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//这里是大于</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max_i</span> <span class=\"operator\">=</span> max(nums, l ,r);<span class=\"comment\">//每次递归都要重新找最大值的下标</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(nums[max_i]);<span class=\"comment\">//前序构造二叉树</span></span><br><span class=\"line\">        root.left = construct(nums, l , max_i - <span class=\"number\">1</span>);<span class=\"comment\">//这里是-1</span></span><br><span class=\"line\">        root.right = construct(nums, max_i + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max_i</span> <span class=\"operator\">=</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> l; i &lt;= r; i++) &#123;<span class=\"comment\">//这里是小于等于</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[max_i] &lt; nums[i]) &#123;</span><br><span class=\"line\">                max_i = i; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">左闭右开区间，这里我觉得不如左闭右开区间好记</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">constructMaximumBinaryTree</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> construct(nums, <span class=\"number\">0</span>, nums.length);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">construct</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l == r) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max_i</span> <span class=\"operator\">=</span> max(nums, l ,r);<span class=\"comment\">//每次递归都要重新找最大值的下标</span></span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(nums[max_i]);<span class=\"comment\">//前序构造二叉树</span></span><br><span class=\"line\">        root.left = construct(nums, l , max_i);<span class=\"comment\">//注意这里还是max_i</span></span><br><span class=\"line\">        root.right = construct(nums, max_i + <span class=\"number\">1</span>, r);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">max</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max_i</span> <span class=\"operator\">=</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> l; i &lt; r; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[max_i] &lt; nums[i]) &#123;</span><br><span class=\"line\">                max_i = i; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max_i;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"617-合并二叉树-easy\"><a href=\"#617-合并二叉树-easy\" class=\"headerlink\" title=\"617 合并二叉树 easy\"></a>617 合并二叉树 easy</h3><p>总体比较简单，看递归的返回值处理，其实就是两个二叉树覆盖在一起,思路就是重新构造一个二叉树。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">mergeTrees</span><span class=\"params\">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root1 == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root2;<span class=\"comment\">//root1空就返回root2</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root2 == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">val</span> <span class=\"operator\">=</span> root1.val + root2.val;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);</span><br><span class=\"line\">        root.left = mergeTrees(root1.left, root2.left);</span><br><span class=\"line\">        root.right = mergeTrees(root1.right, root2.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"700-二叉搜索树的搜索-easy\"><a href=\"#700-二叉搜索树的搜索-easy\" class=\"headerlink\" title=\"700 二叉搜索树的搜索 easy\"></a>700 二叉搜索树的搜索 easy</h3><p>需要注意的是，在递归的时候是用return，另外要了解搜索树的构造。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">也可以写成</span></span><br><span class=\"line\"><span class=\"comment\">        if (root == null) return null;</span></span><br><span class=\"line\"><span class=\"comment\">        if (root.val == val) return root;</span></span><br><span class=\"line\"><span class=\"comment\">这里是思路就是根据二叉搜索树的特点，找到了就返回root，如果大于就递归左子树，小于就递归右子树</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span> || root.val == val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchBST(root.val &gt; val ? root.left: root.right, val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个感觉代码上不够简洁</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">searchBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span> || root.val == val) <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; val) <span class=\"keyword\">return</span> searchBST(root.right, val);<span class=\"comment\">//这里是用return，当前节点小，就要去右子树查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; val) <span class=\"keyword\">return</span> searchBST(root.left, val);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//最后是返回null</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"98-验证二叉搜索树-medium\"><a href=\"#98-验证二叉搜索树-medium\" class=\"headerlink\" title=\"98 验证二叉搜索树 medium\"></a>98 验证二叉搜索树 medium</h3><p>第二次做又忘记，二叉搜索树中序遍历是升序的，根据这个特性来完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> Long.MIN_VALUE;<span class=\"comment\">//重要！注意前面声明是long而不是Long</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidBST</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isValidBST(root.left)) &#123;<span class=\"comment\">//如果左边有false，就返回false</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt;= pre) &#123;<span class=\"comment\">//不符合二叉搜索树的定义</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = root.val;<span class=\"comment\">//记录上一个遍历的节点</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> isValidBST(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面这个代码只是为了说明pre的位置也很重要，这个代码更好理解</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">long</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> Long.MIN_VALUE;<span class=\"comment\">//重要！注意前面声明是long而不是Long</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isValidBST</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> isValidBST(root.left);</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//如果pre = root.val写在这里，又会覆盖掉，导致无法判断下面</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt;= pre) &#123;<span class=\"comment\">//关键部分，如果根比左边小，就肯定不符合了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        pre = root.val;<span class=\"comment\">//记录上一个遍历的节点</span></span><br><span class=\"line\">        <span class=\"type\">boolean</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> isValidBST(root.right);</span><br><span class=\"line\">        <span class=\"comment\">//如果放到这里是出错的 pre = root.val;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> l &amp;&amp; r;<span class=\"comment\">//左右都是true才能返回true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">下面重点来解释</span><br><span class=\"line\">首先利用二叉搜索树升序的特性来做，也就是左子树&lt;根&lt;右子树</span><br><span class=\"line\">所以递归顺序是左根右</span><br><span class=\"line\"></span><br><span class=\"line\">先说第一个<span class=\"type\">long</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> Long.MIN_VALUE;</span><br><span class=\"line\">为什么不用<span class=\"type\">int</span>，因为测试案例的原因，不解释了</span><br><span class=\"line\">这里主要解释为什么要用min，因为后台测试数据中有<span class=\"type\">int</span>最小值，也就是有极端情况</span><br><span class=\"line\">有这个案例：[-<span class=\"number\">2147483648</span>]这个是<span class=\"type\">int</span>的最小值，如果你的pre随便设置，最后结果是<span class=\"literal\">false</span>，但是其实这个也算二叉搜索树，因为递归过程中会比较pre和root.val，你的pre这时候是大于val的，所以会<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">第二个重点解释 pre = root.val;的位置问题，如果根据第二个解答写在r的下面</span><br><span class=\"line\">对于[<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"literal\">null</span>,<span class=\"literal\">null</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>]案例是错误的答案，输出是<span class=\"literal\">true</span>，但是实际上是<span class=\"literal\">false</span></span><br><span class=\"line\">画出这个二叉树，可以发现右子树中是出现一个<span class=\"number\">3</span>，二叉搜索树的定义是根要比所有的右子树都小，你现在根比右边大，就是不合理的。</span><br><span class=\"line\">所以进入右边之前，要保存上一个root的val，但是其实我觉得还有一个理解就是递归顺序就是左-根-右，这个pre其实就是递归到根的情况</span><br><span class=\"line\">这样才可以用中序遍历 左边小于右边来比较</span><br></pre></td></tr></table></figure>\n<h3 id=\"530-二叉搜索树的最小绝对差-medium\"><a href=\"#530-二叉搜索树的最小绝对差-medium\" class=\"headerlink\" title=\"530 二叉搜索树的最小绝对差 medium\"></a>530 二叉搜索树的最小绝对差 medium</h3><p>根据二叉搜索树的定义，用中序遍历完成。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个自己写的，可能有些不够简练,但是好记</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMinimumDifference</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;Integer&gt;();</span><br><span class=\"line\">        traversal(root, result);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">res</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.size() - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            res = Math.min(res, result.get(i + <span class=\"number\">1</span>) - result.get(i));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        traversal(root.left, result);</span><br><span class=\"line\">        result.add(root.val);</span><br><span class=\"line\">        traversal(root.right, result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面这个代码更精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    TreeNode pre;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">getMinimumDifference</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        traversal(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode root)</span> &#123;<span class=\"comment\">//使用中序遍历，和上一个题类似哦</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        traversal(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pre != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            result = Math.min(result, root.val - pre.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = root;<span class=\"comment\">//记录上一个节点</span></span><br><span class=\"line\">        traversal(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"501-二叉搜索树的众数-easy\"><a href=\"#501-二叉搜索树的众数-easy\" class=\"headerlink\" title=\"501 二叉搜索树的众数 easy\"></a>501 二叉搜索树的众数 easy</h3><p>用了中序遍历，也是利用二叉搜索树的性质，中序遍历是按照顺序升序的，主要是理解处理的逻辑。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">和98题结合看，一样是用中序的逻辑和pre，但是这里的pre初始化是null，和98的不一样</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">TreeNode</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">maxcount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] findMode(TreeNode root) &#123;</span><br><span class=\"line\">        traversal(root);</span><br><span class=\"line\">        <span class=\"type\">int</span> result[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[list.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class=\"line\">            result[i] = list.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">traversal</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"><span class=\"comment\">//左</span></span><br><span class=\"line\">        traversal(root.left);</span><br><span class=\"line\"><span class=\"comment\">//根</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pre != <span class=\"literal\">null</span> &amp;&amp; pre.val != root.val) &#123;</span><br><span class=\"line\">            count = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt; maxcount) &#123;</span><br><span class=\"line\">            list.clear();<span class=\"comment\">//删除动态数组中的所有元素</span></span><br><span class=\"line\">            list.add(root.val);<span class=\"comment\">//第二次写的时候忘记这里的逻辑</span></span><br><span class=\"line\">            maxcount = count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count == maxcount)&#123;</span><br><span class=\"line\">            list.add(root.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre = root;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//右</span></span><br><span class=\"line\">        traversal(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"236-二叉树的最近公共祖先-medium\"><a href=\"#236-二叉树的最近公共祖先-medium\" class=\"headerlink\" title=\"236 二叉树的最近公共祖先 medium\"></a>236 二叉树的最近公共祖先 medium</h3><p>这个题需要好好看卡哥的讲解。这里容易漏掉一种情况，就是p是q的祖先，或者反过来，第二次看这个题还是没有想到为什么用后序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">需要从小到上，也就是先获取叶子节点，所以后序遍历</span></span><br><span class=\"line\"><span class=\"comment\">用递归的解法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span> || root == p || root == q) &#123;<span class=\"comment\">//第二次写居然写成p == null，q == null，还是理解不到位，这里要理解为如果找到了 节点p或者q，或者遇到空节点，就返回。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;<span class=\"comment\">//注意不是返回null</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span> &amp;&amp; right == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 若未找到节点 p 或 q</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left != <span class=\"literal\">null</span> &amp;&amp; right == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 若找到一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (left == <span class=\"literal\">null</span> &amp;&amp; right != <span class=\"literal\">null</span>) &#123;<span class=\"comment\">// 若找到一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 若找到两个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"235-二叉搜索树的最近公共祖先-easy\"><a href=\"#235-二叉搜索树的最近公共祖先-easy\" class=\"headerlink\" title=\"235 二叉搜索树的最近公共祖先 easy\"></a>235 二叉搜索树的最近公共祖先 easy</h3><p>用上面一个代码也是可以的，不过我们可以利用二叉搜索树的性质来完成。也就是如果root的值都小于p和q，那就去右区间找，如果都大于就在左区间找，如果在p和q的区间内，说明找到，就返回root。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class=\"keyword\">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class=\"keyword\">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"701-二叉搜索树中的插入操作-medium\"><a href=\"#701-二叉搜索树中的插入操作-medium\" class=\"headerlink\" title=\"701 二叉搜索树中的插入操作 medium\"></a>701 二叉搜索树中的插入操作 medium</h3><p>利用二叉搜索树的性质来插入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">insertIntoBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> val)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//找到插入节点的位置了，并把插入的节点返回</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(val);<span class=\"comment\">//第二次做手误写成root.val</span></span><br><span class=\"line\">            <span class=\"comment\">/*或者写成这样</span></span><br><span class=\"line\"><span class=\"comment\">            TreeNode node = new TreeNode(val);</span></span><br><span class=\"line\"><span class=\"comment\">            return node;</span></span><br><span class=\"line\"><span class=\"comment\">            */</span>    </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; val) &#123;</span><br><span class=\"line\">            root.right = insertIntoBST(root.right, val);<span class=\"comment\">// 第二次做居然写成return了</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &gt; val) &#123;</span><br><span class=\"line\">            root.left = insertIntoBST(root.left, val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//一直容易忘记这个</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"450-删除二叉搜索树中的节点-medium\"><a href=\"#450-删除二叉搜索树中的节点-medium\" class=\"headerlink\" title=\"450 删除二叉搜索树中的节点 medium\"></a>450 删除二叉搜索树中的节点 medium</h3><p>有点难度的题，下面有具体解释。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">deleteNode</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//情况1</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; key) &#123;</span><br><span class=\"line\">            root.left = deleteNode(root.left, key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &lt; key) &#123;</span><br><span class=\"line\">            root.right = deleteNode(root.right, key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val == key) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span> &amp;&amp; root.right == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//情况2</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.right == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root.left;<span class=\"comment\">//情况3</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root.left == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> root.right;<span class=\"comment\">//情况4</span></span><br><span class=\"line\">            <span class=\"type\">TreeNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> root.right;<span class=\"comment\">//情况5</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (temp.left != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                temp = temp.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root.val = temp.val;</span><br><span class=\"line\">            root.right = deleteNode(root.right, temp.val);<span class=\"comment\">//因为这个节点是root的右孩子中，所以用root的右孩子作为新root，同时删除这个节点原来的位置。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;<span class=\"comment\">//最后别忘了返回root</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">一共五种情况</span><br><span class=\"line\"><span class=\"number\">1.</span>没找到删除的节点，直接返回<span class=\"literal\">null</span></span><br><span class=\"line\">然后开始搜索正确的位置，找到节点的情况</span><br><span class=\"line\"><span class=\"number\">2.</span>左右孩子都是空的，返回<span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"number\">3.</span>右孩子空，把左孩子补上去</span><br><span class=\"line\"><span class=\"number\">4.</span>左孩子空，把有孩子补上去</span><br><span class=\"line\"><span class=\"number\">5.</span>有左右孩子，这个情况最复杂，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点，下面详细讲操作。</span><br><span class=\"line\"></span><br><span class=\"line\">先找到这个key的右孩子，然后一直找这个右孩子的最左边的孩子，这时候就顺便把这个孩子的节点值设为root，然后递归删除这个值。</span><br></pre></td></tr></table></figure>\n<h3 id=\"669-修剪二叉搜索树-medium\"><a href=\"#669-修剪二叉搜索树-medium\" class=\"headerlink\" title=\"669 修剪二叉搜索树 medium\"></a>669 修剪二叉搜索树 medium</h3><p>把范围之外的节点清除。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">在边界范围外的，好好看看下面的注释，为什么要return,和上一题对比</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span>    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"type\">int</span> low, <span class=\"type\">int</span> high)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//第二次做的时候漏了，任何情况都要考虑空</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &lt; low) &#123;<span class=\"comment\">//不在范围内的节点，需要继续寻找。小于val，就去右边区间寻找，抛弃其左子树整体。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> trimBST(root.right, low, high);<span class=\"comment\">// 如果当前结点小于下界，直接将修剪后的右子树替换当前节点并返回，所以要return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.val &gt; high) &#123;<span class=\"comment\">//不在范围内的节点，需要继续寻找。大于val，就去左边区间寻找，抛弃其右子树整体。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> trimBST(root.left, low, high); <span class=\"comment\">// 如果当前结点大于上界，直接将修剪后的左子树替换当前节点并返回</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果数字在区间内,就去裁剪左右子节点</span></span><br><span class=\"line\">        root.left = trimBST(root.left, low, high);</span><br><span class=\"line\">        root.right = trimBST(root.right, low, high);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"108-将有序数组转换为二叉搜索树-easy\"><a href=\"#108-将有序数组转换为二叉搜索树-easy\" class=\"headerlink\" title=\"108 将有序数组转换为二叉搜索树 easy\"></a>108 将有序数组转换为二叉搜索树 easy</h3><p>可以对比下构造二叉树那个题。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">sortedArrayToBST</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> bst(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);<span class=\"comment\">//因为下面的递归是用左闭右闭区间，所以长度-1。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">bst</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;<span class=\"comment\">//左闭右闭的区间，所以当区间 left &gt; right的时候，就是空节点了</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> left + (right - left) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">TreeNode</span> <span class=\"variable\">root</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TreeNode</span>(nums[mid]);<span class=\"comment\">//构造中间节点</span></span><br><span class=\"line\">        <span class=\"comment\">//然后构造两边</span></span><br><span class=\"line\">        root.left = bst(nums, left, mid - <span class=\"number\">1</span>);<span class=\"comment\">//mid已经用了，所以要减1</span></span><br><span class=\"line\">        root.right = bst(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"538-把二叉搜索树转换为累加树-medium\"><a href=\"#538-把二叉搜索树转换为累加树-medium\" class=\"headerlink\" title=\"538 把二叉搜索树转换为累加树 medium\"></a>538 把二叉搜索树转换为累加树 medium</h3><p>这个先看定义，就是使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。中序遍历是升序，这样不方便累加，要从后往前，也就是中反的中序遍历，右中左。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//定义sum</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> TreeNode <span class=\"title function_\">convertBST</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        convertBST(root.right);</span><br><span class=\"line\">        sum += root.val;</span><br><span class=\"line\">        root.val = sum;<span class=\"comment\">//这个很关键</span></span><br><span class=\"line\">        convertBST(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><p>一般用于组合，切割，子集，排列，棋盘问题。<br>回溯三部曲<br>1.回溯函数模板返回值以及参数，返回值一般为void<br>2.回溯终止条件<br>3.回溯遍历过程<br>回溯模板</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">backtracking</span><span class=\"params\">(参数)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (终止条件) &#123;</span><br><span class=\"line\">        存放结果;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<span class=\"comment\">//for可以理解为横向遍历</span></span><br><span class=\"line\">        处理节点;</span><br><span class=\"line\">        backtracking(路径，选择列表); <span class=\"comment\">// 递归，递归可以理解为纵向遍历</span></span><br><span class=\"line\">        回溯，撤销处理结果</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">关于剪枝操作，这是卡哥原话</span><br><span class=\"line\">剪枝精髓是：<span class=\"keyword\">for</span>循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。</span><br></pre></td></tr></table></figure>\n<h3 id=\"77-组合-medium\"><a href=\"#77-组合-medium\" class=\"headerlink\" title=\"77 组合 medium\"></a>77 组合 medium</h3><p>注意取过的数字不再取，也就是没有(4,4)这种情况，组合是无序(也就是(1,2)和(2,1)是一样的，取一个就可以)，排列是有序(两个答案都要)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这个代码没有进行剪枝处理</span></span><br><span class=\"line\"><span class=\"comment\">返回范围 [1, n] 中所有可能的 k 个数的组合</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combine</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        backtrack(n, k ,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;<span class=\"comment\">//return语句后不带返回值，作用是退出该程序的运行，终止本层的递归</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt;= n; i++) &#123;<span class=\"comment\">//startindex是为了让程序知道从哪个数字开始取，不能重复的，for (int i = startindex; i &lt;= n - (k - path.size()) + 1; i++)这是剪枝处理</span></span><br><span class=\"line\">            path.add(i);<span class=\"comment\">//把这个数字加进去</span></span><br><span class=\"line\">            backtrack(n, k, i + <span class=\"number\">1</span>);<span class=\"comment\">//递归开始，纵向遍历</span></span><br><span class=\"line\">            path.removeLast();<span class=\"comment\">//把这个数字取出来，再加其他数字，比如原来[1,2]，然后把2取出来，把3加进去，就有[1,3]</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">注意这个才有removeLast的操作，arraylist是没有的。</span><br><span class=\"line\">对剪枝的理解</span><br><span class=\"line\">比如 n = <span class=\"number\">7</span>, k = <span class=\"number\">4</span>，那么从 <span class=\"number\">5</span> 开始搜索就已经没有意义了，这是因为即使把 <span class=\"number\">5</span> 选上，后面的数只有 <span class=\"number\">6</span> 和 <span class=\"number\">7</span>，一共就 <span class=\"number\">3</span> 个候选数，凑不出 <span class=\"number\">4</span> 个数的组合。因此，搜索起点有上界。 </span><br></pre></td></tr></table></figure>\n<h3 id=\"216-组合总和-III-medium\"><a href=\"#216-组合总和-III-medium\" class=\"headerlink\" title=\"216 组合总和 III medium\"></a>216 组合总和 III medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">找出所有相加之和为 n 的 k 个数的组合，只使用数字1到9，每个数字 最多使用一次 </span></span><br><span class=\"line\"><span class=\"comment\">和上一题的区别是，这个题的n的目标数，潜在的范围其实是[1,9]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum3</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        backtrack(k, n, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减枝，这句话没有也是可以通过的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n == sum) &#123;</span><br><span class=\"line\">                result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt;= <span class=\"number\">9</span>; i++)&#123;</span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            backtrack(k, n, sum + i, i + <span class=\"number\">1</span>);<span class=\"comment\">//和下面解法的区别</span></span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum3</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        backtrack(k, n, <span class=\"number\">0</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span> n, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 减枝，这句话没有也是可以通过的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum &gt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == k) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n == sum) &#123;</span><br><span class=\"line\">                result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt;= <span class=\"number\">9</span>; i++)&#123;<span class=\"comment\">//这里也可以进行剪枝</span></span><br><span class=\"line\">            path.add(i);</span><br><span class=\"line\">            sum += i;<span class=\"comment\">//最开始是看到这个写法，后面看到更简洁，就更新了，我觉得和上一个解法的区别是在递归的时候sum有i去控制大小，而这里没有，所以递归后还要减掉。</span></span><br><span class=\"line\">            backtrack(k, n, sum, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">            sum -= i;<span class=\"comment\">//这里是容易忘记的，因为你回溯，务必减去上一个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"17-电话号码的字母组合-medium\"><a href=\"#17-电话号码的字母组合-medium\" class=\"headerlink\" title=\"17 电话号码的字母组合 medium\"></a>17 电话号码的字母组合 medium</h3><p>这个题和上一题的区别是，这个题相当于多个区间进行取值，而上个题是一个区间内。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">letterCombinations</span><span class=\"params\">(String digits)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (digits == <span class=\"literal\">null</span> || digits.length() == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        String[] numString = &#123;<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;&quot;</span>,<span class=\"string\">&quot;abc&quot;</span>,<span class=\"string\">&quot;def&quot;</span>,<span class=\"string\">&quot;ghi&quot;</span>,<span class=\"string\">&quot;jkl&quot;</span>,<span class=\"string\">&quot;mno&quot;</span>,<span class=\"string\">&quot;pqrs&quot;</span>,<span class=\"string\">&quot;tuv&quot;</span>,<span class=\"string\">&quot;wxyz&quot;</span>&#125;;<span class=\"comment\">//这是为了对应2~9，特意空出两个字符</span></span><br><span class=\"line\">        backtrack(numString, digits, <span class=\"number\">0</span>);<span class=\"comment\">//这个0，是获取第一个digits的数字用的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">StringBuilder</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(String[] numString, String digits, <span class=\"type\">int</span> num)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (num == digits.length()) &#123;<span class=\"comment\">//这个条件也是不一样的，因为在循环数字</span></span><br><span class=\"line\">            result.add(temp.toString());</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> numString[digits.charAt(num) - <span class=\"string\">&#x27;0&#x27;</span>];<span class=\"comment\">//先把这个数字对应的字母取出来</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; str.length(); i++) &#123;<span class=\"comment\">//这就是和上题的区别，i=0，是这个区间的开始，而上一个题的同一个区间，所以要找下一个数</span></span><br><span class=\"line\">            temp.append(str.charAt(i));<span class=\"comment\">//这里是append</span></span><br><span class=\"line\">            backtrack(numString, digits, num + <span class=\"number\">1</span>);</span><br><span class=\"line\">            temp.deleteCharAt(temp.length() - <span class=\"number\">1</span>);<span class=\"comment\">//还有这个用法</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"39-组合总和-medium\"><a href=\"#39-组合总和-medium\" class=\"headerlink\" title=\"39 组合总和 medium\"></a>39 组合总和 medium</h3><p>结合216来看，和216的区别是，这里给了一个数组的范围，其次，数组元素的可以重复使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;(); </span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);<span class=\"comment\">//排序很重要</span></span><br><span class=\"line\">        backtrack(candidates, target, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> idx)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> idx; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum + candidates[i] &gt; target) <span class=\"keyword\">break</span>;<span class=\"comment\">//没有这句也是报错的，如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class=\"line\">            path.add(candidates[i]);</span><br><span class=\"line\">            backtrack(candidates, target, sum + candidates[i], i);<span class=\"comment\">//这里不是i + 1，就体现了可以重复使用这个数组的思想</span></span><br><span class=\"line\">            path.removeLast(); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"40-组合总和-II-medium-1\"><a href=\"#40-组合总和-II-medium-1\" class=\"headerlink\" title=\"40 组合总和 II medium\"></a>40 组合总和 II medium</h3><p>这里实际上要完成两个任务，一个是不能有重复元素(是指这个数组中不能重复用这个数，但是数组本身是可以有重复是数字的，比如这个数组可以存在两个1，但是每个1只能用一次)，第二个是不能有重复组合。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">解决不能有重复组合，需要在for中进行去除，也就是对每层的处理</span></span><br><span class=\"line\"><span class=\"comment\">解决不能重复数字以前则遇到过，在回溯的时候，i＋1即可。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">combinationSum2</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(candidates);</span><br><span class=\"line\">        backtrack(candidates, target, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] candidates, <span class=\"type\">int</span> target, <span class=\"type\">int</span> sum, <span class=\"type\">int</span> idx)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum == target) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> idx; i &lt; candidates.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; idx &amp;&amp; candidates[i - <span class=\"number\">1</span>] == candidates[i]) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;<span class=\"comment\">//这里就是重复组合的问题</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sum + candidates[i] &gt; target) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            path.add(candidates[i]);</span><br><span class=\"line\">            backtrack(candidates, target, sum + candidates[i], i + <span class=\"number\">1</span>);<span class=\"comment\">//i+1解决重复元素的问题</span></span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"131-分割回文串-medium\"><a href=\"#131-分割回文串-medium\" class=\"headerlink\" title=\"131 分割回文串 medium\"></a>131 分割回文串 medium</h3><p>回文串 是正着读和反着读都一样的字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    LinkedList&lt;String&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    List&lt;List&lt;String&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;String&gt;&gt; <span class=\"title function_\">partition</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        backtrack(s,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(String s, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (startindex == s.length()) &#123;<span class=\"comment\">//切割线到了最后作为终止条件</span></span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ishuiwen(s, startindex, i)) &#123;<span class=\"comment\">//这里已经判断了是否回文，所以在上面终止条件直接添加结果即可</span></span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> s.substring(startindex, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">                path.add(str);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            backtrack(s, i + <span class=\"number\">1</span>);<span class=\"comment\">//因为也是不能往回走，所以+1</span></span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">ishuiwen</span><span class=\"params\">(String s, <span class=\"type\">int</span> startindex, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex, j = end; i &lt; j; i++, j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先我们要明白startindex的作用就是相当于切割线的作用</span><br><span class=\"line\">这个题的<span class=\"keyword\">for</span>循环是切了第一根线（横向），然后回溯递归的过程是纵向（切第二跟线），这样可以实现切割不同字符串的效果。</span><br><span class=\"line\">那么又有一个疑问，为什么是两条线，因为第一条线固定第一个位置，然后第二根线是一个个位置继续切。</span><br><span class=\"line\"></span><br><span class=\"line\">问题<span class=\"number\">1</span>：为什么回溯结束条件是<span class=\"keyword\">if</span> (startindex == s.length())</span><br><span class=\"line\">当切割线到了最后，说明后面不能再切了，所以这里要设置结束条件并添加结果。</span><br><span class=\"line\">可是，这里没有判断回文呀？</span><br><span class=\"line\">其实不是的，下面<span class=\"keyword\">for</span>循环的时候，已经判断回文，如果不是回文的话，不参加递归，所以，只要参加了递归，就一定是回文。</span><br><span class=\"line\"></span><br><span class=\"line\">这个题要好好看卡哥的画图，可以理解这个切割线。</span><br><span class=\"line\"></span><br><span class=\"line\">substring(start,end)是左开右闭，也就是end序号是没有截取到了，而我们判断回本的时候，end是参与了判断的，所以这里要加<span class=\"number\">1</span>让这个字符串截取到。</span><br></pre></td></tr></table></figure>\n<h3 id=\"93-复原ip地址-medium\"><a href=\"#93-复原ip地址-medium\" class=\"headerlink\" title=\"93 复原ip地址 medium\"></a>93 复原ip地址 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title function_\">restoreIpAddresses</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        backtrack(s, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(String s, <span class=\"type\">int</span> startindex, <span class=\"type\">int</span> pointnum)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pointnum == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isvalid(s, startindex, s.length() - <span class=\"number\">1</span>)) &#123;<span class=\"comment\">//逗点已经写了3个，也就是切成了4份，最后再判断完第四个区间即可</span></span><br><span class=\"line\">                result.add(s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (isvalid(s, startindex, i)) &#123;<span class=\"comment\">//substring是左开右闭</span></span><br><span class=\"line\">                s = s.substring(<span class=\"number\">0</span>, i + <span class=\"number\">1</span>) + <span class=\"string\">&quot;.&quot;</span> + s.substring(i + <span class=\"number\">1</span>);<span class=\"comment\">//在str的后⾯插⼊⼀个逗点</span></span><br><span class=\"line\">                pointnum++;<span class=\"comment\">//记录逗点个数</span></span><br><span class=\"line\">                backtrack(s, i + <span class=\"number\">2</span>, pointnum);<span class=\"comment\">//插⼊逗点之后下⼀个⼦串的起始位置为i+2</span></span><br><span class=\"line\">                pointnum--;<span class=\"comment\">//回溯的时候恢复</span></span><br><span class=\"line\">                s = s.substring(<span class=\"number\">0</span>, i + <span class=\"number\">1</span>) + s.substring(i + <span class=\"number\">2</span>);<span class=\"comment\">//回溯除去逗点</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;<span class=\"comment\">//continue也可以</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isvalid</span><span class=\"params\">(String s, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start &gt; end) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s.charAt(start) == <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;<span class=\"comment\">// start != end是为了这个条件：当[0,0,0,0]，单独传入一个0就是start等于end，所以也可以写成start&lt;end</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">num</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span>  <span class=\"variable\">i</span> <span class=\"operator\">=</span> start; i &lt;= end; i++) &#123;<span class=\"comment\">//这里的end注意下，是&lt;=哦</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) &lt; <span class=\"string\">&#x27;0&#x27;</span> || s.charAt(i) &gt; <span class=\"string\">&#x27;9&#x27;</span>) &#123;<span class=\"comment\">//这个判断可以省略，案例不存在非法字符</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            num = num * <span class=\"number\">10</span> + (s.charAt(i) - <span class=\"string\">&#x27;0&#x27;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num &gt; <span class=\"number\">255</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//最后返回true也容易忘记</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题和上面题的区别：</span><br><span class=\"line\"><span class=\"number\">1.</span>没有path变量</span><br><span class=\"line\">这个题从头到尾都需要整个s，而之前的题目的类似于从里面选若干个元素。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>ip有效判断</span><br><span class=\"line\">首先最主要的判断是区间必须是左小右大，也就是start&gt;end是非法的</span><br><span class=\"line\">first：<span class=\"number\">0</span>开头的数字不合法，但是如果单独<span class=\"number\">0</span>的话是可以的，比如[<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">second：遇到⾮数字字符不合法（这个可以不需要，因为案例中都是数字）</span><br><span class=\"line\">third：大于<span class=\"number\">255</span>的不合法</span><br></pre></td></tr></table></figure>\n<h3 id=\"78-子集-medium\"><a href=\"#78-子集-medium\" class=\"headerlink\" title=\"78 子集 medium\"></a>78 子集 medium</h3><p>和77的区别是这个是回溯的if条件的不同，这里是小于等于，还有就是不能有return。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsets</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        backtrack(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() &lt;= nums.length) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"comment\">//这里不能写return;否则出错，有return说明要终止本层的递归，我们要取树上的节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            path.add(nums[i]);</span><br><span class=\"line\">            backtrack(nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"90-子集2-medium\"><a href=\"#90-子集2-medium\" class=\"headerlink\" title=\"90 子集2 medium\"></a>90 子集2 medium</h3><p>遇到这个重复元素的，想都不用想，先排序，然后再处理。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">subsetsWithDup</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        backtrack(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() &lt;= nums.length) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"comment\">//不要有return哦，否则会终止本层递归，我们要取树上的节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; startindex &amp;&amp; nums[i - <span class=\"number\">1</span>] == nums[i]) &#123;<span class=\"comment\">//子集不能有重复的</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.add(nums[i]);</span><br><span class=\"line\">            backtrack(nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"491-递增子序列-medium\"><a href=\"#491-递增子序列-medium\" class=\"headerlink\" title=\"491 递增子序列 medium\"></a>491 递增子序列 medium</h3><p>这个题不能排序，要用到原数组的顺序，所以可能会出现[4,6,4,7]这种数组，所以上一题子集不能重复的代码思想不能用到，要用map要判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">findSubsequences</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        backtrack(nums, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() &gt; <span class=\"number\">1</span>) &#123;<span class=\"comment\">//因为是递增子集，所以必须要有至少两个数才可以</span></span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();<span class=\"comment\">//for循环中用map来记录使用过的数字次数，避免最后由重复子集。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//满足递增子集，所以上一个数要是大于下一个数就去掉，还有就是这个数有重复用也去掉</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.getLast() || map.getOrDefault(nums[i], <span class=\"number\">0</span>) &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);<span class=\"comment\">//用了这个数就加1</span></span><br><span class=\"line\">            path.add(nums[i]);</span><br><span class=\"line\">            backtrack(nums, i + <span class=\"number\">1</span>);<span class=\"comment\">//i+1纵向遍历不能重复的</span></span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">            <span class=\"comment\">//这里不需要map减去之前用过的数哦，我的理解是这个主要是因为用在for循环的横向遍历中，要是这里减1会出现重复的子集，可以对比下target那些题。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>if条件也可以写成这样</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> startindex)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (path.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.getLast()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (map.getOrDefault(nums[i], <span class=\"number\">0</span>) &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;<span class=\"comment\">//这里是区别哦</span></span><br><span class=\"line\"></span><br><span class=\"line\">        map.put(nums[i], map.getOrDefault(nums[i], <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        path.add(nums[i]);</span><br><span class=\"line\">        backtrack(nums, i + <span class=\"number\">1</span>);</span><br><span class=\"line\">        path.removeLast();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"46-全排列-medium\"><a href=\"#46-全排列-medium\" class=\"headerlink\" title=\"46 全排列 medium\"></a>46 全排列 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path= <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permute</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        backtrack(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;<span class=\"comment\">//和组合的区别1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (path.contains(nums[i])) &#123;<span class=\"comment\">//和组合的区别2</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            path.add(nums[i]);</span><br><span class=\"line\">            backtrack(nums);</span><br><span class=\"line\">            path.removeLast();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">讲解组合和排列的区别</span><br><span class=\"line\">组合也就是[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]和[<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]是一样的</span><br><span class=\"line\">而排列则视为他们是两个不同的结果。</span><br><span class=\"line\"></span><br><span class=\"line\">所以在组合问题中使用了startindex来控制横向遍历中的重复元素问题</span><br><span class=\"line\">而排列则不需要，因为我们还会使用以前用过的数字，所以排列的时候，<span class=\"keyword\">for</span>就是全体元素的遍历，但是用过的数是不能用的，所以用path.contains来排除</span><br><span class=\"line\"></span><br><span class=\"line\">这也是组合和排列的区别啦</span><br></pre></td></tr></table></figure>\n<h3 id=\"47-全排列2-medium-1\"><a href=\"#47-全排列2-medium-1\" class=\"headerlink\" title=\"47 全排列2 medium\"></a>47 全排列2 medium</h3><p>这题的数组中可以有重复的数字，那么又如何去重呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">和40题一样的是，需要先进行排序</span></span><br><span class=\"line\"><span class=\"comment\">解决横向遍历中的重复数字i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]也想到了</span></span><br><span class=\"line\"><span class=\"comment\">但是这里是全排列问题，在纵向遍历中会重复，所以这里需要用到一个used的数组</span></span><br><span class=\"line\"><span class=\"comment\">不过这个题不好理解</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    List&lt;List&lt;Integer&gt;&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">    LinkedList&lt;Integer&gt; path = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">boolean</span>[] used;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;List&lt;Integer&gt;&gt; <span class=\"title function_\">permuteUnique</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        used = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(used, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        backtrack(nums);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">backtrack</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path.size() == nums.length) &#123;</span><br><span class=\"line\">            result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(path));</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//used[i -1] == false说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i - <span class=\"number\">1</span>] == nums[i] &amp;&amp; used[i -<span class=\"number\">1</span>] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">//这里的used[i -1] == false也能填true，但是代表两个意思，具体看卡哥解释</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (used[i] == <span class=\"literal\">false</span>) &#123;<span class=\"comment\">//如果同⼀树⽀nums[i]没使⽤过开始处理</span></span><br><span class=\"line\">                used[i] = <span class=\"literal\">true</span>;<span class=\"comment\">//标记</span></span><br><span class=\"line\">                path.add(nums[i]);</span><br><span class=\"line\">                backtrack(nums);</span><br><span class=\"line\">                path.removeLast();</span><br><span class=\"line\">                used[i] = <span class=\"literal\">false</span>;<span class=\"comment\">//取消标记</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"332-重新安排行程-hard\"><a href=\"#332-重新安排行程-hard\" class=\"headerlink\" title=\"332 重新安排行程 hard\"></a>332 重新安排行程 hard</h3><h3 id=\"51-N皇后-hard\"><a href=\"#51-N皇后-hard\" class=\"headerlink\" title=\"51 N皇后 hard\"></a>51 N皇后 hard</h3><h3 id=\"21-解数独-hard\"><a href=\"#21-解数独-hard\" class=\"headerlink\" title=\"21 解数独 hard\"></a>21 解数独 hard</h3><h2 id=\"贪心算法-1\"><a href=\"#贪心算法-1\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><h3 id=\"455-分发饼干-easy\"><a href=\"#455-分发饼干-easy\" class=\"headerlink\" title=\"455 分发饼干 easy\"></a>455 分发饼干 easy</h3><p>思路很简单，一个for循环就行，先排序，小饼干分给小胃口，然后注意越界问题就行。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findContentChildren</span><span class=\"params\">(<span class=\"type\">int</span>[] g, <span class=\"type\">int</span>[] s)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(g);</span><br><span class=\"line\">        Arrays.sort(s);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j &lt; g.length &amp;&amp; s[i] &gt;= g[j]) &#123;<span class=\"comment\">//必须j &lt; g.length放前面，先判断超界问题，这个是可能忘记的，因为饼干数量和小朋友数量不一定是一样的</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"376-摆动序列-medium\"><a href=\"#376-摆动序列-medium\" class=\"headerlink\" title=\"376 摆动序列 medium\"></a>376 摆动序列 medium</h3><p>可动态规划，要明确返回的是原始序列的长度哦，但是这个原始序列不一定就是题目给的全体，可能是子序列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">wiggleMaxLength</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">pre</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;<span class=\"comment\">//初始化是1，至于为什么，可以理解下[1,1]这个数组，最后返回是数量2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;<span class=\"comment\">//从头到尾进行遍历，注意因为要第二个数减去第一个数，所以从1开始</span></span><br><span class=\"line\">            cur = nums[i] - nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((cur &gt; <span class=\"number\">0</span> &amp;&amp; pre &lt;= <span class=\"number\">0</span>) || (cur &lt; <span class=\"number\">0</span> &amp;&amp; pre &gt;= <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">                pre = cur;<span class=\"comment\">//要在if中加，这样才能保留上一个坡，而不是在if外围加</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"53-最大子数组和-medium\"><a href=\"#53-最大子数组和-medium\" class=\"headerlink\" title=\"53 最大子数组和 medium\"></a>53 最大子数组和 medium</h3><p>可动态规划，这里不要太关注数组下标，一开始老想着这个left和right，和209进行一个对比（这个题是算长度，以及人家有目标值），要注意是连续的子区间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> Integer.MIN_VALUE;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            count += nums[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &gt; result) &#123;</span><br><span class=\"line\">                result = count;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                count = <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果 -<span class=\"number\">2</span> <span class=\"number\">1</span> 在一起，计算起点的时候，一定是从<span class=\"number\">1</span>开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</span><br><span class=\"line\"></span><br><span class=\"line\">利用两个数来完成这个题，result来记录最大的值，同时也是结果值，而count是记录区间的值</span><br><span class=\"line\"></span><br><span class=\"line\">我们要知道最大和，意味着我们不能加上负数，否则只会越来越小，而count是记录区间的大小，当区间大小为负数的时候，我们就不要这个区间了，在下个位置重新开始记录初始化为<span class=\"number\">0</span>，在这个过程中一直对比最大值即可。</span><br><span class=\"line\"></span><br><span class=\"line\">和<span class=\"number\">209</span>的区别，<span class=\"number\">209</span>是求最小的长度，而且是有targer的，当和大于等于这个targer后在慢慢看最小的长度，而本题是计算和</span><br></pre></td></tr></table></figure>\n<h3 id=\"122-买卖股票的最佳时机II-medium\"><a href=\"#122-买卖股票的最佳时机II-medium\" class=\"headerlink\" title=\"122 买卖股票的最佳时机II medium\"></a>122 买卖股票的最佳时机II medium</h3><p>可动态规划，贪心思想：局部最优：收集每天的正利润，全局最优：求得最大利润。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            result += Math.max((prices[i] - prices[i - <span class=\"number\">1</span> ]),<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"55-跳跃游戏-medium\"><a href=\"#55-跳跃游戏-medium\" class=\"headerlink\" title=\"55 跳跃游戏 medium\"></a>55 跳跃游戏 medium</h3><p>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canJump</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cover</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//这里是cover是值步数，而这个步数能否覆盖到最后即可判断为true。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= cover; i++) &#123;<span class=\"comment\">//注意这里是cover 不是nums的长度，因为cover初试值是0，所以要小于等于哦</span></span><br><span class=\"line\">            cover = Math.max(i + nums[i], cover);<span class=\"comment\">//cover是会改变的</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cover &gt;= nums.length - <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//cover是对应数组下标，所以nums的长度-1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"45-跳跃游戏2-medium\"><a href=\"#45-跳跃游戏2-medium\" class=\"headerlink\" title=\"45 跳跃游戏2 medium\"></a>45 跳跃游戏2 medium</h3><p>和上一题的区别是这题要算出一个最小的步数，只需要考虑覆盖的范围是不是到最后一个，而本题没那么简单。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">这里解释为什么循环是nums.length - 1而不是nums.length</span></span><br><span class=\"line\"><span class=\"comment\">在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">假设我们就是nums.length，用案例[2,3,1,1,4]</span></span><br><span class=\"line\"><span class=\"comment\">那么最大范围是下标会是 2（第一次可以跳的下标范围） 4（第二次可以跳的下标范围） 8，其实在第二步4的时候已经到了最后了，但是又多跳一步，然后最大范围可以是8，也就是避免刚好到了末尾又跳</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">jump</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//上次跳跃可达范围右边界（下次的最右起跳点）</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">maxcount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//目前能跳到的最远位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//跳跃次数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;<span class=\"comment\">//注意上一题的循环变量是cover</span></span><br><span class=\"line\">            maxcount = Math.max((i + nums[i]), maxcount);<span class=\"comment\">//取最大的范围</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == end) &#123; <span class=\"comment\">// 到达上次跳跃能到达的右边界了</span></span><br><span class=\"line\">                end =  maxcount;<span class=\"comment\">// 目前能跳到的最远位置变成了下次起跳位置的有边界</span></span><br><span class=\"line\">                step++; <span class=\"comment\">// 进入下一次跳跃</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> step;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1005-K-次取反后最大化的数组和-easy\"><a href=\"#1005-K-次取反后最大化的数组和-easy\" class=\"headerlink\" title=\"1005 K 次取反后最大化的数组和 easy\"></a>1005 K 次取反后最大化的数组和 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">思路就是让最小的负数的开始取反(排序)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">如果所有的负数已经取反了，但是k还是大于0，那就让重新排序，让前面小的值来取反，每次都要重新排序</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">最后求和</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">largestSumAfterKNegations</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(nums);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &lt; <span class=\"number\">0</span> &amp;&amp; k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nums[i] = -nums[i];          </span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            Arrays.sort(nums);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; k; i++) &#123;<span class=\"comment\">//小于k哦</span></span><br><span class=\"line\">                nums[i] = -nums[i];</span><br><span class=\"line\">                k--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) &#123;</span><br><span class=\"line\">            result += x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"134-加油站-medium\"><a href=\"#134-加油站-medium\" class=\"headerlink\" title=\"134 加油站 medium\"></a>134 加油站 medium</h3><p>要充分利用贪心的思想。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">思路如下，设置两个变量totalsum和cursum。</span></span><br><span class=\"line\"><span class=\"comment\">totalsum就是全部的加油量减去耗油量，如果大于0，说明是可以跑完一圈的</span></span><br><span class=\"line\"><span class=\"comment\">然后在这个的基础上，我们可以去找开始出发点，利用到cursum，这个变量就是从[i,j]范围内的加油量减去耗油量，如果是负数的话，我们的起始点就设置为下一个数，然后重新计算cursum</span></span><br><span class=\"line\"><span class=\"comment\">我一开始在想的时候，会考虑到cost[i]是去第i+1个的耗油量，cursum里面是计算gas[i]-cost[i]，所以会不会不对应呢，其实不会的</span></span><br><span class=\"line\"><span class=\"comment\">比如gas是[3,4]，cost是[4,2]，你如果在0号，那么cursum就是-1.也就是说当前加的油不够去下一站，所以这个是对应上的，那么这个起始点就不能选择，所以就移动一位检查下一个起始点，务必注意cursum要重新置0。 </span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">canCompleteCircuit</span><span class=\"params\">(<span class=\"type\">int</span>[] gas, <span class=\"type\">int</span>[] cost)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">cursum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">totalsum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class=\"line\">            cursum += gas[i] - cost[i];</span><br><span class=\"line\">            totalsum += gas[i] - cost[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cursum &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                cursum = <span class=\"number\">0</span>;</span><br><span class=\"line\">                start = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (totalsum &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> start;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"135-分发糖果-hard-1\"><a href=\"#135-分发糖果-hard-1\" class=\"headerlink\" title=\"135 分发糖果 hard\"></a>135 分发糖果 hard</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">领悟的关键，更新的时候能不能用上新的值来比较，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">这里需要注意从前往后遍历，需要用右边来对比左边，然后更新右边的值，那么下一次循环再对比，原来右边的值变成左边，这时候再进行右边是否大于左边去更新，因为这时候左边的值是新值，是有意义的</span></span><br><span class=\"line\"><span class=\"comment\">如果我们来更新左边的值，比如左边大于右边，然后更新左边的值，到了下一次循环，下一次的左边是一个旧值，没有意义，我们用不到新的值</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">然后处理完左边循环（右比左大），然后处理从右边开始的循环，左边比右边大，更新左边的值（注意这时候不是右边原来的值加1，不然会破坏原来前序遍历的结果），需要取就取candys[i + 1] + 1 和 candys[i] 最大的糖果数量</span></span><br><span class=\"line\"><span class=\"comment\">比如举个例子[1,3,4,5,2]，前序遍历完后糖果数组是[1,2,3,4,1]，如果你这时候用candys[i+1]+1更新的话，就变成[1,2,3,2,1]，第四个位置就乱套了，所以取他们的最大值即可</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">candy</span><span class=\"params\">(<span class=\"type\">int</span>[] ratings)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] candys =  <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[ratings.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.fill(candys,<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i - <span class=\"number\">1</span>]) &#123;<span class=\"comment\">//右边比左边大</span></span><br><span class=\"line\">                candys[i] = candys[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> ratings.length - <span class=\"number\">2</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ratings[i] &gt; ratings[i + <span class=\"number\">1</span>]) &#123;<span class=\"comment\">//左边比右边大</span></span><br><span class=\"line\">                candys[i] = Math.max(candys[i], candys[i + <span class=\"number\">1</span>] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : candys) &#123;</span><br><span class=\"line\">            result += x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"860-柠檬树找零-easy\"><a href=\"#860-柠檬树找零-easy\" class=\"headerlink\" title=\"860 柠檬树找零 easy\"></a>860 柠檬树找零 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">别看代码特多逻辑判断，其实很简单，就三种情况</span></span><br><span class=\"line\"><span class=\"comment\">1.付款5元的，直接收取，记录5元张数</span></span><br><span class=\"line\"><span class=\"comment\">2.付款10元的，只能找5元，记录10元张数，同时找5元（减张数），如果不够找，直接返回false</span></span><br><span class=\"line\"><span class=\"comment\">3.付款20元的，可以找10元和5元的，也可以纯5元的，这时候就判断够不够找，不够也返回false</span></span><br><span class=\"line\"><span class=\"comment\">最后别忘了返回true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lemonadeChange</span><span class=\"params\">(<span class=\"type\">int</span>[] bills)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">five</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">ten</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">twenty</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//其实也可以不用这个参数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class=\"line\">            temp = bills[i] / <span class=\"number\">5</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temp == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                five++;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (temp == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (five &lt; <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                ten++;</span><br><span class=\"line\">                five--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                twenty++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ten &gt; <span class=\"number\">0</span> &amp;&amp; five &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    ten--;</span><br><span class=\"line\">                    five--;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (five &gt;= <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">                    five = five - <span class=\"number\">3</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"406-根据身高重建队列-medium-1\"><a href=\"#406-根据身高重建队列-medium-1\" class=\"headerlink\" title=\"406 根据身高重建队列 medium\"></a>406 根据身高重建队列 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">思想就是先排序（高到低排），再插队（下标就是插入的位置），至于为什么，这是贪心的思想，数学证明很难哦，局部最优做到总体最优，矮个子排在哪都对高个子没有影响，但是高个子排在矮个子前面就会造成影响。所以，矮个子要主动选择位置</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] reconstructQueue(<span class=\"type\">int</span>[][] people) &#123;</span><br><span class=\"line\">        Arrays.sort(people,(a, b) -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>]) <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        );<span class=\"comment\">//这里有分号</span></span><br><span class=\"line\">        LinkedList&lt;<span class=\"type\">int</span>[]&gt; que = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span>[] p : people) &#123;<span class=\"comment\">//这里是people哦</span></span><br><span class=\"line\">            que.add(p[<span class=\"number\">1</span>],p);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[people.length][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入是[[<span class=\"number\">7</span>,<span class=\"number\">0</span>],[<span class=\"number\">4</span>,<span class=\"number\">4</span>],[<span class=\"number\">7</span>,<span class=\"number\">1</span>],[<span class=\"number\">5</span>,<span class=\"number\">0</span>],[<span class=\"number\">6</span>,<span class=\"number\">1</span>],[<span class=\"number\">5</span>,<span class=\"number\">2</span>]]，最终结果是[[<span class=\"number\">5</span>,<span class=\"number\">0</span>],[<span class=\"number\">7</span>,<span class=\"number\">0</span>],[<span class=\"number\">5</span>,<span class=\"number\">2</span>],[<span class=\"number\">6</span>,<span class=\"number\">1</span>],[<span class=\"number\">4</span>,<span class=\"number\">4</span>],[<span class=\"number\">7</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\">这里好多语法是第一次见，详细记录一下</span><br><span class=\"line\"><span class=\"keyword\">if</span> (a[<span class=\"number\">0</span>] == b[<span class=\"number\">0</span>]) <span class=\"keyword\">return</span> a[<span class=\"number\">1</span>] - b[<span class=\"number\">1</span>];<span class=\"comment\">//如果身高相同，就按照比他高的人数进行升序排序，也就是第二个位置的数进行由小到大排</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> b[<span class=\"number\">0</span>] - a[<span class=\"number\">0</span>];<span class=\"comment\">//否则身高不相同，就按照逆序排，也就是从高到矮排</span></span><br><span class=\"line\"></span><br><span class=\"line\">a和b分别代表第一个数组和第二个数组</span><br><span class=\"line\"><span class=\"number\">0</span>和<span class=\"number\">1</span>就是这个数组的身高和比他高的人数</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">LinkedList.add(<span class=\"type\">int</span> index,E elemnt)<span class=\"comment\">//add(索引位置,待插入元素)</span></span><br><span class=\"line\">也就是按照数组第二个位置进行插入即可</span><br><span class=\"line\"></span><br><span class=\"line\">将que转成数组，下面是打印出第一个数的情况</span><br><span class=\"line\"><span class=\"type\">int</span>[][] res = que.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[people.length][]);</span><br><span class=\"line\">System.out.print(Arrays.toString(res[<span class=\"number\">0</span>]));<span class=\"comment\">//输出是[5, 0]</span></span><br><span class=\"line\">二维数组可以不定义列数，但必须定义行数。</span><br></pre></td></tr></table></figure>\n<h3 id=\"452-用最小数量的箭引爆气球-medium\"><a href=\"#452-用最小数量的箭引爆气球-medium\" class=\"headerlink\" title=\"452 用最小数量的箭引爆气球 medium\"></a>452 用最小数量的箭引爆气球 medium</h3><p>学习下这个二维数组的排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">先理解为什么要排序，可以理解为这个数组的顺序只是告诉你他们的位置而已</span></span><br><span class=\"line\"><span class=\"comment\">然后要知道，一只箭射的是可以重叠的区间</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">首先获得第一个气球的右边界</span></span><br><span class=\"line\"><span class=\"comment\">然后循环判断，如果下一个气球的左边界比上一个气球的右边界还小（等于也行），说明他们是重叠的，可以用一只箭，然后更新这个右边界的值</span></span><br><span class=\"line\"><span class=\"comment\">为什么要更新这个右边界的值呢，怎么更新呢？</span></span><br><span class=\"line\"><span class=\"comment\">如果第一个区间是[0,100]，那么初试的右边界是100,第二个区间是[3,4],他们可以用一只箭，但是如果第三个区间是[5,6]，需要新箭了，因为[3,4]和[5,6]不重叠，不能用一只箭</span></span><br><span class=\"line\"><span class=\"comment\">所以更新区间的策略是用最大右边界的值和当前区间的右边界值进行比较，取小的那个</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">这个题要纵向看，如下图所示</span></span><br><span class=\"line\"><span class=\"comment\">然后接着下一个区间，判断左边界和比最大右边区间</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMinArrowShots</span><span class=\"params\">(<span class=\"type\">int</span>[][] points)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (points.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class=\"number\">0</span>],b[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        //用x[0] - y[0] 会大于2147483647 造成整型溢出</span></span><br><span class=\"line\"><span class=\"comment\">        Arrays.sort(points,(a, b) -&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return a[0] - b[0];</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;<span class=\"comment\">//因为无论如何至少有一支箭</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightedge</span> <span class=\"operator\">=</span> points[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; points.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (points[i][<span class=\"number\">0</span>] &gt; rightedge) &#123;</span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                rightedge = points[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rightedge = Math.min(rightedge, points[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/452.jpg\"></p>\n<h3 id=\"435-无重叠区间-medium\"><a href=\"#435-无重叠区间-medium\" class=\"headerlink\" title=\"435 无重叠区间 medium\"></a>435 无重叠区间 medium</h3><p>去掉重叠的区间，[1,2],[2,3]不算重叠，然后计算需要去掉的个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">和上个题很像，但是这个题是去除重叠的区间，计数即可，不需要返回去除后的区间</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">思路是左边区间从小到大排序</span></span><br><span class=\"line\"><span class=\"comment\">然后取第一个数组的右边区间作为右边界rightedge</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">开始循环，如果第二个数的左边区间小于rightedge，说明重叠了，这时候要count++，至于移除哪个，你不需要纠结，你计数即可，然后重新取右边区间</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">可以看到，这个题和上一题的逻辑 是有点相反的！</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次做的反思：关于min的问题，这里是相交的时候取最小的右边，二个数的左边区间小于rightedge，重叠，肯定要移除一个，但是为什么保留较小的右边呢，因为如果你的rightedge很大的话，说明很多区间是可能发生重叠的，所以才是这个道理</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">eraseOverlapIntervals</span><span class=\"params\">(<span class=\"type\">int</span>[][] intervals)</span> &#123;</span><br><span class=\"line\">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class=\"number\">0</span>], b[<span class=\"number\">0</span>]));</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightedge</span> <span class=\"operator\">=</span> intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//和上一题不同哦，这里是计算去掉区间的个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (intervals[i][<span class=\"number\">0</span>] &lt; rightedge) &#123;<span class=\"comment\">//现在数组的左区间小于右边界，说明有重叠，需要去掉</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                rightedge = Math.min(rightedge, intervals[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                rightedge = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"763-划分字母区间-medium-1\"><a href=\"#763-划分字母区间-medium-1\" class=\"headerlink\" title=\"763 划分字母区间 medium\"></a>763 划分字母区间 medium</h3><p>字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">我们需要输出的是每个片段的长度</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">注意是尽可能多的片段，然后相同字母都在一起，不然要最少片段，就不用分割了</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">方法就是</span></span><br><span class=\"line\"><span class=\"comment\">1.统计每一个字符最后出现的位置</span></span><br><span class=\"line\"><span class=\"comment\">2.从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">partitionLabels</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] edge = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"type\">char</span>[] chars = s.toCharArray();<span class=\"comment\">//把字符串分割成一个个字符</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            edge[chars[i] - <span class=\"string\">&#x27;a&#x27;</span>] = i;<span class=\"comment\">//不断更新该字符的最远距离，存进edge中</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">last</span> <span class=\"operator\">=</span> -<span class=\"number\">1</span>;<span class=\"comment\">//初始化-1是为了减的时候多加一个1，因为我们要返回个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//用来标记最远距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            index = Math.max(index, edge[chars[i] - <span class=\"string\">&#x27;a&#x27;</span>]);<span class=\"comment\">//获取该字符的最远距离，进入第二轮的话就是和上一个相比</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (index == i) &#123;<span class=\"comment\">//如果当前位置刚好就是这个距离，就说明找到分割点了</span></span><br><span class=\"line\">                list.add(i - last);<span class=\"comment\">//计算长度</span></span><br><span class=\"line\">                last = i;<span class=\"comment\">//更新last，准备下一次计算</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"56-合并区间-mediun\"><a href=\"#56-合并区间-mediun\" class=\"headerlink\" title=\"56 合并区间 mediun\"></a>56 合并区间 mediun</h3><p>这个题注意下返回的输出格式。注意[1,4],[4,5]也要合并的，变成[1,5]。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[][] merge(<span class=\"type\">int</span>[][] intervals) &#123;</span><br><span class=\"line\">        List&lt;<span class=\"type\">int</span>[]&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.sort(intervals, (a ,b) -&gt; Integer.compare(a[<span class=\"number\">0</span>], b[<span class=\"number\">0</span>]));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">leftedge</span> <span class=\"operator\">=</span> intervals[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">rightedge</span> <span class=\"operator\">=</span> intervals[<span class=\"number\">0</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (intervals[i][<span class=\"number\">0</span>] &gt; rightedge) &#123;<span class=\"comment\">//左边区间大于的上一个数的右边界，说明可以把之前的边界合并在一起了</span></span><br><span class=\"line\">                result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;leftedge, rightedge&#125;);</span><br><span class=\"line\">                leftedge = intervals[i][<span class=\"number\">0</span>];</span><br><span class=\"line\">                rightedge = intervals[i][<span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;<span class=\"comment\">//这个就是小于等于号的情况</span></span><br><span class=\"line\">                rightedge = Math.max(intervals[i][<span class=\"number\">1</span>], rightedge);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        result.add(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;leftedge, rightedge&#125;);<span class=\"comment\">//上面的数循环完后，会漏掉最后一个区间的，所以最后加上</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result.toArray(<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[result.size()][]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面452,435,56题，需要好好理解什么时候是需要比较max的右边界的，而且上面三个题，都是左边区间排序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">别忘了均是左边区间排序，从小到大，还有循环都是从<span class=\"number\">1</span>开始</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">452</span> </span><br><span class=\"line\">在右边界内，也就是当前数组的左边区间小于右边界，说明重叠了，可以穿过同一只箭，不需要更新箭的数量，但是这时候要更新右边区间，要缩小右边区间的范围，所以要用min来对比</span><br><span class=\"line\">反之如果大于这个右区间，就要增加箭的数量，然后更新右边界</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">435</span></span><br><span class=\"line\">去掉重叠的区间注意[<span class=\"number\">1</span>,<span class=\"number\">2</span>][<span class=\"number\">2</span>,<span class=\"number\">3</span>]不重叠</span><br><span class=\"line\">在右边界内，也就是当前数组的左边区间小于右边界，说明需要去掉一个数组，count++，同时需要更新右边界min来比较，为什么要min呢，可以这么想，万一第一个的右边界很大，覆盖了全部数组，那必须得去掉啊</span><br><span class=\"line\">如果不在边界，就直接更新右边界的值即可</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">56</span></span><br><span class=\"line\">注意[<span class=\"number\">4</span>,<span class=\"number\">5</span>]，[<span class=\"number\">5</span>,<span class=\"number\">6</span>]也是需要合并的</span><br><span class=\"line\">这个题要记录左右边界</span><br><span class=\"line\">在右边界外，也就是当前数组的左边区间大于右边界，可以直接添加元素了，为什么不用小于等于呢（别忘了上面一行什么情况需要合并），其实也可以的，只是里面内容不一样而已，添加了元素后，要更新左右边界</span><br><span class=\"line\">反正，只需要更新右边界，因为不确定下一个是不是还是重叠的，所以这里不添加元素，只是改变右边界</span><br><span class=\"line\">循环完后，会漏掉最后一个区间的，所以最后加上</span><br><span class=\"line\">这个题的的返回值要注意下</span><br></pre></td></tr></table></figure>\n<h2 id=\"动态规划-1\"><a href=\"#动态规划-1\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>确定dp[i]的含义</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式（转移方程）</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化dp数组</span><br><span class=\"line\"><span class=\"number\">4.</span>确定遍历顺序</span><br><span class=\"line\"><span class=\"number\">5.</span>举例推导dp数组</span><br></pre></td></tr></table></figure>\n<h3 id=\"509-斐波那契数-easy\"><a href=\"#509-斐波那契数-easy\" class=\"headerlink\" title=\"509 斐波那契数 easy\"></a>509 斐波那契数 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i] 第i个数的斐波那契数</span><br><span class=\"line\"><span class=\"number\">2.</span>转移方程 dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化dp[<span class=\"number\">0</span>],dp[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">4.</span>dp[i]依赖dp[i-<span class=\"number\">1</span>]和dp[i-<span class=\"number\">2</span>]，按照顺序遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>自己推导一下<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">8</span> <span class=\"number\">13</span> <span class=\"number\">21</span> <span class=\"number\">34</span> <span class=\"number\">55</span></span><br><span class=\"line\"></span><br><span class=\"line\">这里注意一个点就是求dp[n]，也就是初始化数组的大小是n+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">2</span>) <span class=\"keyword\">return</span> n;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//这是需要注意理解题目的</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;= n; i++ ) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"70-爬楼梯-easy-1\"><a href=\"#70-爬楼梯-easy-1\" class=\"headerlink\" title=\"70 爬楼梯 easy\"></a>70 爬楼梯 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">先理解题目，每次可以爬两级或者爬一级，也就是你可以在dp[i-<span class=\"number\">2</span>]的级上爬两级，也可以在dp[i-<span class=\"number\">1</span>]的级上爬一级，那么爬楼梯的方法就有dp[i-<span class=\"number\">1</span>]加上dp[i-<span class=\"number\">2</span>]</span><br><span class=\"line\">本题不需要dp[<span class=\"number\">0</span>]，因为这样没有意义，没有说爬<span class=\"number\">0</span>级的楼梯，所以dp[<span class=\"number\">1</span>]和dp[<span class=\"number\">2</span>]需要初始化，由于是求dp[n]，所以数组的长度也就是需要n+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i]爬到第i层楼梯的方法数</span><br><span class=\"line\"><span class=\"number\">2.</span>根据我上面写的题意可以推出 dp[i]=dp[i-<span class=\"number\">1</span>]+dp[i-<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">3.</span>第<span class=\"number\">0</span>层没意义，但是会生成数组的时候会自动初始化<span class=\"number\">0</span>，我们也不需要管，dp[<span class=\"number\">1</span>]=<span class=\"number\">1</span>,dp[<span class=\"number\">2</span>]=<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">4.</span>dp[i]依赖dp[i-<span class=\"number\">1</span>]和dp[i-<span class=\"number\">2</span>]，按照顺序遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>可以自己推导下前面几个，比如 <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">5</span> <span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">climbStairs</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">3</span>) <span class=\"keyword\">return</span> n;  </span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            dp[i] = dp[i - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"746-使用最小花费爬楼梯-easy\"><a href=\"#746-使用最小花费爬楼梯-easy\" class=\"headerlink\" title=\"746 使用最小花费爬楼梯 easy\"></a>746 使用最小花费爬楼梯 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题需要好好看看讲解哦，本题的要求是花费最小的体力值，然后首先看下面的例子理解下顶部是哪里！！！这个一开始我很懵，跟<span class=\"number\">70</span>一样，也是一次可以跳<span class=\"number\">1</span>级或者<span class=\"number\">2</span>级</span><br><span class=\"line\">例子<span class=\"number\">1</span>：cost = [<span class=\"number\">10</span>,<span class=\"number\">15</span>-,<span class=\"number\">20</span>]，支付 <span class=\"number\">15</span> ，向上爬两个台阶，到达楼梯顶部，顶部这里是没有体现的，也就是跳到cost[<span class=\"number\">2</span>]是一级，然后再跳到顶部是一级，一共两级</span><br><span class=\"line\"></span><br><span class=\"line\">这里-标记了跳的台阶</span><br><span class=\"line\"></span><br><span class=\"line\">例子<span class=\"number\">2</span>：cost = [<span class=\"number\">1</span>-,<span class=\"number\">100</span>,<span class=\"number\">1</span>-,<span class=\"number\">1</span>,<span class=\"number\">1</span>-,<span class=\"number\">100</span>,<span class=\"number\">1</span>-,<span class=\"number\">1</span>-,<span class=\"number\">100</span>,<span class=\"number\">1</span>-],一共支付<span class=\"number\">6</span>，从下标为<span class=\"number\">0</span>的台阶开始</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">0</span>]，向上爬两个台阶，到达下标为 <span class=\"number\">2</span> 的台阶。</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">2</span>]，向上爬两个台阶，到达下标为 <span class=\"number\">4</span> 的台阶。</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">4</span>]，向上爬两个台阶，到达下标为 <span class=\"number\">6</span> 的台阶。</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">6</span>]，向上爬一个台阶，到达下标为 <span class=\"number\">7</span> 的台阶。</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">7</span>]，向上爬两个台阶，到达下标为 <span class=\"number\">9</span> 的台阶。</span><br><span class=\"line\">- 支付 <span class=\"number\">1</span> cost[<span class=\"number\">9</span>]，向上爬一个台阶，到达楼梯顶部。</span><br><span class=\"line\"></span><br><span class=\"line\">看到题目的例子后，需要注意，最后一个楼梯顶部，在数组中是没有体现他的位置的，也就是后移一个，其实不需要纠结这个问题</span><br><span class=\"line\">因为你只要最后取数组倒数两个进行比较就行，哪个花费体力小就用哪个，这样他们都可以跳到楼顶</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i]到达第i个台阶需要花费的最少体力</span><br><span class=\"line\"><span class=\"number\">2.</span>因为我们需要花费最少的体力，然后可以跳<span class=\"number\">1</span>级或者<span class=\"number\">2</span>级，也就是 dp[i]=dp[i-<span class=\"number\">1</span>]+dp[i-<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化<span class=\"number\">2</span>个就行，dp[<span class=\"number\">0</span>]和dp[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">4.</span>dp[i]依赖dp[i-<span class=\"number\">1</span>]和dp[i-<span class=\"number\">2</span>]，按照顺序遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导一下cost = [<span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">100</span>, <span class=\"number\">1</span>] 的dp数组是[<span class=\"number\">1</span>,<span class=\"number\">100</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">3</span>,<span class=\"number\">103</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">104</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">这里的转移方程详细说下，dp[i] = Math.min(dp[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>]) + cost[i];</span><br><span class=\"line\">这里为什么是cost[i]而不是cost[i-<span class=\"number\">1</span>]或者cost[i-<span class=\"number\">2</span>]</span><br><span class=\"line\">因为我们想，我们现在是取到了前面两个比较小的值，然后本级需要跳，就要花费，先不考虑我们这个级跳<span class=\"number\">1</span>级还是<span class=\"number\">2</span>级的问题，因为我们先把整个dp数组弄出来，最后比较最后两个的值</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"type\">int</span>[] cost)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost == <span class=\"literal\">null</span> || cost.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cost.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[cost.length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = cost[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.min(dp[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>]) + cost[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.min(dp[cost.length - <span class=\"number\">2</span>], dp[cost.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minCostClimbingStairs</span><span class=\"params\">(<span class=\"type\">int</span>[] cost)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*这部分可以不写，因为不存在这个范围的用例</span></span><br><span class=\"line\"><span class=\"comment\">        if (cost == null || cost.length == 0) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return 0;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        if (cost.length == 1) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return cost[0];</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[cost.length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = cost[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = cost[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.min(dp[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>]) + cost[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.min(dp[cost.length - <span class=\"number\">2</span>], dp[cost.length - <span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"62-不同路径-medium\"><a href=\"#62-不同路径-medium\" class=\"headerlink\" title=\"62 不同路径 medium\"></a>62 不同路径 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]代表到从（<span class=\"number\">0</span> ，<span class=\"number\">0</span>）出发，到(i, j) 有dp[i][j]条不同的路径。</span><br><span class=\"line\"><span class=\"number\">2.</span>题目说只能从右边还有下边走，所以只依赖两个方向的路径，dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">3.</span>dp初始化，第一行和第一列的坐标都是<span class=\"number\">1</span>，因为只有一个方向走</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序就是从左到右</span><br><span class=\"line\"><span class=\"number\">5.</span>自己手动画下推导数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePaths</span><span class=\"params\">(<span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span> [m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"63-不同路径2-medium\"><a href=\"#63-不同路径2-medium\" class=\"headerlink\" title=\"63 不同路径2 medium\"></a>63 不同路径2 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">和上一题五部曲差不多，这里直说区别</span><br><span class=\"line\"></span><br><span class=\"line\">首先初始化问题</span><br><span class=\"line\">初始化只在第一行和第一列，但是如果遇到障碍，需要<span class=\"keyword\">break</span>，而不是<span class=\"keyword\">continue</span>，这个的意思是，障碍后面的格子，都是<span class=\"number\">0</span>了，但是如果你是<span class=\"keyword\">continue</span>的话，只是单纯障碍这一格子是<span class=\"number\">0</span>，但是后面是<span class=\"number\">1</span></span><br><span class=\"line\">而我们需要知道，你只要有障碍，后面都不能通过了</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">在具体递推公式的时候，遇到障碍则跳过，不是<span class=\"keyword\">break</span>，因为你<span class=\"keyword\">break</span>的话就全部结束了，而<span class=\"keyword\">continue</span>只是跳过这个格子，这样这个格子就会为<span class=\"number\">0</span>，在其他位置需要加他的时候，就是加<span class=\"number\">0</span>。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">uniquePathsWithObstacles</span><span class=\"params\">(<span class=\"type\">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> obstacleGrid.length;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> obstacleGrid[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m][n];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obstacleGrid[i][<span class=\"number\">0</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (obstacleGrid[<span class=\"number\">0</span>][i] == <span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (obstacleGrid[i][j] == <span class=\"number\">1</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + dp[i][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"343-整数拆分-medium\"><a href=\"#343-整数拆分-medium\" class=\"headerlink\" title=\"343 整数拆分 medium\"></a>343 整数拆分 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题感觉没那么容易理解</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i] 分拆数字i，可以得到的最大乘积为dp[i]。</span><br><span class=\"line\"><span class=\"number\">2.</span>当i&gt;=<span class=\"number\">2</span> 时，假设对正整数 i 拆分出的第一个正整数是 j（<span class=\"number\">1</span>&lt;=j&lt;i），则有以下两种方案：<span class=\"number\">1.</span>将 i拆分成j和i−j的和，且i−j 不再拆分成多个正整数，此时的乘积是j*(i-j)；<span class=\"number\">2.</span>将 ii 拆分成 jj 和 i-ji−j 的和，且 i-ji−j 继续拆分成多个正整数，此时的乘积是j*dp[i-j]。</span><br><span class=\"line\">上面其实不容易懂，需要这样理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘，因为题目要求可以至少拆分出<span class=\"number\">2</span>个。</span><br><span class=\"line\"><span class=\"number\">3.</span>首先要清楚，dp[<span class=\"number\">0</span>]和dp[<span class=\"number\">1</span>]，因为<span class=\"number\">0</span>无法拆分，<span class=\"number\">1</span>也无法拆分，所以初始化要从<span class=\"number\">2</span>开始，<span class=\"number\">2</span>=<span class=\"number\">1</span>+<span class=\"number\">1</span>，然后<span class=\"number\">1</span>*<span class=\"number\">1</span>=<span class=\"number\">1</span>，dp[<span class=\"number\">2</span>]=<span class=\"number\">1</span>，然后注意数组长度是n+<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序也是第一次见，需要i和j，然后也是顺序遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>自己可以手动推导，比如n=<span class=\"number\">10</span>，dp数组是<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">12</span>,<span class=\"number\">18</span>,<span class=\"number\">27</span>,<span class=\"number\">36</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">integerBreak</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">2</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">3</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= i - j; j++) &#123;<span class=\"comment\">//这里j的范围需要注意是小于等于i-j</span></span><br><span class=\"line\">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[i - j] * j));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"96-不同的二叉搜索树-medium\"><a href=\"#96-不同的二叉搜索树-medium\" class=\"headerlink\" title=\"96 不同的二叉搜索树 medium\"></a>96 不同的二叉搜索树 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题其实算困难了，尤其是递推关系，没做过压根不知道，可以看卡哥的图</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i] ： <span class=\"number\">1</span>到i为节点组成的二叉搜索树的个数为dp[i]</span><br><span class=\"line\"><span class=\"number\">2.</span>递推公式</span><br><span class=\"line\">元素<span class=\"number\">1</span>为头结点搜索树的数量 = 右子树有<span class=\"number\">2</span>个元素的搜索树数量 * 左子树有<span class=\"number\">0</span>个元素的搜索树数量</span><br><span class=\"line\">元素<span class=\"number\">2</span>为头结点搜索树的数量 = 右子树有<span class=\"number\">1</span>个元素的搜索树数量 * 左子树有<span class=\"number\">1</span>个元素的搜索树数量</span><br><span class=\"line\">元素<span class=\"number\">3</span>为头结点搜索树的数量 = 右子树有<span class=\"number\">0</span>个元素的搜索树数量 * 左子树有<span class=\"number\">2</span>个元素的搜索树数量</span><br><span class=\"line\">有<span class=\"number\">2</span>个元素的搜索树数量就是dp[<span class=\"number\">2</span>]</span><br><span class=\"line\">有<span class=\"number\">1</span>个元素的搜索树数量就是dp[<span class=\"number\">1</span>]</span><br><span class=\"line\">有<span class=\"number\">0</span>个元素的搜索树数量就是dp[<span class=\"number\">0</span>]</span><br><span class=\"line\">所以dp[<span class=\"number\">3</span>] = dp[<span class=\"number\">2</span>] * dp[<span class=\"number\">0</span>] + dp[<span class=\"number\">1</span>] * dp[<span class=\"number\">1</span>] + dp[<span class=\"number\">0</span>] * dp[<span class=\"number\">2</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">递推公式：dp[i] += dp[j - <span class=\"number\">1</span>] * dp[i - j]</span><br><span class=\"line\">这个不好记，可以看dp[<span class=\"number\">3</span>]，第一个是dp[<span class=\"number\">2</span>]*dp[<span class=\"number\">0</span>]，i=<span class=\"number\">3</span>，然后j是从<span class=\"number\">1</span>开始，所以可以想到i-j,然后另外一个规律就是<span class=\"number\">2</span>+<span class=\"number\">0</span>=<span class=\"number\">2</span>，前面<span class=\"number\">3</span>-<span class=\"number\">1</span>=<span class=\"number\">0</span>，另外一个就是j-<span class=\"number\">1</span>=<span class=\"number\">0</span>，此时j=<span class=\"number\">1</span>哦</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>，dp[<span class=\"number\">1</span>]=<span class=\"number\">1</span>,<span class=\"number\">1</span>的话好理解，但是<span class=\"number\">0</span>的话不好理解，但是我们后面用到乘法，所以初始化为<span class=\"number\">1</span>更好。</span><br><span class=\"line\"><span class=\"number\">4.</span>节点数为i的状态是依靠 i之前节点数的状态，从前往后即可</span><br><span class=\"line\"><span class=\"number\">5.</span>可以推导下</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numTrees</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt;=n; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= i; j++) &#123;</span><br><span class=\"line\">                dp[i] += dp[i - j] * dp[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"416-分割等和子集-medium\"><a href=\"#416-分割等和子集-medium\" class=\"headerlink\" title=\"416 分割等和子集 medium\"></a>416 分割等和子集 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0</span>-<span class=\"number\">1</span>背包问题</span><br><span class=\"line\">nums里面可以看成物品，每个物品只能用一次，题目拆解后可以发现target是背包容量</span><br><span class=\"line\"></span><br><span class=\"line\">对于一维dp数组，务必先遍历物品，反正倒着遍历容量（因为每次元素不能重复使用），其次还要注意j&gt;=nums[i]，而不是<span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">这里 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class=\"line\">max中的dp[j]可以理解为二维数组中的dp[i-<span class=\"number\">1</span>]，因为如果用一维数组dp[i - <span class=\"number\">1</span>]那一层拷贝到dp[i]上</span><br><span class=\"line\"></span><br><span class=\"line\">五部曲</span><br><span class=\"line\"><span class=\"number\">1.</span>dp[j]表示容量为j的背包，所背物品价值最高是dp[j]</span><br><span class=\"line\"><span class=\"number\">2.</span>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);本题的物品，既是容量，也是价值</span><br><span class=\"line\"><span class=\"number\">3.</span>题目给的价值都是正整数的话，都可以初始化为<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序：使用一维数组的话，物品遍历的<span class=\"keyword\">for</span>循环放在外层，遍历背包的<span class=\"keyword\">for</span>循环放在内层，且内层<span class=\"keyword\">for</span>循环倒序遍历！</span><br><span class=\"line\"><span class=\"number\">5.</span>自己递推试试，注意本题的容量是target，所以数组的长度是target+<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">这里有个细节就是，target可能不能被整除，所以先要判断能不能被<span class=\"number\">2</span>取模</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">canPartition</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) &#123;</span><br><span class=\"line\">            sum += x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sum % <span class=\"number\">2</span> != <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;<span class=\"comment\">//很细的细节</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[target + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> target; j &gt;= nums[i]; j--) &#123;</span><br><span class=\"line\">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[target] == target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1049-最后一块石头的重量II-medium\"><a href=\"#1049-最后一块石头的重量II-medium\" class=\"headerlink\" title=\"1049 最后一块石头的重量II medium\"></a>1049 最后一块石头的重量II medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题和上个题的区别是，上个题能不能正好装满，这个题是求最多能装多少</span><br><span class=\"line\">其实一开始看这个题，有点懵，一直纠结一直拿两块石头应该怎么拿。</span><br><span class=\"line\">看了分析后，其实这个题的本意是尽量让石头分成重量相同的两堆，这样相撞后的石头最小。同样，本题物品的重量为store[i]，物品的价值也为store[i]。</span><br><span class=\"line\">也就是当我们把所有重量求和/<span class=\"number\">2</span>，就可以求我们的dp数组，然后这个题不需要考虑sum能否被整除<span class=\"number\">2</span>，因为本题说了是最多能装多少</span><br><span class=\"line\">最后，我们理解下题目需要返回什么，按照上面的思路，其实石头被分成两堆，一堆是dp[target]，一堆是sum-dp[target],然后相减就是剩下石头的重量</span><br><span class=\"line\"></span><br><span class=\"line\">五部曲和上面一题一样</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lastStoneWeightII</span><span class=\"params\">(<span class=\"type\">int</span>[] stones)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : stones) &#123;</span><br><span class=\"line\">            sum += x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> sum / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[target + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> target; j &gt;= stones[i]; j--) &#123;</span><br><span class=\"line\">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum -  <span class=\"number\">2</span> * dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"494-目标和-medium\"><a href=\"#494-目标和-medium\" class=\"headerlink\" title=\"494 目标和 medium\"></a>494 目标和 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">涉及组合问题，而且这个题和其他背包问题不太一样，有点难度，下面详细讲下，本题也是<span class=\"number\">0</span>-<span class=\"number\">1</span>背包。</span><br><span class=\"line\"></span><br><span class=\"line\">首先理解一点是如何表达target</span><br><span class=\"line\">我们可以计算出这个数组的总和sum，然后我们想想都是加号的数字和为a，都是减号的数字和为b，</span><br><span class=\"line\">那么a-b就是sum，然后a+b就是target(这里和卡哥有点出入，我按照自己的理解去写，他是反过来的)</span><br><span class=\"line\">b= a-sum </span><br><span class=\"line\">a+a-sum=target</span><br><span class=\"line\">a=(target+sum)/<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">a即为bagsize</span><br><span class=\"line\">这里需要考虑<span class=\"number\">2</span>个问题，一个是target的绝对值如果大于sum，是不可能组成的，因为可能有这种案例</span><br><span class=\"line\">第二个考虑就是(target+sum)%<span class=\"number\">2</span>==<span class=\"number\">1</span>的话，也是不行的，例如sum 是<span class=\"number\">5</span>，target是<span class=\"number\">2</span>的话其实就是无解的，根本无法组合出来，<span class=\"number\">4</span>-<span class=\"number\">1</span>=<span class=\"number\">3</span>,<span class=\"number\">3</span>-<span class=\"number\">2</span>=<span class=\"number\">1</span>，压根组合不到<span class=\"number\">2</span>，也就是要求sum+target一定为偶数才行，至于为啥，还没想通。</span><br><span class=\"line\"></span><br><span class=\"line\">那么这里a就可以理解为背包容量，为什么呢，我们理解为组成加号和为a情况有多少种</span><br><span class=\"line\">那么dp[a+<span class=\"number\">1</span>]，这是dp数组长度</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">五部曲</span><br><span class=\"line\"><span class=\"number\">1.</span>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</span><br><span class=\"line\"><span class=\"number\">2.</span>这里的递推公式不一样！！！！其实也不算完全理解</span><br><span class=\"line\">不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。</span><br><span class=\"line\">那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。</span><br><span class=\"line\">例如：dp[j]，j 为<span class=\"number\">5</span></span><br><span class=\"line\">已经有一个<span class=\"number\">1</span>（nums[i]） 的话，有 dp[<span class=\"number\">4</span>]种方法 凑成 dp[<span class=\"number\">5</span>]。</span><br><span class=\"line\">已经有一个<span class=\"number\">2</span>（nums[i]） 的话，有 dp[<span class=\"number\">3</span>]种方法 凑成 dp[<span class=\"number\">5</span>]。</span><br><span class=\"line\">已经有一个<span class=\"number\">3</span>（nums[i]） 的话，有 dp[<span class=\"number\">2</span>]中方法 凑成 dp[<span class=\"number\">5</span>]。</span><br><span class=\"line\">已经有一个<span class=\"number\">4</span>（nums[i]） 的话，有 dp[<span class=\"number\">1</span>]中方法 凑成 dp[<span class=\"number\">5</span>]。</span><br><span class=\"line\">已经有一个<span class=\"number\">5</span> （nums[i]）的话，有 dp[<span class=\"number\">0</span>]中方法 凑成 dp[<span class=\"number\">5</span>]。</span><br><span class=\"line\">那么凑整dp[<span class=\"number\">5</span>]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</span><br><span class=\"line\">这个是组合类问题，递推公式为：dp[j] += dp[j - nums[i]]</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化</span><br><span class=\"line\">这里必须要设置dp[<span class=\"number\">0</span>]为<span class=\"number\">1</span>，这个可以理解为容量为<span class=\"number\">0</span>的背包，有一种方法，就是装<span class=\"number\">0</span>件物品。但是如果初始化是<span class=\"number\">0</span>后面无法推导。</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序，物品放外面（数组），容量放里面（bagsize）。</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findTargetSumWays</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) &#123;</span><br><span class=\"line\">            sum += x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((sum + target) % <span class=\"number\">2</span> == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Math.abs(target) &gt; sum) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">bagsize</span> <span class=\"operator\">=</span> (sum + target) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[bagsize + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> bagsize; j &gt;= nums[i]; j--) &#123;</span><br><span class=\"line\">                dp[j] += dp[j - nums[i]];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[bagsize];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"474-零和一-medium\"><a href=\"#474-零和一-medium\" class=\"headerlink\" title=\"474 零和一 medium\"></a>474 零和一 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题 也没那么容易，本质也是<span class=\"number\">0</span>-<span class=\"number\">1</span>背包问题</span><br><span class=\"line\"></span><br><span class=\"line\">sts数组就是物品，然后这里很难理解的就是m和n，这里不能理解为多重背包，这里要理解为有两个维度的背包。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]：最多有i个<span class=\"number\">0</span>和j个<span class=\"number\">1</span>的strs的最大子集的大小为dp[i][j]，也就是里面存的是大小</span><br><span class=\"line\"><span class=\"number\">2.</span>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化就是<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序，这个题有点不一样哦，里面是两个维度的容量，但是总体上还是物品在外面遍历，容量在里面遍历（倒着）</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findMaxForm</span><span class=\"params\">(String[] strs, <span class=\"type\">int</span> m, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[m + <span class=\"number\">1</span>][n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (String str:strs) &#123;<span class=\"comment\">//物品，也就是每个数组</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">onenum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, zeronum = <span class=\"number\">0</span>;<span class=\"comment\">//每次都要重新计算数组的0和1的个数</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : str.toCharArray()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (c == <span class=\"string\">&#x27;0&#x27;</span>) &#123;</span><br><span class=\"line\">                    zeronum++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    onenum++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//下面是容量，注意题目m是代表0，n是代表1，不需要搞错了</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> m; i &gt;= zeronum; i--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span>  <span class=\"variable\">j</span> <span class=\"operator\">=</span> n; j &gt;= onenum; j--) &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i][j], dp[i - zeronum][j - onenum] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[m][n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"背包问题解析合集\"><a href=\"#背包问题解析合集\" class=\"headerlink\" title=\"背包问题解析合集\"></a>背包问题解析合集</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总结一下，<span class=\"number\">0</span>-<span class=\"number\">1</span>背包物品先，容量倒着来，完全背包物品先，容量顺着来</span><br><span class=\"line\">组合问题物品先，容量顺着来，排列问题容量先从头来</span><br><span class=\"line\"></span><br><span class=\"line\">至于是写dp[j]还是dp[i]，是根据你把j和i定义成什么，其实都是dp[容量],也就是用容量的下标来表示</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>   <span class=\"number\">0</span>-<span class=\"number\">1</span>背包</span><br><span class=\"line\">表示物品只能拿一次，先遍历物品（顺序），再遍历容量（倒着，保证物品只被添加一次）</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; weight.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">倒着的原因，这里举个例子</span><br><span class=\"line\">    重量  价值</span><br><span class=\"line\">物品<span class=\"number\">0</span> <span class=\"number\">1</span>   <span class=\"number\">15</span></span><br><span class=\"line\">物品<span class=\"number\">1</span> <span class=\"number\">3</span>   <span class=\"number\">20</span></span><br><span class=\"line\">物品<span class=\"number\">2</span> <span class=\"number\">4</span>   <span class=\"number\">30</span></span><br><span class=\"line\"></span><br><span class=\"line\">如果是正序遍历</span><br><span class=\"line\">dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">1</span> - weight[<span class=\"number\">0</span>]] + value[<span class=\"number\">0</span>] = <span class=\"number\">15</span></span><br><span class=\"line\">dp[<span class=\"number\">2</span>] = dp[<span class=\"number\">2</span> - weight[<span class=\"number\">0</span>]] + value[<span class=\"number\">0</span>] = <span class=\"number\">30</span></span><br><span class=\"line\">我们可以看到dp[<span class=\"number\">2</span>]这样是加了两次物品<span class=\"number\">0</span>的重量</span><br><span class=\"line\"></span><br><span class=\"line\">但是如果是倒序遍历</span><br><span class=\"line\">dp[<span class=\"number\">2</span>] = dp[<span class=\"number\">2</span> - weight[<span class=\"number\">0</span>]] + value[<span class=\"number\">0</span>] = <span class=\"number\">15</span> （dp数组已经都初始化为<span class=\"number\">0</span>）</span><br><span class=\"line\">dp[<span class=\"number\">1</span>] = dp[<span class=\"number\">1</span> - weight[<span class=\"number\">0</span>]] + value[<span class=\"number\">0</span>] = <span class=\"number\">15</span></span><br><span class=\"line\"></span><br><span class=\"line\">最后再次说明dp[j]的意思是容量为j的背包，所背的物品价值可以最大为dp[j]。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>   完全背包</span><br><span class=\"line\">表示物品可以添加多次，先遍历物品（顺序），再遍历容量（顺序，可以添加多次）</span><br><span class=\"line\"><span class=\"comment\">// 先遍历物品，再遍历背包</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; weight.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class=\"comment\">// 遍历背包容量，顺序遍历，顺序遍历</span></span><br><span class=\"line\">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">另外说一些额外的：</span><br><span class=\"line\"><span class=\"number\">01</span>背包中二维dp数组的两个<span class=\"keyword\">for</span>遍历的先后循序是可以颠倒了，一维dp数组的两个<span class=\"keyword\">for</span>循环先后循序一定是先遍历物品，再遍历背包容量。</span><br><span class=\"line\">完全背包中，对于一维dp数组来说，其实两个<span class=\"keyword\">for</span>循环嵌套顺序同样无所谓！但是代码还是有点不一样，这里就看个参考，不要记了</span><br><span class=\"line\"><span class=\"comment\">// 先遍历背包，再遍历物品</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;= bagWeight; j++) &#123; <span class=\"comment\">// 遍历背包容量，别忘了，这里是j</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; weight.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j - weight[i] &gt;= <span class=\"number\">0</span>) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>   组合数和排列数问题，组合不强调元素之间的顺序（也就是[<span class=\"number\">1</span>,<span class=\"number\">5</span>]和[<span class=\"number\">5</span>,<span class=\"number\">1</span>]是一回事），排列强调元素之间的顺序，初始化dp[<span class=\"number\">0</span>]为<span class=\"number\">1</span>，至于为什么，没有原因。</span><br><span class=\"line\"><span class=\"number\">494</span>是组合问题，初始化dp[<span class=\"number\">0</span>]为<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">组合代码，和完全背包一样，都是先遍历物品，再遍历容量</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> coins[i]; j &lt;= amount; j++) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">        dp[j] += dp[j - coins[i]];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">排列代码 ，这个不一样哦，先遍历容量，再遍历，而且背包遍历容量，是从<span class=\"number\">0</span>开始的，注意背包</span><br><span class=\"line\">如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[<span class=\"number\">4</span>]的时候，结果集只有 &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125; 这样的集合，不会有&#123;<span class=\"number\">3</span>,<span class=\"number\">1</span>&#125;这样的集合，因为nums遍历放在外层，<span class=\"number\">3</span>只能出现在<span class=\"number\">1</span>后面！</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;= amount; j++) &#123; <span class=\"comment\">// 遍历背包容量</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.size(); i++) &#123; <span class=\"comment\">// 遍历物品</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (j - coins[i] &gt;= <span class=\"number\">0</span>) dp[j] += dp[j - coins[i]];<span class=\"comment\">//注意要有背包容量大于等于coins[i]</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"377-组合总和Ⅳ-medium\"><a href=\"#377-组合总和Ⅳ-medium\" class=\"headerlink\" title=\"377 组合总和Ⅳ medium\"></a>377 组合总和Ⅳ medium</h3><p>这个其实是排列+完全背包问题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</span><br><span class=\"line\"><span class=\"number\">2.</span>求排列 dp[i] += dp[i - nums[j]];</span><br><span class=\"line\"><span class=\"number\">3.</span>dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>，组合排列都是这样初始化，其他位置为<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>外层<span class=\"keyword\">for</span>遍历背包，内层<span class=\"keyword\">for</span>循环遍历物品，且注意背包容量要大于物品，不然会越界</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">combinationSum4</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp =<span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[target + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt;= target; j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - nums[i] &gt;= <span class=\"number\">0</span>) dp[j] += dp[j - nums[i]]; <span class=\"comment\">//且注意背包容量要大于物品，不然会越界</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[target];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"518-零钱兑换II-medium\"><a href=\"#518-零钱兑换II-medium\" class=\"headerlink\" title=\"518 零钱兑换II medium\"></a>518 零钱兑换II medium</h3><p>完全背包+组合，注意这里是求凑成总金额的硬币组合数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[j]：凑成总金额j的货币组合数为dp[j]</span><br><span class=\"line\"><span class=\"number\">2.</span>组合数，dp[j] += dp[j - coins[i]]</span><br><span class=\"line\"><span class=\"number\">3.</span>dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>，组合排列都是这样初始化，其他位置为<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>顺序遍历物品（金币），顺序遍历容量（钱总额）</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">change</span><span class=\"params\">(<span class=\"type\">int</span> amount, <span class=\"type\">int</span>[] coins)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">1</span>; </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">                dp[j] += dp[j - coins[i]]; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"322-零钱兑换-medium\"><a href=\"#322-零钱兑换-medium\" class=\"headerlink\" title=\"322 零钱兑换 medium\"></a>322 零钱兑换 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">和上题的区别</span><br><span class=\"line\">本题求的是硬币的最小个数，最小的话，有顺序和没有顺序都可以，也就是排列组合都没有关系，但是符合完全背包（钱币可以无限用）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</span><br><span class=\"line\"><span class=\"number\">2.</span>递推公式：dp[j] = min(dp[j - coins[i]] + <span class=\"number\">1</span>, dp[j]);，其实这里我还没理解为啥加<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">3.</span>首先凑足总金额为<span class=\"number\">0</span>所需钱币的个数一定是<span class=\"number\">0</span>，那么dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;其次其他下标需要为最大值</span><br><span class=\"line\"><span class=\"number\">4.</span>完全背包，先遍历顺序物品，然后顺序遍历容量</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">coinChange</span><span class=\"params\">(<span class=\"type\">int</span>[] coins, <span class=\"type\">int</span> amount)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE) <span class=\"comment\">// 如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class=\"line\">                    &#123;dp[j] = Math.min(dp[j],dp[j - coins[i]] + <span class=\"number\">1</span>);&#125;<span class=\"comment\">//看了别人的解释，金额为11的最小硬币数 和 金额为(11-一个面值)的最小硬币数+1 比较最小值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class=\"number\">1</span> : dp[amount];<span class=\"comment\">//因为可能不能组合成功，那么就返回-1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完全背包也可以先写容量，再写物品，但是要多加一个判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">coinChange</span><span class=\"params\">(<span class=\"type\">int</span>[] coins, <span class=\"type\">int</span> amount)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span> [amount + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= amount; j++) &#123;<span class=\"comment\">//其实j从0开始也行的，但是我们之前声明了dp[0]，所以没意义，直接从1开始</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - coins[i] &gt;= <span class=\"number\">0</span> &amp;&amp; dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class=\"number\">1</span> : dp[amount];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"279-完全平方数-medium-1\"><a href=\"#279-完全平方数-medium-1\" class=\"headerlink\" title=\"279 完全平方数 medium\"></a>279 完全平方数 medium</h3><p>和前面一题差不多，这里把完全平方数看做物品。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numSquares</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i * i &lt;= j; i++) &#123;<span class=\"comment\">//物品，平方数是0没有意义，而且写0也会错的，自己推导一下就知道，这里直接是用i，而不是像数组那样</span></span><br><span class=\"line\">                <span class=\"comment\">/*if (j - i * i &gt;= 0)  加上这句也是可以的*/</span> dp[j] = Math.min(dp[j], dp[j - i * i] + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numSquares</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i * i &lt;= n; i++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= n; j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - i * i &gt;= <span class=\"number\">0</span>) dp[j] = Math.min(dp[j], dp[j - i * i] + <span class=\"number\">1</span>);<span class=\"comment\">//这里和之前总结的东西有点区别，为什么这里要if判断，有个原因就是这里是直接用i本身，而不是用数组</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"139-单词拆分-medium-1\"><a href=\"#139-单词拆分-medium-1\" class=\"headerlink\" title=\"139 单词拆分 medium\"></a>139 单词拆分 medium</h3><p>这道题类似于完全平方数分割。单词就是物品，字符串s就是背包，完全背包问题，求能否组成背包，因为分割子串的特殊性，遍历背包放在外循环，将遍历物品放在内循环更方便一些。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*跟下面的解法一样的，只是习惯了j代表背包容量而已*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[s.length() + <span class=\"number\">1</span>];<span class=\"comment\">//默认都是false的</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;<span class=\"comment\">//dp[0]表示如果字符串为空的话，说明出现在字典里。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= s.length(); j++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; j; i++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (wordDict.contains(s.substring(i, j)) &amp;&amp; dp[i] == <span class=\"literal\">true</span>) &#123;<span class=\"comment\">//(j,i)，注意是j开始，这里表示起始位置，左开右闭，dp[j]==true表示字符串长度为j的话，可以拆分为一个或者多个在字典中出现的单词，也就是之前的单词都是能拆的，然后如果后面也能拆，再把dp[i]置为true</span></span><br><span class=\"line\">                    dp[j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">wordBreak</span><span class=\"params\">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length();</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[n + <span class=\"number\">1</span>];<span class=\"comment\">//默认都是false的</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = <span class=\"literal\">true</span>;<span class=\"comment\">//dp[0]表示如果字符串为空的话，说明出现在字典里。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= n; i++) &#123;<span class=\"comment\">//容量</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;<span class=\"comment\">//物品</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j] == <span class=\"literal\">true</span>) &#123; <span class=\"comment\">//(j,i)，注意是j开始，这里表示起始位置，左开右闭，dp[j]==true表示字符串长度为j的话，可以拆分为一个或者多个在字典中出现的单词，也就是之前的单词都是能拆的，然后如果后面也能拆，再把dp[i]置为true</span></span><br><span class=\"line\">                    dp[i] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[n];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">卡哥将得很详细，复制一下记录</span><br><span class=\"line\">单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。substring(start,end)是左开右闭。</span><br><span class=\"line\"></span><br><span class=\"line\">拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span><br><span class=\"line\"></span><br><span class=\"line\">动规五部曲分析如下：</span><br><span class=\"line\"></span><br><span class=\"line\">1.确定dp数组以及下标的含义</span><br><span class=\"line\">dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span><br><span class=\"line\"></span><br><span class=\"line\">2.确定递推公式</span><br><span class=\"line\">如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i）。</span><br><span class=\"line\"></span><br><span class=\"line\">所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</span><br><span class=\"line\"></span><br><span class=\"line\">3.dp数组如何初始化</span><br><span class=\"line\">从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</span><br><span class=\"line\"></span><br><span class=\"line\">那么dp[0]有没有意义呢？</span><br><span class=\"line\"></span><br><span class=\"line\">dp[0]表示如果字符串为空的话，说明出现在字典里。</span><br><span class=\"line\"></span><br><span class=\"line\">但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</span><br><span class=\"line\"></span><br><span class=\"line\">下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</span><br><span class=\"line\"></span><br><span class=\"line\">4.确定遍历顺序</span><br><span class=\"line\">题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</span><br><span class=\"line\"></span><br><span class=\"line\">还要讨论两层for循环的前后循序。</span><br><span class=\"line\"></span><br><span class=\"line\">如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span><br><span class=\"line\"></span><br><span class=\"line\">如果求排列数就是外层for遍历背包，内层for循环遍历物品。</span><br><span class=\"line\"></span><br><span class=\"line\">本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</span><br><span class=\"line\"></span><br><span class=\"line\">那么本题使用求排列的方式，还是求组合的方式都可以。</span><br><span class=\"line\"></span><br><span class=\"line\">即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</span><br><span class=\"line\"></span><br><span class=\"line\">但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</span><br><span class=\"line\"></span><br><span class=\"line\">如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</span><br><span class=\"line\"></span><br><span class=\"line\">所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。</span><br><span class=\"line\"></span><br><span class=\"line\">5.举例推导dp[i]</span><br><span class=\"line\">以输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]为例，dp状态如图：</span><br><span class=\"line\">（在下方）</span><br><span class=\"line\">dp[s.size()]就是最终结果。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ps:</span><br><span class=\"line\">五部曲中第一部是最困难的. 一般都是遵循&quot;题目问什么, 就把`dp[]设置成什么</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">作者：carlsun-2</span><br><span class=\"line\">链接：https://leetcode.cn/problems/word-break/solution/dai-ma-sui-xiang-lu-139-dan-ci-chai-fen-50a1a/</span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/139.jpg\"></p>\n<h3 id=\"198-打家劫舍-medium-1\"><a href=\"#198-打家劫舍-medium-1\" class=\"headerlink\" title=\"198 打家劫舍 medium\"></a>198 打家劫舍 medium</h3><p>居然一开始和背包问题联系起来了，其实不是一回事啊！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i]表示考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式，决定dp[i]的因素就是第i房间偷还是不偷。偷第i间房子，那么dp[i] = dp[i-<span class=\"number\">2</span>]+nums[i]，因为不能导致报警，如果不偷第i间房子，dp[i]=dp[i-<span class=\"number\">1</span>]，这里不是表明要偷i-<span class=\"number\">1</span>房哦，要牢记dp[i]的概念，i以内的房间，所以dp[i] = max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"number\">3.</span>从递推公式可以看出，要初始化dp[<span class=\"number\">0</span>]和dp[<span class=\"number\">1</span>]，这里注意dp[<span class=\"number\">1</span>]是要求最大值哦，不是单纯赋值nums[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">4.</span>确定遍历顺序，从前到后</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">1</span>] = Math.max(nums[<span class=\"number\">1</span>], nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - <span class=\"number\">1</span>], dp[i - <span class=\"number\">2</span>] + nums[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[nums.length - <span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"213-打家劫舍2-medium\"><a href=\"#213-打家劫舍2-medium\" class=\"headerlink\" title=\"213 打家劫舍2 medium\"></a>213 打家劫舍2 medium</h3><p>和上一题的区别是，上一题的房子都是在一条街道，而本题的房子，是围成一圈，第一间和最后一间挨着。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">没做过的话，确实不好想</span><br><span class=\"line\">其实就是分成两部分，一部分不包含最后一个元素，一部分不包含第一个元素，然后比较他们的最大值</span><br><span class=\"line\">其余的和上一题一样。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (nums.length == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(robRange(nums, <span class=\"number\">0</span> , end - <span class=\"number\">1</span>), robRange(nums, <span class=\"number\">1</span>, end));</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">robRange</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (start == end) <span class=\"keyword\">return</span> nums[start];<span class=\"comment\">//如果不写这句，遇到[0,0]会出错，因为这时候传进来的start和end都是相等的</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span> [nums.length];</span><br><span class=\"line\">        dp[start] = nums[start];<span class=\"comment\">//主体的逻辑也要根据start和end来写哦</span></span><br><span class=\"line\">        dp[start + <span class=\"number\">1</span>] = Math.max(nums[start], nums[start + <span class=\"number\">1</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start + <span class=\"number\">2</span>; i &lt;= end; i++) &#123;<span class=\"comment\">//注意小于等于end</span></span><br><span class=\"line\">            dp[i] = Math.max(dp[i - <span class=\"number\">2</span>] + nums[i], dp[i - <span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[end];<span class=\"comment\">//注意返回的是end</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"337-打家劫设3-medium\"><a href=\"#337-打家劫设3-medium\" class=\"headerlink\" title=\"337 打家劫设3 medium\"></a>337 打家劫设3 medium</h3><p>这题用上了二叉树了，树形dp是第一次遇到！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">首先要用后序遍历，因为通过递归函数的返回值来做下一步计算。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>用长度为<span class=\"number\">2</span>的大小数组来保存，dp[<span class=\"number\">0</span>]表示不偷当前节点所获得的最大金钱，dp[<span class=\"number\">1</span>]表示偷当前节点所获得的最大金钱。</span><br><span class=\"line\"><span class=\"number\">2.</span>到了这里不是递推公式了，而是初始化，<span class=\"keyword\">if</span> (cur == NULL) <span class=\"keyword\">return</span> vector&lt;<span class=\"type\">int</span>&gt;&#123;<span class=\"number\">0</span>, <span class=\"number\">0</span>&#125;;，相当于初始化</span><br><span class=\"line\"><span class=\"number\">3.</span>确定遍历顺序，通过递归左节点，得到左节点偷与不偷的金钱。通过递归右节点，得到右节点偷与不偷的金钱。</span><br><span class=\"line\"><span class=\"number\">4.</span>确定单层递归的逻辑，如果是偷当前节点，那么左右孩子就不能偷，如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，因为只要不挨着就行，所以不一定要偷的</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">rob</span><span class=\"params\">(TreeNode root)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = dfs(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(res[<span class=\"number\">0</span>], res[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] dfs(TreeNode root) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">2</span>];<span class=\"comment\">//初始化</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] left = dfs(root.left);<span class=\"comment\">//左孩子</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] right = dfs(root.right);<span class=\"comment\">//右孩子</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = Math.max(left[<span class=\"number\">0</span>],left[<span class=\"number\">1</span>]) + Math.max(right[<span class=\"number\">0</span>], right[<span class=\"number\">1</span>]);<span class=\"comment\">//不偷当前节点的话，左右孩子可以偷，也可以不偷，关键在于取最大</span></span><br><span class=\"line\">        res[<span class=\"number\">1</span>] = root.val + left[<span class=\"number\">0</span>] + right[<span class=\"number\">0</span>];<span class=\"comment\">//偷当前节点，那么左右孩子都不能偷，0代表不偷，left和right代表左右孩子</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"121-买卖股票的最佳时机-easy-1\"><a href=\"#121-买卖股票的最佳时机-easy-1\" class=\"headerlink\" title=\"121 买卖股票的最佳时机 easy\"></a>121 买卖股票的最佳时机 easy</h3><p>只买卖一次！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">需要强化一个概念，持有不代表今天买，不持有不代表今天卖，可能是维持前一天的状态！！！！！</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][<span class=\"number\">0</span>]代表第i天持有股票的最多现金，dp[i][<span class=\"number\">1</span>]代表第i天不持有股票股票所得最多现金，注意注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态，也就是第二维的<span class=\"number\">0</span>和<span class=\"number\">1</span>代表持有和不持有，第一维只代表天</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">第i天持有股票即dp[i][<span class=\"number\">0</span>]</span><br><span class=\"line\">持有表示可能之前就买了，那么就保持上一天的状态呗，也就是等于dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">也可能表示今天买了，那么就是-price[i]</span><br><span class=\"line\">所以dp[i][<span class=\"number\">0</span>] = max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">第i天不持有股票即dp[i][<span class=\"number\">1</span>]</span><br><span class=\"line\">不持有表示之前早就卖了，那就维持前一天的状态，dp[i-<span class=\"number\">1</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">也可能今天卖了，那就是dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>]+prices[i],也就是前一天还是持有的状态，然后今天卖了，其实前一天的价格是负数，因为你持有了，加上今天的价格，就是利润</span><br><span class=\"line\">dp[i][<span class=\"number\">1</span>] = max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], prices[i] + dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>从递推公式可以看到，需要依赖dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>]和dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序，从前往后</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//动态规划</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];<span class=\"comment\">//0代表持有</span></span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">//1代表卖出，初始化不持有就表示现金为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], -prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">1</span>];<span class=\"comment\">//用第二个维度的1是因为，本题不持有股票状态所得金钱一定比持有股票状态得到的多！</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//贪心算法，找最左最小值</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">low</span> <span class=\"operator\">=</span>  Integer.MAX_VALUE;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            low = Math.min(low, prices[i]);<span class=\"comment\">//找最左最小值</span></span><br><span class=\"line\">            result = Math.max(result, prices[i] - low);<span class=\"comment\">//取最大利润</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"122-买卖股票的最佳时机2-medium\"><a href=\"#122-买卖股票的最佳时机2-medium\" class=\"headerlink\" title=\"122 买卖股票的最佳时机2 medium\"></a>122 买卖股票的最佳时机2 medium</h3><p>和上一题的区别是，这个题可以每天进行买卖，也就是可以多次买卖。最多只能持有一股股票，也可以先购买，然后在同一天出售。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] - prices[i], dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>]);<span class=\"comment\">//唯一的区别，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//贪心</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            result += Math.max(prices[i] - prices[i - <span class=\"number\">1</span>], <span class=\"number\">0</span>);<span class=\"comment\">//把每次正利润都累加，所以这里用一个0来比较</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"123-买卖股票最佳时机3-hard\"><a href=\"#123-买卖股票最佳时机3-hard\" class=\"headerlink\" title=\"123 买卖股票最佳时机3 hard\"></a>123 买卖股票最佳时机3 hard</h3><p>限制了最多可以完成两笔交易！也就是买卖一次，可以买卖两次，也可以不买卖。这题难不少！！</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这题和之前的状态不一样，之前的第二个维度，<span class=\"number\">0</span>代表持有，<span class=\"number\">1</span>代表不持有</span><br><span class=\"line\"><span class=\"number\">1.</span>确定下标含义</span><br><span class=\"line\"></span><br><span class=\"line\">而本题只能最多买卖<span class=\"number\">2</span>次，那么可以设置<span class=\"number\">5</span>个状态，也是第二个维度来表示</span><br><span class=\"line\"><span class=\"number\">0</span>代表不操作</span><br><span class=\"line\"><span class=\"number\">1</span>代表第一次持有</span><br><span class=\"line\"><span class=\"number\">2</span>代表第一次不持有</span><br><span class=\"line\"><span class=\"number\">3</span>代表第二次持有</span><br><span class=\"line\"><span class=\"number\">4</span>代表第二次不持有</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>递推公式</span><br><span class=\"line\">以dp[i][<span class=\"number\">1</span>]为例</span><br><span class=\"line\">操作一：第i天买入股票了，那么dp[i][<span class=\"number\">1</span>] = dp[i-<span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i]，注意这里是前一天的<span class=\"number\">0</span></span><br><span class=\"line\">操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][<span class=\"number\">1</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">取他们最大</span><br><span class=\"line\"></span><br><span class=\"line\">其他一样递推</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span></span><br><span class=\"line\">只需要初始化买入状态，即便第二次买入可能要考虑第一次买入</span><br><span class=\"line\">总之 dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>],dp[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = -price[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序就是从左到右</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//0没有操作，1第一次持有，2第一次不持有，3第二次持有，4第二次不持有</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">5</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">1</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">3</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>];<span class=\"comment\">//不写也能通过</span></span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] - prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">2</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] + prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">3</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>] - prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">4</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">4</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] + prices[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"188-买卖股票最佳时机4-hard\"><a href=\"#188-买卖股票最佳时机4-hard\" class=\"headerlink\" title=\"188 买卖股票最佳时机4 hard\"></a>188 买卖股票最佳时机4 hard</h3><p>最多可以完成k笔交易，和上一题没啥区别，就是k次而已。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span> k, <span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (prices.length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;<span class=\"comment\">//唯一区别，为了满足测试用例</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">2</span> * k + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">2</span> * k + <span class=\"number\">1</span>; i = i + <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt; <span class=\"number\">2</span> * k + <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">                dp[i][j] = Math.max(dp[i - <span class=\"number\">1</span>][j], dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + (<span class=\"type\">int</span>)Math.pow(-<span class=\"number\">1</span>,j) * prices[i]);<span class=\"comment\">//注意int</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">2</span> * k];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"309-最佳买卖股票时机含冷冻期-medium-1\"><a href=\"#309-最佳买卖股票时机含冷冻期-medium-1\" class=\"headerlink\" title=\"309 最佳买卖股票时机含冷冻期 medium\"></a>309 最佳买卖股票时机含冷冻期 medium</h3><p>比122多了一个冷冻期，支持多次交易，但是也不会太容易</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">关键在于有一个冷冻期，那么本题设置<span class=\"number\">4</span>种状态</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>持有（可能是保持前一天的持有状态，可能是今天买入）</span><br><span class=\"line\"><span class=\"number\">2.</span>不持有（这个不一样，反正今天不能卖！），两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span><br><span class=\"line\"><span class=\"number\">3.</span>卖出（也就是把之前股票问题的不持有状态拆成两个状态，一个不持有，一个卖出，等下讲解）</span><br><span class=\"line\"><span class=\"number\">4.</span>冷冻期，只有一天</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>递推公式</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>持有状态下</span><br><span class=\"line\"><span class=\"number\">1.1</span> 保持前一天的持有状态</span><br><span class=\"line\"><span class=\"number\">1.2</span> 昨天是冷冻期，今天买入</span><br><span class=\"line\"><span class=\"number\">1.3</span> 之前早就卖出股票并且度过了冷冻期，今天可以买入</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>不持有状态下</span><br><span class=\"line\"><span class=\"number\">2.1</span> 保持前一天的不持有的状态</span><br><span class=\"line\"><span class=\"number\">2.2</span> 冷冻期（这个不容易想到，因为冷冻期代表你已经卖了股票了，你可以保持这个状态表示不持有）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>卖出</span><br><span class=\"line\"><span class=\"number\">3.1</span> 前一天持有了才能卖出</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>冷冻期</span><br><span class=\"line\"><span class=\"number\">4.1</span> 前一天卖出就会触发冷冻期</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化</span><br><span class=\"line\">只需要设置持有状态下就可以，其他均为<span class=\"number\">0</span>，也就是dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -price[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序就是从前到后</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">4</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>] - prices[i], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] - prices[i]));</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">3</span>]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">2</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i];</span><br><span class=\"line\">            dp[i][<span class=\"number\">3</span>] = dp[i - <span class=\"number\">1</span>][<span class=\"number\">2</span>]; </span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">1</span>], Math.max(dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">2</span>], dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">3</span>]));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"714-买卖股票的最佳时机含手续费-medium\"><a href=\"#714-买卖股票的最佳时机含手续费-medium\" class=\"headerlink\" title=\"714 买卖股票的最佳时机含手续费 medium\"></a>714 买卖股票的最佳时机含手续费 medium</h3><p>也是无限次交易，只是多了一个手续费，参考122就行啦，多一个手续费。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProfit</span><span class=\"params\">(<span class=\"type\">int</span>[] prices, <span class=\"type\">int</span> fee)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[prices.length][<span class=\"number\">2</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = -prices[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>] - prices[i]);</span><br><span class=\"line\">            dp[i][<span class=\"number\">1</span>] = Math.max(dp[i - <span class=\"number\">1</span>][<span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][<span class=\"number\">0</span>] + prices[i] - fee);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[prices.length - <span class=\"number\">1</span>][<span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"300-最长递增子序列-medium-1\"><a href=\"#300-最长递增子序列-medium-1\" class=\"headerlink\" title=\"300 最长递增子序列 medium\"></a>300 最长递增子序列 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</span><br><span class=\"line\"><span class=\"number\">2.</span>位置i的最长升序子序列等于j从<span class=\"number\">0</span>到i-<span class=\"number\">1</span>各个位置的最长升序子序列 + <span class=\"number\">1</span> 的最大值。所以要用双重循环</span><br><span class=\"line\"><span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">这里注意j是大小是从<span class=\"number\">0</span>到i(不包含i)，我们需要取dp[j] + <span class=\"number\">1</span>的最大值</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化，这里和之前的dp问题有些不一样，每一个i的长度至少都是可以为<span class=\"number\">1</span>，所以全部先设置为<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">4.</span>顺序遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(dp, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>];<span class=\"comment\">//不能设置为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class=\"line\">                    dp[i] = Math.max(dp[i], dp[j] + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    result = Math.max(result, dp[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;<span class=\"comment\">//本题不能直接用一维数组最后一个位置的值来返回，</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"674-最长连续递增序列-easy\"><a href=\"#674-最长连续递增序列-easy\" class=\"headerlink\" title=\"674 最长连续递增序列 easy\"></a>674 最长连续递增序列 easy</h3><p>和上一题的区别是，本题要求连续，上一题的话可以隔开元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。</span><br><span class=\"line\"><span class=\"number\">2.</span><span class=\"keyword\">if</span> (nums[i] &gt; nums[i - <span class=\"number\">1</span>]) dp[i] = Math.max(dp[i], dp[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>);因为要连续，所以需要比较上一个，而不是像上一题一样从<span class=\"number\">0</span>到j去找</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化，也是全部初试化为<span class=\"number\">1</span>，因为每个i</span><br><span class=\"line\"><span class=\"number\">4.</span>确定遍历顺序，就是从前到后</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findLengthOfLCIS</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(dp, <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>];<span class=\"comment\">//不能设置为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                dp[i] = dp[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;<span class=\"comment\">//注意没有max，要理解上题为什么有max</span></span><br><span class=\"line\">                result = Math.max(dp[i], result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;<span class=\"comment\">//本题不能直接用一维数组最后一个位置的值来返回，</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"718-最长重复子数组-medium\"><a href=\"#718-最长重复子数组-medium\" class=\"headerlink\" title=\"718 最长重复子数组 medium\"></a>718 最长重复子数组 medium</h3><p>也是连续子序列问题，但是这里是两个数组的对比</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">本题的含义不一样！！！注意看！！！本题的含义不一样！！！注意看！！！本题的含义不一样！！！注意看！！！</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][j] ：以下标i-<span class=\"number\">1</span>为结尾的A（指第一个数组），和以下标j-<span class=\"number\">1</span>为结尾的B（指第二个数组），最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i-<span class=\"number\">1</span>为结尾的A（指第一个数组）” 标明一定是 以A[i-<span class=\"number\">1</span>]为结尾的字符串 ）</span><br><span class=\"line\">以前都是下标i，但是本题是下标i-<span class=\"number\">1</span>，我是这么觉得的，因为比较的时候，从<span class=\"number\">0</span>开始的话，往前面推是-<span class=\"number\">1</span>，因为这里涉及两个数组，不方便，而且我们回过头去看之前的dp问题，也是有i-<span class=\"number\">1</span>的元素在的，而本题是同时比较两个数组</span><br><span class=\"line\"><span class=\"number\">2.</span>当A[i - <span class=\"number\">1</span>] 和B[j - <span class=\"number\">1</span>]相等的时候，dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化，<span class=\"number\">0</span>即可，dp[i][<span class=\"number\">0</span>] 和dp[<span class=\"number\">0</span>][j]初始化为<span class=\"number\">0</span>，java的话本来就默认<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>循环遍历，从前到后，第一组先，然后再第二组</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findLength</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length + <span class=\"number\">1</span>][nums2.length + <span class=\"number\">1</span>];<span class=\"comment\">//注意两个数组可能大小是不一样的！！！！</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];<span class=\"comment\">//方便在遍历的时候就找到最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums1[i - <span class=\"number\">1</span>] == nums2[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;<span class=\"comment\">//没有max比较</span></span><br><span class=\"line\">                    result = Math.max(result, dp[i][j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;<span class=\"comment\">//本题不能直接用二维数组最后一个位置的值来返回</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"1143-最长公共子序列-medium-1\"><a href=\"#1143-最长公共子序列-medium-1\" class=\"headerlink\" title=\"1143 最长公共子序列 medium\"></a>1143 最长公共子序列 medium</h3><p>连续的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]：长度为[<span class=\"number\">0</span>, i - <span class=\"number\">1</span>]的字符串text1与长度为[<span class=\"number\">0</span>, j - <span class=\"number\">1</span>]的字符串text2的最长公共子序列长度为 dp[i][j]</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">text1[i-<span class=\"number\">1</span>] 与 text2[j-<span class=\"number\">1</span>]相同情况下</span><br><span class=\"line\">如果text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">text1[i-<span class=\"number\">1</span>] 与 text2[j-<span class=\"number\">1</span>]不相同情况下(重点理解这里，不是太好理解)</span><br><span class=\"line\">如果text1[i - <span class=\"number\">1</span>] 与 text2[j - <span class=\"number\">1</span>]不相同，那就看看text1[<span class=\"number\">0</span>, i - <span class=\"number\">2</span>]与text2[<span class=\"number\">0</span>, j - <span class=\"number\">1</span>]的最长公共子序列 和 text1[<span class=\"number\">0</span>, i - <span class=\"number\">1</span>]与text2[<span class=\"number\">0</span>, j - <span class=\"number\">2</span>]的最长公共子序列，取最大的。</span><br><span class=\"line\">dp[i][j] = max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>统一初始化为<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>从前到后遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestCommonSubsequence</span><span class=\"params\">(String text1, String text2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[text1.length() + <span class=\"number\">1</span>][text2.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (text1.charAt(i - <span class=\"number\">1</span>) == text2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);<span class=\"comment\">//这个不容易理解</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result =Math.max(dp[i][j], result);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;<span class=\"comment\">//其实本题是可以直接返回dp[text1.length()][text2.length()]，不需要result也可以。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"最长序列问题总结\"><a href=\"#最长序列问题总结\" class=\"headerlink\" title=\"最长序列问题总结\"></a>最长序列问题总结</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">总体分为几种情况的组合，单数组和双数组，连续或者子序</span><br><span class=\"line\"><span class=\"number\">1.</span>定义</span><br><span class=\"line\">如果是单数组，就直接定义一维的，直接按照<span class=\"number\">0</span>~i-<span class=\"number\">1</span>的位置来即可，定义长度就是数组长度，但是如果是双数组，用i-<span class=\"number\">1</span>代表dp[i][j]更好，也就是长度需要加<span class=\"number\">1</span>，同时双数组就定义两个维度。</span><br><span class=\"line\"><span class=\"number\">2.</span>状态转移方程需要根据题目意思来</span><br><span class=\"line\"><span class=\"number\">3.</span>确定初始化，对于单数组，都是比较自己，因为单独一个元素就是一个长度序列，所以应该全部初始化为<span class=\"number\">1</span>，但是对于双数组，则需要比较，所以在比较的情况下再确定长度，也就是初始化为<span class=\"number\">0</span>即可。</span><br><span class=\"line\"><span class=\"number\">4.</span>从前到后遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br><span class=\"line\"></span><br><span class=\"line\">另外说几点，对于求连续的，不需要max来比较，直接前一个位置+<span class=\"number\">1</span>就行</span><br><span class=\"line\">但是对于子序，需要考虑前面的所有情况</span><br><span class=\"line\"></span><br><span class=\"line\">另外说下关于返回值的问题，以前我们的dp问题，都能用数组的最后一个位置的值返回，但是本系列只有<span class=\"number\">1143</span>可以这么做</span><br><span class=\"line\">我的理解是这样的，最重要是看dp的定义</span><br><span class=\"line\"><span class=\"number\">300</span>：i之前包括i的以nums[i]结尾最长上升子序列的长度，以他为结尾，意味着他要包含进去，但是包含他的，不一定是最长的长度，所以要不断找最大值</span><br><span class=\"line\"><span class=\"number\">674</span>：以下标i为结尾的数组的连续递增的子序列长度为dp[i]，也是和上面一样的意思去判断</span><br><span class=\"line\"><span class=\"number\">718</span>：以下标i-<span class=\"number\">1</span>为结尾的A，和以下标j-<span class=\"number\">1</span>为结尾的B，最长重复子数组长度为dp[i][j]，也是和上面一样</span><br><span class=\"line\">所以上面三个题，都需要来比较来找到最大值</span><br><span class=\"line\"><span class=\"number\">1143</span>：长度为[<span class=\"number\">0</span>,i-<span class=\"number\">1</span>]的字符串text1与长度为[<span class=\"number\">0</span>,j-<span class=\"number\">1</span>]的字符串text2的最长公共子序列长度为dp[i][j]</span><br><span class=\"line\"></span><br><span class=\"line\">当然了，其实我是在知道定义后写的，至于<span class=\"number\">1143</span>为什么不是以结尾来定义，还没弄明白，如果觉得不好记，统一用max比较也可以</span><br></pre></td></tr></table></figure>\n<h3 id=\"1035-不相交的线-medium\"><a href=\"#1035-不相交的线-medium\" class=\"headerlink\" title=\"1035 不相交的线 medium\"></a>1035 不相交的线 medium</h3><p>需要拆解为，两个字符串的最长公共子序列的长度！也就是和上一题一毛一样！ </p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxUncrossedLines</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length + <span class=\"number\">1</span>][nums2.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums1[i - <span class=\"number\">1</span>] == nums2[j - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = Math.max(result, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"53-最大子数组和-medium-1\"><a href=\"#53-最大子数组和-medium-1\" class=\"headerlink\" title=\"53 最大子数组和 medium\"></a>53 最大子数组和 medium</h3><p>这个题是连续部分，不是子序，这个题一开始还有点懵，需要理解一下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i]：包括下标i之前的最大连续子序列和为dp[i]。</span><br><span class=\"line\"><span class=\"number\">2.</span>两个方向来推：<span class=\"number\">2.1</span> dp[i-<span class=\"number\">1</span>]+nums[i]，即：nums[i] <span class=\"number\">2.2</span>加入当前连续子序列和nums[i]，即：从头开始计算当前连续子序列和</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化为<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4.</span>从前到后遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxSubArray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dp[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dp[i] = Math.max(dp[i - <span class=\"number\">1</span>] + nums[i], nums[i]);</span><br><span class=\"line\">            sum = Math.max(sum, dp[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"392-判断子序列-medium\"><a href=\"#392-判断子序列-medium\" class=\"headerlink\" title=\"392 判断子序列 medium\"></a>392 判断子序列 medium</h3><p>和1143,1035差不多，但是本题注意是s是否t的子序列，也就是最长子序列长度必须要为s的长度才可以。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isSubsequence</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length() + <span class=\"number\">1</span>][t.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i - <span class=\"number\">1</span>) == t.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i - <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                max = Math.max(max, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max == s.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"115-不同的子序列-hard\"><a href=\"#115-不同的子序列-hard\" class=\"headerlink\" title=\"115 不同的子序列 hard\"></a>115 不同的子序列 hard</h3><p>这个题真的超级难懂</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1143</span>是找最长公共子序列</span><br><span class=\"line\">而本题是字符串s有很多个子序列(不一定连续)，这些子序列字符串中，字符串t出现了多少次？</span><br><span class=\"line\">也就是计算在 s 的子序列中 t 出现的个数。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]：以i-<span class=\"number\">1</span>为结尾的s子序列中出现以j-<span class=\"number\">1</span>为结尾的t的个数为dp[i][j]。</span><br><span class=\"line\"><span class=\"number\">2.</span>递推顺序（https:<span class=\"comment\">//leetcode.cn/problems/distinct-subsequences/solution/tu-jie-dong-tai-gui-hua-by-cyingenohalt-nnlc/）</span></span><br><span class=\"line\">第一种情况s[i-<span class=\"number\">1</span>]与t[j-<span class=\"number\">1</span>]不相等</span><br><span class=\"line\">第一种解释：我们发现当sub_s新增了一个长度后，如果新增的字符（当前sub_s尾字符），与sub_t尾字符不匹配，那么似乎在sub_s上多了个<span class=\"string\">&quot;没用&quot;</span>的字符，sub_s所有子序列字符串中sub_t出现的次数没有任何变化。因此在这种状态下：dp[i][j]=dp[i-<span class=\"number\">1</span>][j];</span><br><span class=\"line\">第二种解释：s[i−<span class=\"number\">1</span>]不能和t[j−<span class=\"number\">1</span>] 匹配，因此只考虑t[j-<span class=\"number\">1</span>]作为s[i-<span class=\"number\">2</span>]的子序列，子序列个数为dp[i-<span class=\"number\">1</span>][j]dp[i−<span class=\"number\">1</span>][j]</span><br><span class=\"line\"></span><br><span class=\"line\">第二种情况：s[i-<span class=\"number\">1</span>]与t[j-<span class=\"number\">1</span>]相等</span><br><span class=\"line\">第一种解释：如果新加入sub_s的这个字符与sub_t尾字符相匹配时，在没有增加这个字符的情况下，sub_t出现的次数是dp[i-<span class=\"number\">1</span>][j], 现在增加了并且和sub_t尾字符相匹配，因此还要在这个基础上加上两者此前的状态下的次数，即dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]，因为相比此前，两者都多了同一个字符，与两者没有加上这个相同字符时情况是一样的。因此这种情况下总和是dp[i-<span class=\"number\">1</span>][j]+dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化</span><br><span class=\"line\">如果 j=<span class=\"number\">0</span> 即 t[j]为空字符串，由于空字符串是任何字符串的子序列，因此对任意dp[i][<span class=\"number\">0</span>]=<span class=\"number\">1</span>；</span><br><span class=\"line\">如果 i=<span class=\"number\">0</span>即 s[i]为空字符串，t[j]为非空字符串，由于非空字符串不是空字符串的子序列，因此 dp[<span class=\"number\">0</span>][j]=<span class=\"number\">0</span>。<span class=\"comment\">//这个java默认，可以不用管</span></span><br><span class=\"line\"><span class=\"number\">4.</span>从前到后遍历，从<span class=\"number\">1</span>开始</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">这个题为什么没有加<span class=\"number\">1</span>操作，因为这个题是求出现的次数，如果你下一个字符是相等的，那么他们的出现次数是和之前一样的（我自己理解，不一定对）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numDistinct</span><span class=\"params\">(String s, String t)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length() + <span class=\"number\">1</span>][t.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i - <span class=\"number\">1</span>) == t.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + dp[i - <span class=\"number\">1</span>][j]; </span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[s.length()][t.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"583-两个字符串的删除操作-medium\"><a href=\"#583-两个字符串的删除操作-medium\" class=\"headerlink\" title=\"583 两个字符串的删除操作 medium\"></a>583 两个字符串的删除操作 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">和上一题的区别是，本题可以任意删除其中一个字符串</span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]：以i-<span class=\"number\">1</span>为结尾的字符串word1，和以j-<span class=\"number\">1</span>位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">情况<span class=\"number\">1</span>：当word1[i-<span class=\"number\">1</span>]与word2[j-<span class=\"number\">1</span>]相同的时候</span><br><span class=\"line\">可以理解为，相同，所以不用删，那就复用上一次的结果</span><br><span class=\"line\">dp[i][j]=dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">情况<span class=\"number\">2</span>：当word1[i-<span class=\"number\">1</span>]与word2[j-<span class=\"number\">1</span>]不相同的时候，有三种情况</span><br><span class=\"line\">删word1[i - <span class=\"number\">1</span>]，最少操作次数为dp[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span></span><br><span class=\"line\">删word2[j - <span class=\"number\">1</span>]，最少操作次数为dp[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span></span><br><span class=\"line\">同时删word1[i - <span class=\"number\">1</span>]和word2[j - <span class=\"number\">1</span>]，操作的最少次数为dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>，因为每操作一次，就要加一，这里同时各操作了一次</span><br><span class=\"line\">dp[i][j] = min(&#123;dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>, dp[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>, dp[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化</span><br><span class=\"line\">dp[i][<span class=\"number\">0</span>]：word2为空字符串，以i-<span class=\"number\">1</span>为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][<span class=\"number\">0</span>] = i。</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][i]：word1为空字符串，以i-<span class=\"number\">1</span>为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显dp[<span class=\"number\">0</span>][i] = i。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>从前到后遍历</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[word1.length() + <span class=\"number\">1</span>][word2.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= word2.length(); i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1.charAt(i - <span class=\"number\">1</span>) == word2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>, Math.min(dp[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span>, dp[i][j - <span class=\"number\">1</span>] + <span class=\"number\">1</span>));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;      </span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[word1.length()][word2.length()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"72-编辑距离-hard-1\"><a href=\"#72-编辑距离-hard-1\" class=\"headerlink\" title=\"72 编辑距离 hard\"></a>72 编辑距离 hard</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">上一题是任何一个字符串都能删除，本题的话，可以进行删，改，增，或者不操作</span><br><span class=\"line\">我看题解的时候，官方表达的意思是两个字符都能操作，但是实际题目意思，我感觉是只能操作<span class=\"number\">1</span>，然后让其变成<span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>dp[i][j] 表示以下标i-<span class=\"number\">1</span>为结尾的字符串word1，和以下标j-<span class=\"number\">1</span>为结尾的字符串word2，最近编辑距离为dp[i][j]。</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式，分为两个情况</span><br><span class=\"line\">情况<span class=\"number\">1</span>：word1[i-<span class=\"number\">1</span>] == word2[j-<span class=\"number\">1</span>]</span><br><span class=\"line\">dp[i][j] = dp[i - <span class=\"number\">1</span>][j] + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">情况<span class=\"number\">2</span>：word1[i-<span class=\"number\">1</span>] != word2[j-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">操作<span class=\"number\">1</span>：word1删除一个元素<span class=\"comment\">//word1的[0,i-1]位置与word2的[0,j]位置的字符已匹配, 加1代表执行word1[i]的删除操作</span></span><br><span class=\"line\">dp[i][j] = dp[i-<span class=\"number\">1</span>][j] + <span class=\"number\">1</span></span><br><span class=\"line\">操作<span class=\"number\">2</span>：word2删除一个元素（相当于word1的插入操作）</span><br><span class=\"line\">dp[i][j] = dp[i][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span><span class=\"comment\">//word1的[0,i]位置与word2的[0,j-1]位置的字符已匹配, 加1代表执行word1[i]的插入操作</span></span><br><span class=\"line\">操作<span class=\"number\">3</span>：word1替换操作</span><br><span class=\"line\">dp[i][j] = dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]+<span class=\"number\">1</span><span class=\"comment\">//word1的[0,i-1]位置与word2的[0,j-1]位置的字符已匹配, 加1代表执行word1[i]-&gt;word2[j]的替换操作</span></span><br><span class=\"line\">然后取他们的最小值，即</span><br><span class=\"line\">dp[i][j] = min(&#123;dp[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>], dp[i-<span class=\"number\">1</span>][j], dp[i][j-<span class=\"number\">1</span>]&#125;) + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化dp</span><br><span class=\"line\">和上一题一样</span><br><span class=\"line\">dp[i][<span class=\"number\">0</span>]就应该是i，对word1里的元素全部做删除操作，即：dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">dp[<span class=\"number\">0</span>][i]就应该是i，对word2里的元素全部做删除操作，即：dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序</span><br><span class=\"line\">从前到后</span><br><span class=\"line\"><span class=\"number\">5.</span>推导公式</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">minDistance</span><span class=\"params\">(String word1, String word2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[word1.length() + <span class=\"number\">1</span>][word2.length() + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class=\"line\">            dp[i][<span class=\"number\">0</span>] = i;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= word2.length(); i++) &#123;</span><br><span class=\"line\">            dp[<span class=\"number\">0</span>][i] = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (word1.charAt(i - <span class=\"number\">1</span>) == word2.charAt(j - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.min(dp[i - <span class=\"number\">1</span>][j], Math.min(dp[i][j - <span class=\"number\">1</span>], dp[i - <span class=\"number\">1</span>][j - <span class=\"number\">1</span>])) + <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dp[word1.length()][word2.length()];        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"647-回文子串-medium\"><a href=\"#647-回文子串-medium\" class=\"headerlink\" title=\"647 回文子串 medium\"></a>647 回文子串 medium</h3><p>本题遍历顺序不一样，注意看！！！本题是连续的字符串，而且是算个数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">注意本题的dp数组是布尔类型   </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为<span class=\"literal\">true</span>，否则为<span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">分为两种情况</span><br><span class=\"line\">情况<span class=\"number\">1</span>：s[i]与s[j]相等</span><br><span class=\"line\"><span class=\"number\">2.1</span>下标i与j相同，同一个字符例如a，是回文子串</span><br><span class=\"line\"><span class=\"number\">2.2</span>下标i与j相差为<span class=\"number\">1</span>，例如aa，也是回文子串</span><br><span class=\"line\"><span class=\"number\">2.</span>3i与j相差大于<span class=\"number\">1</span>的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是i+<span class=\"number\">1</span>与j-<span class=\"number\">1</span>区间，这个区间是不是回文就看dp[i+<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]是否为<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">情况<span class=\"number\">1</span>：s[i]与s[j]不相等</span><br><span class=\"line\">直接为<span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>初始化dp</span><br><span class=\"line\">一开始当然都是<span class=\"literal\">false</span>啦，都没有匹配上</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序，不是按顺序，不是按顺序，不是按顺序！！！！</span><br><span class=\"line\">我们可以看到<span class=\"number\">2.3</span>这情况，根据dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]是否为<span class=\"literal\">true</span>，在对dp[i][j]进行赋值<span class=\"literal\">true</span>的，然后dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>]在dp[i][j]左下角，也就是遍历顺序是下到上，左到右，可以理解为从斜左下角推导到右上角。</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">countSubstrings</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">boolean</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">boolean</span>[s.length()][s.length()];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> ; i--) &#123;<span class=\"comment\">//从下到上遍历</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i; j &lt; s.length(); j++) &#123;<span class=\"comment\">//注意j不是从0开始，然后从左到右</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class=\"number\">1</span> || dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>])) &#123;<span class=\"comment\">//j - i &lt;= 1包含2.1和2.2情况，dp[i + 1][j - 1]也就是2.3情况</span></span><br><span class=\"line\">                    result++;</span><br><span class=\"line\">                    dp[i][j] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">             &#125;    </span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"516-最长回文子序列-medium\"><a href=\"#516-最长回文子序列-medium\" class=\"headerlink\" title=\"516 最长回文子序列 medium\"></a>516 最长回文子序列 medium</h3><p>注意本题是求子序的最长长度</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</span><br><span class=\"line\"><span class=\"number\">2.</span>确定递推公式</span><br><span class=\"line\">s[i]与s[j]相同，那么dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>;<span class=\"comment\">//因为长度加2，注意里面是i+1和j-1的基础上，是字串的基础上加2</span></span><br><span class=\"line\">s[i]与s[j]不相同（可以看卡哥的图），说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</span><br><span class=\"line\">加入s[j]的回文子序列长度为dp[i + <span class=\"number\">1</span>][j]。加入s[i]的回文子序列长度为dp[i][j - <span class=\"number\">1</span>]。那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\"><span class=\"number\">3.</span>初始化dp</span><br><span class=\"line\">首先要理解定义，所以i和j相等，那长度肯定是<span class=\"number\">1</span>的，因为他们就是指示一个字符</span><br><span class=\"line\">dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">4.</span>遍历顺序，和上面一题一样，也是从左下角到右上角，也就是从下到上，从左到右</span><br><span class=\"line\"><span class=\"number\">5.</span>推导数组</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestPalindromeSubseq</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[][] dp = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[s.length()][s.length()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            dp[i][i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> dp[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> s.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class=\"line\">                    dp[i][j] = dp[i + <span class=\"number\">1</span>][j - <span class=\"number\">1</span>] + <span class=\"number\">2</span>;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    dp[i][j] = Math.max(dp[i + <span class=\"number\">1</span>][j], dp[i][j - <span class=\"number\">1</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = Math.max(result, dp[i][j]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;<span class=\"comment\">//return dp[0][s.length() - 1];也可以但是不好记</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">如果找更大的元素，需要构建单调递减栈</span><br><span class=\"line\">如果找更小的元素，需要构建单调递增栈</span><br></pre></td></tr></table></figure>\n<h3 id=\"739-每日温度-medium\"><a href=\"#739-每日温度-medium\" class=\"headerlink\" title=\"739 每日温度 medium\"></a>739 每日温度 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单调栈方法,通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</span></span><br><span class=\"line\">分为三种情况</span><br><span class=\"line\">栈里面是存储数组的下标，而不是值</span><br><span class=\"line\"><span class=\"number\">1.</span>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">把T[i]的下标入栈</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">把T[i]的下标入栈</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">计算距离放入result中，将栈顶元素弹出。</span><br><span class=\"line\">等到不符合条件了（也就是栈里面的元素下标已经大于当前T[i]），那么这时候就把T[i]入栈</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在LinkedList中，poll方法是检测并删除头元素，peek是单纯检索头元素（类似于栈，头元素就是最后加进去的那个元素）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] dailyTemperatures(<span class=\"type\">int</span>[] temperatures) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[temperatures.length];</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;</span><br><span class=\"line\">                stack.push(i);<span class=\"comment\">//合并情况1和2</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<span class=\"comment\">//情况3，注意栈不能为空</span></span><br><span class=\"line\">                    result[stack.peek()] =  i - stack.peek();</span><br><span class=\"line\">                    stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//暴力循环，找到第一个大的就break，但是复杂度很高</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] dailyTemperatures(<span class=\"type\">int</span>[] temperatures) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[temperatures.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; temperatures.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temperatures[j] &gt; temperatures[i]) &#123;</span><br><span class=\"line\">                    result[i] = j - i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"496-下一个更大元素1-easy\"><a href=\"#496-下一个更大元素1-easy\" class=\"headerlink\" title=\"496 下一个更大元素1 easy\"></a>496 下一个更大元素1 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单调栈，和上一题的思路是差不多的，关键在于，这里是两个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">首先我们用一个map把数组<span class=\"number\">1</span>的&lt;数值，下标&gt;存进去</span><br><span class=\"line\"></span><br><span class=\"line\">然后操作数组<span class=\"number\">2</span>，数组<span class=\"number\">2</span>的操作逻辑也是</span><br><span class=\"line\"><span class=\"number\">1.</span>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">把T[i]的下标入栈</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">把T[i]的下标入栈</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</span><br><span class=\"line\">这时候可以找到右边第一个比自己大的元素</span><br><span class=\"line\">判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</span><br><span class=\"line\">然后出栈</span><br><span class=\"line\"></span><br><span class=\"line\">当不满足大于栈顶元素，就把当前元素入栈</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        Arrays.fill(result, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class=\"line\">            map.put(nums1[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        stack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums2.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums2[i] &lt;= nums2[stack.peek()]) &#123;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (map.containsKey(nums2[stack.peek()])) &#123;</span><br><span class=\"line\">                        <span class=\"type\">Integer</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> map.get(nums2[stack.peek()]);</span><br><span class=\"line\">                        result[index] = nums2[i];</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//暴力出奇迹</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElement(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span>[] nums2) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums1.length];</span><br><span class=\"line\">        Arrays.fill(result, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> j + <span class=\"number\">1</span>; x &lt; nums2.length;x++) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">if</span> (nums2[x] &gt; nums1[i]) &#123;</span><br><span class=\"line\">                            result[i] = nums2[x];</span><br><span class=\"line\">                            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"503-下一个更大元素2-medium\"><a href=\"#503-下一个更大元素2-medium\" class=\"headerlink\" title=\"503 下一个更大元素2 medium\"></a>503 下一个更大元素2 medium</h3><p>本题关键在于 如何处理循环数组</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//处理循环数组，太秒了，循环的时候，把数组变成两倍的长度，然后用%可以走两遍数组</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElements(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Arrays.fill(result, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        stack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; <span class=\"number\">2</span> * nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i % nums.length] &lt;= nums[stack.peek()]) &#123;</span><br><span class=\"line\">                stack.push(i % nums.length);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; nums[i % nums.length] &gt; nums[stack.peek()]) &#123;</span><br><span class=\"line\">                    result[stack.peek()] = nums[i % nums.length];<span class=\"comment\">//或者用poll，那么pop就省略了</span></span><br><span class=\"line\">                    stack.pop();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.push(i % nums.length);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//暴力出奇迹，找完右边再重新找左边</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] nextGreaterElements(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        Arrays.fill(result, -<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class=\"line\">                    result[i] = nums[j];</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; i; x++) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (nums[x] &gt; nums[i]) &#123;</span><br><span class=\"line\">                        result[i] = nums[x];</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length - <span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; nums[nums.length - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                result[nums.length - <span class=\"number\">1</span>] = nums[i];</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"42-接雨水-hard\"><a href=\"#42-接雨水-hard\" class=\"headerlink\" title=\"42 接雨水 hard\"></a>42 接雨水 hard</h3><p>高频率题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">单调栈做法</span><br><span class=\"line\">单调递减栈</span><br><span class=\"line\"></span><br><span class=\"line\">注意用单调栈的做法计算面积和双指针略有不同,双指针直接就是先找到最左边最高，最右边最高，然后用他们比较小的那个减去当前高度就是体积（因为当前高度的宽是<span class=\"number\">1</span>，不用长*宽了）</span><br><span class=\"line\"></span><br><span class=\"line\">栈：先进去的是栈底，</span><br><span class=\"line\">当前元素小于等于栈顶元素，那么就入栈</span><br><span class=\"line\"></span><br><span class=\"line\">如果大于了栈顶元素，这时候就可以找出三个元素</span><br><span class=\"line\">right下标就是当前i小标</span><br><span class=\"line\">mid就是栈顶下标，用了之后要取出来，为什么要取出来，因为用过了。</span><br><span class=\"line\">left就是下一个栈顶下标，这里不用取出来，因为下一次还要用</span><br><span class=\"line\">h是高度，右边下标的对应的值（是指，不是下标数）和左边小标对应的值找到较小那个-当前i的高度</span><br><span class=\"line\">w是宽度，用右边下标-左边下标-<span class=\"number\">1</span>（-<span class=\"number\">1</span>是因为算两个栈中间的区域长度，<span class=\"number\">0</span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>，比如<span class=\"number\">0</span>和<span class=\"number\">3</span>，中间的长度就是<span class=\"number\">2</span>,<span class=\"number\">3</span>-<span class=\"number\">0</span>-<span class=\"number\">1</span>=<span class=\"number\">2</span>）</span><br><span class=\"line\">然后h*w即可</span><br><span class=\"line\">这里为什么和双指针那个算法不一样，其实我认为是因为单调栈这样出栈顺序，不是他的左边最高和右边最高，这样出栈是单纯能算出体积</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">trap</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> stack.poll();<span class=\"comment\">//拿到后要取出</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (!stack.isEmpty()) &#123;<span class=\"comment\">//注意这里，有点不一样，还需要判断一次</span></span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> stack.peek();</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">h</span> <span class=\"operator\">=</span> Math.min(height[right], height[left]) - height[mid];</span><br><span class=\"line\">                        <span class=\"type\">int</span> <span class=\"variable\">w</span> <span class=\"operator\">=</span> right - left - <span class=\"number\">1</span>;</span><br><span class=\"line\">                        sum += h * w;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">本题用双指针解法（但是力扣官方是写暴力解法），这个比较容易懂</span><br><span class=\"line\"></span><br><span class=\"line\">首先清楚，第一根柱子和最后一根柱子，是不接雨水的，所以遍历的时候跳过这两个</span><br><span class=\"line\"></span><br><span class=\"line\">然后要清楚，雨水是如何计算的</span><br><span class=\"line\">对于每一列，我们都要找出他左边最高的一个柱子（包含第一格），同时找出右边最高的柱子（包含最后一格）</span><br><span class=\"line\">然后选出他们两个高度之间小的那个，减去本列的高度，就是雨水的体积，因为长度都是<span class=\"number\">1</span>，所以<span class=\"number\">1</span>*高度就是雨水体积</span><br><span class=\"line\"></span><br><span class=\"line\">那么我们只要找到每一格的高度，就可以完成任务</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">trap</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; height.length - <span class=\"number\">1</span>; i++) &#123;<span class=\"comment\">//第一格和最后一格不算</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">lheight</span> <span class=\"operator\">=</span> height[i];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">rheight</span> <span class=\"operator\">=</span> height[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">l</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; l &lt; i; l++) &#123;<span class=\"comment\">//找到本列左边最高的柱子，包含第一格</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height[l] &gt; lheight) lheight = height[l];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; r &lt; height.length; r++) &#123;<span class=\"comment\">//找到本列右边最高的柱子，包含最后一格</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height[r] &gt; rheight) rheight = height[r];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">high</span> <span class=\"operator\">=</span> Math.min(lheight, rheight) - height[i];<span class=\"comment\">//雨水取决于短板</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (high &gt; <span class=\"number\">0</span>) sum += high;<span class=\"comment\">//其实不用high大于0也是可以的</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"84-柱状图中最大的矩形-hard\"><a href=\"#84-柱状图中最大的矩形-hard\" class=\"headerlink\" title=\"84 柱状图中最大的矩形 hard\"></a>84 柱状图中最大的矩形 hard</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">找每个柱子左右侧的第一个高度值小于该柱子的柱子，注意和上一题的区别</span><br><span class=\"line\"></span><br><span class=\"line\">单调栈：栈顶到栈底：从大到小（每插入一个新的小数值时，都要弹出先前的大数值）</span><br><span class=\"line\">栈顶，栈顶的下一个元素，即将入栈的元素：这三个元素组成了最大面积的高度和宽度</span><br><span class=\"line\">情况一：当前遍历的元素heights[i]大于栈顶元素的情况</span><br><span class=\"line\">情况二：当前遍历的元素heights[i]等于栈顶元素的情况</span><br><span class=\"line\">情况三：当前遍历的元素heights[i]小于栈顶元素的情况</span><br><span class=\"line\"></span><br><span class=\"line\">这里是找到左右侧高度小于当前的，所以用单调递增栈</span><br><span class=\"line\"></span><br><span class=\"line\">当前高度大于等于栈顶，入栈</span><br><span class=\"line\">当前高度小于栈顶</span><br><span class=\"line\"></span><br><span class=\"line\">mid高度栈顶下标，用了需要取出来</span><br><span class=\"line\">right就是当前元素下标</span><br><span class=\"line\">left就是栈顶下标（之前取出了一个mid，这个是新栈顶）</span><br><span class=\"line\"></span><br><span class=\"line\">面积就是 (right-left-<span class=\"number\">1</span>)*mid</span><br><span class=\"line\">减去<span class=\"number\">1</span>可以继续看下面的图理解</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">largestRectangleArea</span><span class=\"params\">(<span class=\"type\">int</span>[] heights)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] newheights = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[heights.length + <span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class=\"line\">            newheights[i + <span class=\"number\">1</span>] = heights[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        heights = newheights;</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        stack.push(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (heights[i] &gt;= heights[stack.peek()]) &#123;</span><br><span class=\"line\">                stack.push(i);<span class=\"comment\">//情况1和2</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">mid</span> <span class=\"operator\">=</span> heights[stack.poll()];</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> i;</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> stack.peek();</span><br><span class=\"line\">                    <span class=\"type\">int</span> <span class=\"variable\">width</span> <span class=\"operator\">=</span> right - left - <span class=\"number\">1</span>;</span><br><span class=\"line\">                    result = Math.max(result, width * mid);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>借用别人画的图来理解如何计算面积<br>比如计算5（下标是2）的最大面积<br>左边小的是1（下标1），右边小的是2（下标4）<br>面积就是（4-1-1）* 5&#x3D;10</p>\n<p>比如计算6（下标是3）的最大面积<br>左边小的是5（下标2），右边小的是2（下标4）<br>面积就是（4-2-1）* 6&#x3D;6</p>\n<p><img src=\"/images/leetcode-java/84.png\"></p>\n<h2 id=\"hot100\"><a href=\"#hot100\" class=\"headerlink\" title=\"hot100\"></a>hot100</h2><h3 id=\"3-无重复字符的最长子串\"><a href=\"#3-无重复字符的最长子串\" class=\"headerlink\" title=\"3 无重复字符的最长子串\"></a>3 无重复字符的最长子串</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">用一个map来保存字符</span><br><span class=\"line\">双指针的做法</span><br><span class=\"line\">一个start 一个end</span><br><span class=\"line\">如果发现重复了（map中），需要重新找到start的位置，新start的位置需要这个字符在map的位置然后加<span class=\"number\">1</span>，但是start不能往回走（因为单纯加<span class=\"number\">1</span>的话，可能会回退，因为字符可能在最开始的位置），所以要在start和 这个字符在map的数字加<span class=\"number\">1</span>比较，确定新start的位置</span><br><span class=\"line\">长度就是end-start+<span class=\"number\">1</span>,在过程中记录即可，然后把字符加入到map中</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">lengthOfLongestSubstring</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> s.length(), ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Map&lt;Character, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>, start = <span class=\"number\">0</span>; end &lt; n; end++) &#123;</span><br><span class=\"line\">            <span class=\"type\">char</span> <span class=\"variable\">alpha</span> <span class=\"operator\">=</span> s.charAt(end);</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.containsKey(alpha)) &#123;</span><br><span class=\"line\">                start = Math.max(map.get(alpha) + <span class=\"number\">1</span>, start);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            ans = Math.max(ans, end - start + <span class=\"number\">1</span>);</span><br><span class=\"line\">            map.put(s.charAt(end), end);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-最长回文子串-medium\"><a href=\"#5-最长回文子串-medium\" class=\"headerlink\" title=\"5 最长回文子串 medium\"></a>5 最长回文子串 medium</h3><p>思路挺简单的，仔细阅读下代码，用的是暴力法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestPalindrome</span><span class=\"params\">(String s)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j - i + <span class=\"number\">1</span> &gt; len &amp;&amp; valid(s, i, j)) &#123;<span class=\"comment\">//注意这里是把整个s带进去</span></span><br><span class=\"line\">                    len = j-i+<span class=\"number\">1</span>;</span><br><span class=\"line\">                    begin = i;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.substring(begin, begin + len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">valid</span><span class=\"params\">(String s, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> &#123;       </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> start, j = end; i &lt; j; i++,j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"11-盛水最多的容器-medium\"><a href=\"#11-盛水最多的容器-medium\" class=\"headerlink\" title=\"11 盛水最多的容器 medium\"></a>11 盛水最多的容器 medium</h3><p>需要和42 84一起看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">本题的思路是用双指针，一个最左边，一个最右边</span></span><br><span class=\"line\"><span class=\"comment\">每次都是固定长的那根，然后计算面积（较短的那根*距离）</span></span><br><span class=\"line\"><span class=\"comment\">然后每次移动比较短的那根</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxArea</span><span class=\"params\">(<span class=\"type\">int</span>[] height)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; height.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span>; j &lt; height.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">high</span> <span class=\"operator\">=</span> Math.min(height[i], height[j]);</span><br><span class=\"line\">                <span class=\"type\">int</span> <span class=\"variable\">width</span> <span class=\"operator\">=</span> j - i;</span><br><span class=\"line\">                result = Math.max(result, high * width);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"128-最长连续序列-medium\"><a href=\"#128-最长连续序列-medium\" class=\"headerlink\" title=\"128 最长连续序列 medium\"></a>128 最长连续序列 medium</h3><p>注意这个题，是指内部可以组成的连续的序列，比如1,2,3,4,5，累加1这种，但是，不是指必须他们在位置上连续，他们一开始是打乱的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">用set，因为数组是可能中间有连续一样的数字，set可以用来保留一个</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestConsecutive</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        HashSet&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : nums) &#123;</span><br><span class=\"line\">            set.add(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(i - <span class=\"number\">1</span>)) &#123;<span class=\"comment\">//只有当num-1不存在时，才开始向后遍历，如果没有这句话，会超时的</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (set.contains(i)) &#123;</span><br><span class=\"line\">                    temp++;</span><br><span class=\"line\">                    i++;<span class=\"comment\">//在这里进行++，因为连续嘛，比前一个数大于1就可以连续</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                result = Math.max(result, temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"146-LRU缓存-medium\"><a href=\"#146-LRU缓存-medium\" class=\"headerlink\" title=\"146 LRU缓存 medium\"></a>146 LRU缓存 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">LinkedHashMap是尾插</span><br><span class=\"line\"></span><br><span class=\"line\">LinkedHashMap和HashMap不一样，HashMap是无序的，前者是有序的，所以不能用hashmap来做这个题</span><br><span class=\"line\"><span class=\"number\">1.</span>查询操作</span><br><span class=\"line\">存在的话，先对他进行最近操作处理，然后返回值</span><br><span class=\"line\">否则返回-<span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span>插入操作</span><br><span class=\"line\">如果这个key本身存在的话，先对他进行最近操作处理，然后把value更新，并且中断操作</span><br><span class=\"line\">如果key不存在，先判断插入的时候，是否满了，先删除头部的老节点，然后再插入</span><br><span class=\"line\"></span><br><span class=\"line\">最近操作处理</span><br><span class=\"line\">先存这个value，然后删除key，然后再重新put即可</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">LRUCache</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> capacity;</span><br><span class=\"line\">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LRUCache</span><span class=\"params\">(<span class=\"type\">int</span> capacity)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.capacity = capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.containsKey(key)) &#123;</span><br><span class=\"line\">            makeRecently(key);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.get(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">put</span><span class=\"params\">(<span class=\"type\">int</span> key, <span class=\"type\">int</span> value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.containsKey(key)) &#123;</span><br><span class=\"line\">            makeRecently(key);</span><br><span class=\"line\">            cache.put(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;<span class=\"comment\">//这个很重要，不然不能通过，否则会往下走</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cache.size() == <span class=\"built_in\">this</span>.capacity) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">oldKey</span> <span class=\"operator\">=</span> cache.keySet().iterator().next();<span class=\"comment\">//学习这个写法</span></span><br><span class=\"line\">            cache.remove(oldKey);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">makeRecently</span><span class=\"params\">(<span class=\"type\">int</span> key)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">value</span> <span class=\"operator\">=</span> cache.get(key);</span><br><span class=\"line\">        cache.remove(key);</span><br><span class=\"line\">        cache.put(key, value);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"152-乘积最大子数组-medium\"><a href=\"#152-乘积最大子数组-medium\" class=\"headerlink\" title=\"152 乘积最大子数组 medium\"></a>152 乘积最大子数组 medium</h3><p>对比53题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这题最大的不同点在于需要维护两个dp数组，一个最大的，一个最小的</span><br><span class=\"line\">一般我们都是维护一个最大的即可，这里说下如果不维护一个最小的</span><br><span class=\"line\">比如[-<span class=\"number\">2</span>,<span class=\"number\">3</span>,-<span class=\"number\">4</span>]</span><br><span class=\"line\">dp[<span class=\"number\">0</span>] = -<span class=\"number\">2</span></span><br><span class=\"line\">dp[<span class=\"number\">1</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">dp[<span class=\"number\">2</span>] = <span class=\"number\">3</span></span><br><span class=\"line\">但是，其实正确答案是<span class=\"number\">24</span>，因为可能中间是负数，后面是负数，就可以变成正数，但是单纯用max的话，会忽略掉中间负数的情况</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">maxProduct</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dpmax = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"type\">int</span>[] dpmin = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"comment\">//Arrays.fill(dp, 1);</span></span><br><span class=\"line\">        dpmax[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        dpmin[<span class=\"number\">0</span>] = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            dpmax[i] = Math.max(Math.max(nums[i] * dpmax[i - <span class=\"number\">1</span>], nums[i] * dpmin[i - <span class=\"number\">1</span>]), nums[i]);</span><br><span class=\"line\">            dpmin[i] = Math.min(Math.min(nums[i] * dpmax[i - <span class=\"number\">1</span>], nums[i] * dpmin[i - <span class=\"number\">1</span>]), nums[i]);</span><br><span class=\"line\">            result = Math.max(result, dpmax[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"136-只出现一次的数字-easy\"><a href=\"#136-只出现一次的数字-easy\" class=\"headerlink\" title=\"136 只出现一次的数字 easy\"></a>136 只出现一次的数字 easy</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">异或运算</span></span><br><span class=\"line\"><span class=\"comment\">十进制下相同数字异或结果为0，数字a与0异或结果仍为原来的数字a。</span></span><br><span class=\"line\"><span class=\"comment\">还有就是异或运算支持结合律，所以你的数组顺序是无所谓的</span></span><br><span class=\"line\"><span class=\"comment\">计算完后剩下的就是出现那一个的数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">single</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums) &#123;</span><br><span class=\"line\">            single ^= num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> single;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这个不符合题目不用额外空间的要求，但是能pass</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">singleNumber</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            map.put(i, map.getOrDefault(i, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(i) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"283-移动零-easy\"><a href=\"#283-移动零-easy\" class=\"headerlink\" title=\"283 移动零 easy\"></a>283 移动零 easy</h3><p>注意题目要在原数组上操作</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span></span><br><span class=\"line\"><span class=\"comment\">其实第一次看这个做法，还挺奇妙的，只用了一次遍历</span></span><br><span class=\"line\"><span class=\"comment\">可以理解为，left会指向下一个0，然后等着right找到不是0，进行交换</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">moveZeroes</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[right] != <span class=\"number\">0</span>) &#123;<span class=\"comment\">////当前元素!=0，就把其交换到左边，等于0的会交换到右边</span></span><br><span class=\"line\">                swap(nums, left, right);</span><br><span class=\"line\">                left++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">swap</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> nums[left];</span><br><span class=\"line\">        nums[left] = nums[right];</span><br><span class=\"line\">        nums[right] = temp; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这种是补0，好像和意思不太对，但是也能做</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">moveZeroes</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                nums[slow] = nums[i];</span><br><span class=\"line\">                slow++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> slow; j &lt; nums.length; j++) &#123;</span><br><span class=\"line\">            nums[j] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"169-多数元素-easy\"><a href=\"#169-多数元素-easy\" class=\"headerlink\" title=\"169 多数元素 easy\"></a>169 多数元素 easy</h3><p>统计次数，用map</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">majorityElement</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            map.put(i, map.getOrDefault(i, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(i) &gt; nums.length / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                result = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"234-回文链表-easy\"><a href=\"#234-回文链表-easy\" class=\"headerlink\" title=\"234 回文链表 easy\"></a>234 回文链表 easy</h3><p>自己写的，看</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">isPalindrome</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">StringBuilder</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuilder</span>();</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            s.append(cur.val);</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> s.toString();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> a.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"448-找到所有数组中消失的数字-easy\"><a href=\"#448-找到所有数组中消失的数字-easy\" class=\"headerlink\" title=\"448 找到所有数组中消失的数字 easy\"></a>448 找到所有数组中消失的数字 easy</h3><p>用set来保存数，然后遍历1~n，看看哪个数不在就添加</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title function_\">findDisappearedNumbers</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedList</span>&lt;&gt;();</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            set.add(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!set.contains(i + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                list.add(i + <span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"287-寻找重复数-medium\"><a href=\"#287-寻找重复数-medium\" class=\"headerlink\" title=\"287 寻找重复数 medium\"></a>287 寻找重复数 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不过不满足题目的要求</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findDuplicate</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        HashMap&lt;Integer, Integer&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> nums[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums) &#123;</span><br><span class=\"line\">            map.put(i, map.getOrDefault(i, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (map.get(i) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                result = i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"560-和为-K-的子数组-medium\"><a href=\"#560-和为-K-的子数组-medium\" class=\"headerlink\" title=\"560 和为 K 的子数组 medium\"></a>560 和为 K 的子数组 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个解法很少见，先找到每个下标，然后从这个下标开始倒着加，如果中途满足k，就计数</span><br><span class=\"line\">当然顺着加也可以（注释中的语句），即先固定左边界，然后枚举右边界哈，</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subarraySum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">start</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; start &lt; nums.length; start++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> start; end &gt;= <span class=\"number\">0</span>; end--) &#123;<span class=\"comment\">//for (int end = start; end &lt; nums.length; end++)也可以，这个我觉得更好理解，倒着来太麻烦   </span></span><br><span class=\"line\">                sum += nums[end];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sum == k) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>前缀和解法，前缀和就是前i个数的和，left和right区间内的前缀和相减如果等于k，就说明中间有连续数组是为k</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">subarraySum</span><span class=\"params\">(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> k)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] presum = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length + <span class=\"number\">1</span>];</span><br><span class=\"line\">        presum[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;<span class=\"comment\">//注意第一个不算，置为0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            presum[i + <span class=\"number\">1</span>] = presum[i] + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> i + <span class=\"number\">1</span> ; j &lt;= nums.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (presum[j] - presum[i] == k) &#123;</span><br><span class=\"line\">                    count++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"581-最短无序连续子数组-medium\"><a href=\"#581-最短无序连续子数组-medium\" class=\"headerlink\" title=\"581 最短无序连续子数组 medium\"></a>581 最短无序连续子数组 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">其实就是新建一个拍好序的数组，然后从左边遍历看第一个不正确的数，记录left</span><br><span class=\"line\">然后从右边遍历第一个不正确的数，记录right。这里需要注意，不能用sortnum = num，因为这样操作是浅拷贝，如果你把sortnum排序了，那么num也会变的！！！！</span><br><span class=\"line\">比如[<span class=\"number\">2</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">8</span>,<span class=\"number\">10</span>,<span class=\"number\">9</span>,<span class=\"number\">15</span>]，最终记录left为<span class=\"number\">1</span>，right为<span class=\"number\">5</span>，然后务必+<span class=\"number\">1</span>才是长度</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">findUnsortedSubarray</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> sortnum[] = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            sortnum[i] = nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        Arrays.sort(sortnum);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (left &lt; nums.length &amp;&amp; nums[left] == sortnum[left]) &#123;</span><br><span class=\"line\">            left++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (right &gt; <span class=\"number\">0</span> &amp;&amp; nums[right] == sortnum[right]) &#123;</span><br><span class=\"line\">            right--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (right == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                 </span><br><span class=\"line\">        <span class=\"keyword\">return</span> right - left + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"461-汉明距离-easy\"><a href=\"#461-汉明距离-easy\" class=\"headerlink\" title=\"461 汉明距离 easy\"></a>461 汉明距离 easy</h3><p>单纯计算二进制，然后比较</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">hammingDistance</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span> || y != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> != y % <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                result++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x = x / <span class=\"number\">2</span>;</span><br><span class=\"line\">            y = y / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-两数相加-medium\"><a href=\"#2-两数相加-medium\" class=\"headerlink\" title=\"2 两数相加 medium\"></a>2 两数相加 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">这个题的关键是遇到两位数的和，需要把十位上的数，累加到下一次中，举个例子</span><br><span class=\"line\">[<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">[<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">他们的和是<span class=\"number\">7</span>,<span class=\"number\">10</span>,<span class=\"number\">10</span>，第二个数已经超过了<span class=\"number\">10</span>，把<span class=\"number\">0</span>保留，<span class=\"number\">1</span>留在下一个中，就是<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">11</span>，然后<span class=\"number\">11</span>又超过了两位数，所以把<span class=\"number\">1</span>留下，最后是<span class=\"number\">7</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"comment\">//ListNode pre = dump;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">carry</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">null</span> || l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> l1 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l1.val;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">y</span> <span class=\"operator\">=</span> l2 == <span class=\"literal\">null</span> ? <span class=\"number\">0</span> : l2.val;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> x + y + carry;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            sum = sum % <span class=\"number\">10</span>;</span><br><span class=\"line\">            cur.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum);<span class=\"comment\">//这里前面不需要再声明ListNode</span></span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry == <span class=\"number\">1</span>) &#123;<span class=\"comment\">//处理最后遗留的carry，因为最大也就是相加之和为18，所以只能是1</span></span><br><span class=\"line\">            cur.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"338-比特位计数-easy\"><a href=\"#338-比特位计数-easy\" class=\"headerlink\" title=\"338 比特位计数 easy\"></a>338 比特位计数 easy</h3><p>很简单，计算二进制即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] countBits(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[n + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span> ; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            result[i] = count(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">count</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (x != <span class=\"number\">0</span>) &#123;<span class=\"comment\">//注意条件是x != 0</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x % <span class=\"number\">2</span> == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                sum++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            x = x / <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"23-合并K个升序链表-hard\"><a href=\"#23-合并K个升序链表-hard\" class=\"headerlink\" title=\"23 合并K个升序链表 hard\"></a>23 合并K个升序链表 hard</h3><p>思想参考21题，放在本题就是合并两两链表。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">mergeKLists</span><span class=\"params\">(ListNode[] lists)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class=\"line\">            dump = mergetwoLists(dump, lists[i]); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump;   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">mergetwoLists</span><span class=\"params\">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//这个可要可不要</span></span><br><span class=\"line\">        <span class=\"comment\">/*  </span></span><br><span class=\"line\"><span class=\"comment\">        if (list1 == null || list2 == null) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            return list1 == null ? list2 : list1;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        */</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (list1 != <span class=\"literal\">null</span> &amp;&amp; list2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = list1 == <span class=\"literal\">null</span> ? list2 : list1;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"238-除自身以外数组的乘积-medium\"><a href=\"#238-除自身以外数组的乘积-medium\" class=\"headerlink\" title=\"238 除自身以外数组的乘积 medium\"></a>238 除自身以外数组的乘积 medium</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">先算左侧数字累积，也就是当前元素之前元素的累积（不含当前元素）</span><br><span class=\"line\">然后倒过来算累计，也就是当前元素之后元素的累积，在左侧数字累积的基础上相乘，这样就可以算出除自身外的累积</span><br><span class=\"line\">总体思想也就是左侧数字的累积乘以右侧数字的累积，也就是除了这个数的累积。</span><br><span class=\"line\"></span><br><span class=\"line\">不能用暴力，否则超时</span><br><span class=\"line\"></span><br><span class=\"line\">比如[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">左侧数字累积是[<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">算完之后用一个R来保存右侧的累积，初始化R为<span class=\"number\">1</span></span><br><span class=\"line\">虽然在第一轮中，<span class=\"number\">4</span>这个位置的左边已经全部算好了，但是我们需要改变R的累积来为<span class=\"number\">3</span>这个数字服务，所以倒着的时候还是先从最后一个数开始</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] productExceptSelf(<span class=\"type\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[nums.length];</span><br><span class=\"line\">        result[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">            result[i] = result[i - <span class=\"number\">1</span>] * nums[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">Right</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;<span class=\"comment\">//代表右侧数字的累积</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> nums.length - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            result[i] = Right * result[i];</span><br><span class=\"line\">            Right = Right * nums[i];<span class=\"comment\">//累积</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"148-排序链表-medium\"><a href=\"#148-排序链表-medium\" class=\"headerlink\" title=\"148 排序链表 medium\"></a>148 排序链表 medium</h3><p>和下一个方法一样的思路，但是这个方法可能好理解一点</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">归并排序，可以看下面一个图</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">切割环节：</span></span><br><span class=\"line\"><span class=\"comment\">使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</span></span><br><span class=\"line\"><span class=\"comment\">找到中点 slow 后，执行 slow.next = null 将链表切断</span></span><br><span class=\"line\"><span class=\"comment\">递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 </span></span><br><span class=\"line\"><span class=\"comment\">cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">merge环节：</span></span><br><span class=\"line\"><span class=\"comment\">就是21题源代码</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">如果下面写成fast = head</span></span><br><span class=\"line\"><span class=\"comment\">传入head只有两个节点的时候，slow会指向第二个节点，此时left : head-&gt;node1-&gt;null ; right:null; 然后在ListNode left = sortList(head);这一步会发生stackoverflow</span></span><br><span class=\"line\"><span class=\"comment\">但是如果要用fast = head</span></span><br><span class=\"line\"><span class=\"comment\">需要把while写成while (fast != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">sortList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1、递归结束条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//  需要找到链表中间节点的前一个节点（876类似，但是又不同于876）</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next.next;<span class=\"comment\">//不能写成head，但是可以写成head.next，但是建议还是写成next.next，和下面对应</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">null</span> &amp;&amp; fast.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head2</span> <span class=\"operator\">=</span> slow.next;</span><br><span class=\"line\">        slow.next=<span class=\"literal\">null</span>;<span class=\"comment\">//切割出来</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeTwoLists(sortList(head), sortList(head2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">mergeTwoLists</span><span class=\"params\">(ListNode list1, ListNode list2)</span> &#123;<span class=\"comment\">//21题原题代码</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (list1 != <span class=\"literal\">null</span> &amp;&amp; list2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = list1 == <span class=\"literal\">null</span> ? list2 :list1;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/leetcode-java/148.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">归并排序方法</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">sortList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1、递归结束条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2、找到链表中间节点并断开链表 &amp; 递归下探</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">midNode</span> <span class=\"operator\">=</span> middleNode(head);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">rightHead</span> <span class=\"operator\">=</span> midNode.next;</span><br><span class=\"line\">        midNode.next = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">left</span> <span class=\"operator\">=</span> sortList(head);<span class=\"comment\">//递归</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">right</span> <span class=\"operator\">=</span> sortList(rightHead);<span class=\"comment\">//递归</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 3、当前层业务操作（合并有序链表）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mergeTwoLists(left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//  需要找到链表中间节点的前一个节点（876类似，但是又不同于876）</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">middleNode</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span> || head.next == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">slow</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">fast</span> <span class=\"operator\">=</span> head.next.next;<span class=\"comment\">//不能写成head，但是可以写成head.next</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != <span class=\"literal\">null</span> &amp;&amp; fast.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">mergeTwoLists</span><span class=\"params\">(ListNode list1, ListNode list2)</span> &#123;<span class=\"comment\">//21题原代码，合并两个升序链表</span></span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (list1 != <span class=\"literal\">null</span> &amp;&amp; list2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = list1 == <span class=\"literal\">null</span> ? list2 :list1;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>自己写的解法，思路很简单，先用Arraylist来记录数字，然后排序，这里注意是用Collections.sort(list);进行排序，而不是Arrays.sort(list)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不过这个不太符合题目的要求，时间和空间复杂度会很高</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">sortList</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">len</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            list.add(cur.val);</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        Collections.sort(list);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">temp</span> <span class=\"operator\">=</span> dump;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> x : list) &#123;</span><br><span class=\"line\">            temp.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(x);</span><br><span class=\"line\">            temp = temp.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"200-岛屿数量-medium\"><a href=\"#200-岛屿数量-medium\" class=\"headerlink\" title=\"200 岛屿数量 medium\"></a>200 岛屿数量 medium</h3><p>对比695</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">和695非常类似，一开始我用695的方法，在判断上是只要面积大于0就加1，但是感觉有点冗余，下面是去掉了冗余的代码</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">numIslands</span><span class=\"params\">(<span class=\"type\">char</span>[][] grid)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; j &lt; grid[<span class=\"number\">0</span>].length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (grid[i][j] == <span class=\"string\">&#x27;1&#x27;</span>) &#123;</span><br><span class=\"line\">                    dfs(grid, i, j);</span><br><span class=\"line\">                    result++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">dfs</span><span class=\"params\">(<span class=\"type\">char</span>[][] grid, <span class=\"type\">int</span> cur_i, <span class=\"type\">int</span> cur_j)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur_i &lt; <span class=\"number\">0</span> || cur_j &lt;  <span class=\"number\">0</span> || cur_i == grid.length || cur_j == grid[<span class=\"number\">0</span>].length || grid[cur_i][cur_j] != <span class=\"string\">&#x27;1&#x27;</span>)  &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        grid[cur_i][cur_j] = <span class=\"string\">&#x27;0&#x27;</span>;<span class=\"comment\">//这个很重要，把走过的格子置为0，不然会一直重复dfs</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span>[] next_cur_i = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,-<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] next_cur_j = &#123;<span class=\"number\">1</span>,-<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; index &lt; <span class=\"number\">4</span>; index++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_i</span> <span class=\"operator\">=</span> cur_i + next_cur_i[index];</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">next_j</span> <span class=\"operator\">=</span> cur_j + next_cur_j[index];</span><br><span class=\"line\">            dfs(grid, next_i, next_j);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"208-实现Trie-前缀树-medium\"><a href=\"#208-实现Trie-前缀树-medium\" class=\"headerlink\" title=\"208 实现Trie(前缀树) medium\"></a>208 实现Trie(前缀树) medium</h3><p><a href=\"https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/\">具体看解释看</a>，前缀树的用处：一次建树，多次查询</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Trie</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">class</span> <span class=\"title class_\">TrieNode</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"type\">boolean</span> isEnd;<span class=\"comment\">//该节点是否是一个串的结束</span></span><br><span class=\"line\">        TrieNode[] next;<span class=\"comment\">//指向孩子节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"title function_\">TrieNode</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//初始化</span></span><br><span class=\"line\">            isEnd = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            next = <span class=\"keyword\">new</span> <span class=\"title class_\">TrieNode</span>[<span class=\"number\">26</span>];<span class=\"comment\">//字母映射表</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TrieNode root;<span class=\"comment\">//指向根，后面每次操作，都是从根开始</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Trie</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        root = <span class=\"keyword\">new</span> <span class=\"title class_\">TrieNode</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">insert</span><span class=\"params\">(String word)</span> &#123;<span class=\"comment\">//插入操作</span></span><br><span class=\"line\">        <span class=\"type\">TrieNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//从根开始查</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : word.toCharArray()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node.next[c - <span class=\"string\">&#x27;a&#x27;</span>] == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//如果没有的话，</span></span><br><span class=\"line\">                node.next[c - <span class=\"string\">&#x27;a&#x27;</span>] = <span class=\"keyword\">new</span> <span class=\"title class_\">TrieNode</span>(); <span class=\"comment\">//就开辟一个新的节点</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node.next[c - <span class=\"string\">&#x27;a&#x27;</span>];<span class=\"comment\">//插入完之后指向下一个节点</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.isEnd = <span class=\"literal\">true</span>;<span class=\"comment\">//插入完之后，设置尾巴为true，表示这个词的终点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">search</span><span class=\"params\">(String word)</span> &#123;<span class=\"comment\">//查找操作</span></span><br><span class=\"line\">        <span class=\"type\">TrieNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//从根开始查</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : word.toCharArray()) &#123;</span><br><span class=\"line\">            node =  node.next[c - <span class=\"string\">&#x27;a&#x27;</span>];<span class=\"comment\">//移动下一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//如果空的话直接返回false</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.isEnd;<span class=\"comment\">//注意因为这个是查找整个单词的操作，所以是返回尾巴的isend看看是不是为true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">startsWith</span><span class=\"params\">(String prefix)</span> &#123;<span class=\"comment\">//查找前缀</span></span><br><span class=\"line\">        <span class=\"type\">TrieNode</span> <span class=\"variable\">node</span> <span class=\"operator\">=</span> root;<span class=\"comment\">//从根开始查</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">char</span> c : prefix.toCharArray()) &#123;</span><br><span class=\"line\">            node =  node.next[c - <span class=\"string\">&#x27;a&#x27;</span>];<span class=\"comment\">//移动下一个节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (node == <span class=\"literal\">null</span>) &#123;<span class=\"comment\">//如果空就直接返回false</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;<span class=\"comment\">//注意这里只是查找前缀，所以如果全部都找完了，说明没有false，那么最终就是返回true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"额外练习\"><a href=\"#额外练习\" class=\"headerlink\" title=\"额外练习\"></a>额外练习</h1><h2 id=\"21-合并两个有序链表-easy\"><a href=\"#21-合并两个有序链表-easy\" class=\"headerlink\" title=\"21 合并两个有序链表 easy\"></a>21 合并两个有序链表 easy</h2><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">mergeTwoLists</span><span class=\"params\">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (list1 != <span class=\"literal\">null</span> &amp;&amp; list2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (list2.val &gt;= list1.val) &#123;</span><br><span class=\"line\">                cur.next = list1;</span><br><span class=\"line\">                list1 = list1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (list2.val &lt; list1.val) &#123;</span><br><span class=\"line\">                cur.next = list2;</span><br><span class=\"line\">                list2 = list2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            cur = cur.next;<span class=\"comment\">//判断完记得移到next</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur.next = list1 == <span class=\"literal\">null</span> ? list2 : list1;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"先递增再递减数组找最大值\"><a href=\"#先递增再递减数组找最大值\" class=\"headerlink\" title=\"先递增再递减数组找最大值\"></a>先递增再递减数组找最大值</h2><p>别人面试碰到的题</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">(1)如果数组先增大再减小，峰值就是最大值。</span></span><br><span class=\"line\"><span class=\"comment\">(2)如果数组单调递增，最后一个元素就是最大值。</span></span><br><span class=\"line\"><span class=\"comment\">(3)如果数组单调递减，第一个元素就是最大值。</span></span><br><span class=\"line\"><span class=\"comment\">(4)如果数组全部都一样，任何一个元素都是答案，更极端地，如果数组只有一个元素，那么这唯一的元素就是答案。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">作者：analanxingde</span></span><br><span class=\"line\"><span class=\"comment\">链接：https://www.jianshu.com/p/fa328c8a323c</span></span><br><span class=\"line\"><span class=\"comment\">来源：简书</span></span><br><span class=\"line\"><span class=\"comment\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">FindMax</span><span class=\"params\">(<span class=\"type\">int</span> *A, <span class=\"type\">int</span> m)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(m == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;            <span class=\"comment\">//如果数组大小为0，则返回错误</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">begin</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">end</span> <span class=\"operator\">=</span> m - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">MP</span> <span class=\"operator\">=</span>  (begin + end)/<span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(MP &gt; <span class=\"number\">0</span> &amp;&amp; MP &lt; m -<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(A[MP] &gt; A[MP+<span class=\"number\">1</span>] &amp;&amp; A[MP] &gt; A[MP-<span class=\"number\">1</span>])&#123;  <span class=\"comment\">//如果符合条件就返回此值</span></span><br><span class=\"line\">                   <span class=\"keyword\">return</span> MP;        </span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (A[MP] &lt; A[MP+<span class=\"number\">1</span>])&#123;            <span class=\"comment\">//在递增段</span></span><br><span class=\"line\">                begin = MP+ <span class=\"number\">1</span>;</span><br><span class=\"line\">                MP= begin + (end - begin)/<span class=\"number\">2</span>;</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;                                 <span class=\"comment\">//在递减段</span></span><br><span class=\"line\">                end = MP- <span class=\"number\">1</span>;</span><br><span class=\"line\">                MP= begin + (end - begin)/<span class=\"number\">2</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MP == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>; <span class=\"comment\">//如果数组是完全递减的，则第一个值就是最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(MP == m-<span class=\"number\">1</span>) <span class=\"keyword\">return</span> m-<span class=\"number\">1</span>; <span class=\"comment\">//如果数组是完全递增的，则最后一个值为最大值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">longestConsecutive</span><span class=\"params\">(<span class=\"type\">int</span>[] nums)</span> &#123;</span><br><span class=\"line\">        Set&lt;Integer&gt;set=<span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();<span class=\"comment\">//HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i:nums) &#123;</span><br><span class=\"line\">            set.add(i);</span><br><span class=\"line\">        &#125;<span class=\"comment\">//将元素加入集合中</span></span><br><span class=\"line\">        <span class=\"type\">int</span> len=<span class=\"number\">0</span>,max=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i:nums) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!set.contains(i-<span class=\"number\">1</span>))&#123;<span class=\"comment\">//进行判断如果有比当前元素小的元素就直接跳过不在进行长度增长。如果不进行该操作时间会超限</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(set.contains(i)) &#123;</span><br><span class=\"line\">                    len+=<span class=\"number\">1</span>;</span><br><span class=\"line\">                    i+=<span class=\"number\">1</span>;<span class=\"comment\">//取最大连续序列，就一直＋1再判断是否在序列中</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(len&gt;max) &#123;</span><br><span class=\"line\">                    max=len;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            len=<span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">作者：cranky-gausshdx</span><br><span class=\"line\">链接：https:<span class=\"comment\">//leetcode.cn/problems/longest-consecutive-sequence/solution/by-cranky-gausshdx-jm5b/</span></span><br><span class=\"line\">来源：力扣（LeetCode）</span><br><span class=\"line\">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>\n<h2 id=\"14-最长公共前缀-easy\"><a href=\"#14-最长公共前缀-easy\" class=\"headerlink\" title=\"14 最长公共前缀 easy\"></a>14 最长公共前缀 easy</h2><p>注意这个题只是看前缀，而不是共同字符，所以只在最前面开始搜就行</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> strs[<span class=\"number\">0</span>];<span class=\"comment\">//把第一个字符串拿过来</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; strs.length; i++) &#123;<span class=\"comment\">//然后从第二个字符串开始比较</span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;<span class=\"comment\">//为什么在这里写而不是下面写？ 下面有解释</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span>( ;j &lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ans.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ans = ans.substring(<span class=\"number\">0</span>, j);<span class=\"comment\">//因为是前缀，所以肯定是从第一个开始，至于到了哪个是共同，就是看j</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>错误题解，用来解释的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">但是，如果下面这样写的话</span></span><br><span class=\"line\"><span class=\"comment\">[&quot;ab&quot;, &quot;a&quot;]的输出结果是ab，这是错误的，正确结果应该是a，因为第二个字符串长度为1，所以只进行了一次循环后，就不循环了，也就是b这个数都无法比较，所以最终无法进入if语句</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">longestCommonPrefix</span><span class=\"params\">(String[] strs)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">ans</span> <span class=\"operator\">=</span> strs[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> <span class=\"number\">0</span> ;j &lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;<span class=\"comment\">//如果在这里写，那么ans.sub就要在if里面写，因为是局部变量</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ans.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class=\"line\">                    ans = ans.substring(<span class=\"number\">0</span>, j);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125; </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"83-删除排序链表中的重复数字-easy\"><a href=\"#83-删除排序链表中的重复数字-easy\" class=\"headerlink\" title=\"83 删除排序链表中的重复数字 easy\"></a>83 删除排序链表中的重复数字 easy</h2><p>其实很简单，为什么自己一开始想的很复杂呢？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">dump</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(-<span class=\"number\">1</span>);</span><br><span class=\"line\">        dump.next = head;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur != <span class=\"literal\">null</span> &amp;&amp; cur.next != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (cur.val == cur.next.val) &#123;</span><br><span class=\"line\">                cur.next = cur.next.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dump.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"88-合并两个有序数组-easy-1\"><a href=\"#88-合并两个有序数组-easy-1\" class=\"headerlink\" title=\"88 合并两个有序数组 easy\"></a>88 合并两个有序数组 easy</h2><p>在尾巴处进行修改，需要注意的是，本题的nums1大小是m+n，然后最后返回的数组也是nums1</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">merge</span><span class=\"params\">(<span class=\"type\">int</span>[] nums1, <span class=\"type\">int</span> m, <span class=\"type\">int</span>[] nums2, <span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> m - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">k</span> <span class=\"operator\">=</span> m + n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; j &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums2[j] &gt; nums1[i]) &#123;</span><br><span class=\"line\">                nums1[k--] = nums2[j--];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                nums1[k--] = nums1[i--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (j &gt;= <span class=\"number\">0</span>) nums1[k--] = nums2[j--];<span class=\"comment\">//对剩下的nums2进行操作，不需要对nums1进行操作了，因为本质上是原地复制，无意义</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","categories":["学习笔记"],"tags":["Leetcode"]},{"title":"光纤光学笔记","url":"/2020/09/19/%E5%85%89%E7%BA%A4%E5%85%89%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>入门好痛苦，那就现在开始记录笔记吧</p>\n<span id=\"more\"></span>\n<p>笔记来源：1.书籍：《光纤光学》，作者：廖延彪 2.中国MOOC视频 3.百度百科 4.网络上博主写的笔记</p>\n<p>相关量化指标<br>1 SSIM  越大越好<br>2 PSNR  dB为单位的 越大越好？<br>3 MAE 平均绝对误差  越小越好<br>4 NPCC 因为网络解决了回归问题，所以调整回归问题的损失对于优化网络性能是至关重要的。尽管均方误差(MSE)和平均误差(MAE)损失函数对于回归问题是常见的，但研究表明，它们对于该问题来说并不太好，因为输入图像是与基本事实不完全相似的图像。因此，我们选择使用负皮尔逊相关系数(NPCC)损失函数，该函数对这类问题有效</p>\n<p>1.折射率：光在真空中的传播速度与光在该介质中的传播速度之比<br>2.按纤芯折射率分布：1.阶跃折射率光纤(SIOF)—纤芯和包层分界面处，折射率发生突变，2.梯度(渐变)折射率光纤(GIOF)—折射率按照一定函数关系随光纤中心径向距离而连续变化<br>3.光纤结构：纤芯，包层，涂覆层<br>4.纤芯折射率大于芯包折射率是因为要满足全反射条件<br>5.全反射的充要条件：1.光从光密介质射到它与光疏介质的界面上 2.入射角等于或大于临界角<br>6.相干光：在传播过程中保持相同的相位差，可以发生干涉现象的光<br>7.光学4F系统:最简单的来说就是：有两个焦距为f的透镜，相距2f，物距为f，相距也为f。所以是4f系统。只有距离大于4f的系统才能做变焦系统。</p>\n<p>需要解决的盲区：<br>1.相干照明，非相干照明<br>2.计算光学成像领域中，经常使用的神经网络总 体结构是 U 型结构(应该指U-NET结构)</p>\n<p>看论文了解到的知识：<br>1.通常通过使用空间光调制器(SLM)来实现波前整形<br>2.CCD是电荷耦合器件（charge coupled device）的简称，它能够将光线变为电荷并将电荷存储及转移，也可将存储之电荷取出使电压发生变化，因此是理想的CCD相机元件，以其构成的CCD相机具有体积小、重量轻、不受磁场影响、具有抗震动和撞击之特性而被广泛应用。<br>3.DMD(Digital Micromirror Device)数字微镜器件是光开关的一种，利用旋转反射镜实现光开关的开合，开闭时间稍长，为微秒量级。作用过程十分简单，光从光纤中出来，射向DMD的反射镜片，DMD打开的时候，光可经过对称光路进入到另一端光纤；当DMD关闭的时候，即DMD的反射镜产生一个小的旋转，光经过反射后，无法进入对称的另一端，也就达到了光开关关闭的效果。<a href=\"https://www.sohu.com/a/255275407_99961126\">https://www.sohu.com/a/255275407_99961126</a><br>4.皮尔森相关系数也称皮尔森积矩相关系数(Pearson product-moment correlation coefficient) ，是一种线性相关系数，是最常用的一种相关系数。记为r，用来反映两个变量X和Y的线性相关程度，r值介于-1到1之间，绝对值越大表明相关性越强。<br>5.SSIM(在论文补充材料后面有)SSIM取值范围[0,1]，值越大，表示图像失真越小。<br>6.随机介质能够显著地提高成像系统的有效值孔径及视场<br>7.测量随机介质传输矩阵的两个方法:1.从空间域直接测量 2.从空频域的角度测量<br>8.多模光纤的散射作用是由模间色散引起，各模式间因群速度不同从而导致色散</p>\n<p>~.论文上接触到的英语词汇：<br>1.伪影(Artifacts)是指原本被扫描物体并不存在而在图像上却出现的各种形态的影像，伪影大致分为与患者有关和与机器有关的两类。<br>2.grayscale：灰度图<br>3.diffuser:慢射体<br>4.Pearson correlation coefficient (PCC)：皮尔逊相关系数<br>5.specklegram：散斑图<br>6.coupling:耦合<br>7.Phase Retrieval:相位恢复算法<br>8.dispersion:色散<br>9.modal dispersion &#x3D; intermodal dispersion 模间色散<br>10.chromatic dispersion &#x3D; intramodal dispersion 模内色散<br>11.spectra光谱<br>12.superpositions叠加<br>13.scattering media散射介质<br>14.aberrations像差<br>15.granular颗粒<br>16.DP是diffraction pattern 的简写，意为衍射图样<br>17.optical depth 光学深度<br>18.transmission matrix 传输矩阵<br>19.transport free path:自由传播路程<br>20.transport mean free path:平均传播自由程<br>21.optical memory effect:光学记忆效应<br>22.space–bandwidth product:空间带宽积</p>\n<p>光学涉及的数学<br>Hadamard Product：矩阵对应位置相乘</p>\n","categories":["研究生阶段--科研工具，科研网址及科研记录"],"tags":["光纤"]},{"title":"仿牛客网项目记录","url":"/2022/06/07/%E4%BB%BF%E7%89%9B%E5%AE%A2%E7%BD%91%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/","content":"<p>仿牛客网项目笔记，<a href=\"https://www.nowcoder.com/courses/cover/live/246\">点击进入学习地址</a>。</p>\n<span id=\"more\"></span>\n\n<h1 id=\"牛客网项目笔记\"><a href=\"#牛客网项目笔记\" class=\"headerlink\" title=\"牛客网项目笔记\"></a>牛客网项目笔记</h1><p>略有些乱，有空整理下。<br>启动项目之前需要启动的工具有：<br>1.打开MySQL workbench，有时候遇到数据库问题打开就没事啦<br>2.启动kafka（windows下经常奔溃，删除log试试）<br>要保证你当前的路径是D:\\kafka_2.13-3.2.0下哦，用cmd启动<br>bin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties<br>bin\\windows\\kafka-server-start.bat config\\server.properties<br>3.启动ES<br>bin文件夹下的elasticsearch.bat</p>\n<h2 id=\"Spring-Boot进阶，开发社区核心功能\"><a href=\"#Spring-Boot进阶，开发社区核心功能\" class=\"headerlink\" title=\"Spring Boot进阶，开发社区核心功能\"></a>Spring Boot进阶，开发社区核心功能</h2><h3 id=\"首页\"><a href=\"#首页\" class=\"headerlink\" title=\"首页\"></a>首页</h3><p>在没有登录之前，首页会显示若干条网友的帖子信息，首先当然是查询我们的数据库一共有多少条帖子，需要注意有些帖子是黑名单，然后进行一个排序，因为有的帖子是加精华或者置顶。展示帖子的时候，需要考虑页数，因为你不可能展示所有页，可以保留本页的前两页和后两页，当然如果是第一页或者末页你需要考虑一些限制，除此外，你每页展示的帖子也有数量限制，具体可以看数据库怎么计算的。这里我们需要额外考虑一个功能就是查询我的帖子，这是后面额外的功能，可以用动态sql语句来拼接，如果登录了就可以传我的id来查询。默认情况下没有登录，后台首先查询到所有帖子的信息，根据帖子信息可以查询到userid然后可以查到作者名字（post数据库没有存用户名字），用一个map来存储两个参数，一个是post的内容，比如标题呀创建时间之类的，还有一个是username，再用一个ArrayList(名字为discussPosts)来保存这些map，然后通过model来注入传输到index。而计算总页数则单独用实例page来控制，包括页的范围之类。</p>\n<p><strong>HomeController</strong>用来返回主页，调取mapper来获得主页的页数以及内容方法</p>\n<p><strong>DiscussPostMapper</strong>定义两个查询数据库的方法</p>\n<p><strong>discusspost-mapper.xml</strong>具体的数据库语句</p>\n<p>涉及两个实体<strong>Page</strong>和<strong>DiscussPost</strong>，分别是页的各种属性和帖子的各种属性</p>\n<p>涉及网页<strong>Index.html</strong></p>\n<p>本方法没有用到业务层</p>\n<p><strong>关于前台传数据到后台，controller都是用String，对于首页在方法用写了Page page</strong></p>\n<p>需要注意的是，如果没有登录用户，不能显示我要发布这个功能</p>\n<h3 id=\"注册功能\"><a href=\"#注册功能\" class=\"headerlink\" title=\"注册功能\"></a>注册功能</h3><p>输入账号，密码，确认密码，邮箱后，后台首先检查两次密码是否一致，然后检查账号是否存在，不存在的话发送一个链接到指定邮箱，只有用户点击邮箱后的链接才算激活成功。</p>\n<p>User实体定义用户id，用户名，密码，盐，邮箱，类型(管理员之类，普通用户)，激活状态，头像图片链接，创建时间</p>\n<p><strong>LoginController</strong>前台接收了信息后交给<strong>Userservice的register</strong>方法用于判断注册的有效性，比如邮箱是否已经被注册，然后无误后进行注册，有问题会返回一个map给ConTroller并显示错误信息，没问题则告知注册成功并发送首页然后跳转到首页。</p>\n<p>register方法：判断完有效后，注册的时候首先生成随机盐，然后用随机盐+密码的合体转成md5写入表中，类型为普通用户，状态未激活，然后生成一个随机字符串用于生成激活码，接着生成图片和创建时间，写入数据库，接着把生成一个链接，含有激活码和系统为用户生成的id，发送到邮箱等待激活。激活成功会把激活状态更新为1，然后可以登录。</p>\n<p>邮件是用模板引擎渲染的</p>\n<p><strong>UserMapper</strong>定义数据库方法，查id，email，name。更新激活状态，图片url，密码。创建用户</p>\n<p><strong>user-mapper.xml</strong>则是具体的sql语句</p>\n<p>涉及网页<strong>register.html</strong></p>\n<p>工具类<strong>CommunityUtil</strong>用来生成随机数，这个不需要注入，提供的是静态方法</p>\n<p><strong>关于前台传数据到后台，前台定义了username，password，但是后台是定义User user，需要注意的是表单传入的数据可能会很多，通过实体接收比较方便，不然参数太多了。这也是需要对应的，表单参数名与实体属性名对应。</strong></p>\n<h3 id=\"激活功能\"><a href=\"#激活功能\" class=\"headerlink\" title=\"激活功能\"></a>激活功能</h3><p>邮箱收到的链接为<a href=\"http://localhost:8080/community/activation/101/code%EF%BC%8C**LoginController**%E4%BC%9A%E6%8F%90%E5%8F%96id%E5%92%8C%E9%9A%8F%E6%9C%BA%E7%A0%81%EF%BC%8C%E8%AE%A9**userService.activation**%E5%88%A4%E6%96%AD%E6%9C%89%E6%B2%A1%E6%9C%89%E6%BF%80%E6%B4%BB%E8%BF%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%BF%80%E6%B4%BB%E7%A0%81%E6%98%AF%E5%90%A6%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%B8%80%E6%A0%B7%EF%BC%8C%E8%BF%98%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E6%BF%80%E6%B4%BB%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%9C%E9%A1%B5%E3%80%82%E6%BF%80%E6%B4%BB%E6%88%90%E5%8A%9F%E5%B0%B1%E8%B7%B3%E8%BD%AC%E7%99%BB%E5%BD%95%E9%A1%B5%EF%BC%8C%E5%90%A6%E5%88%99%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5%E5%B0%B1%E8%B7%B3%E8%BD%AC%E5%88%B0%E9%A6%96%E9%A1%B5%E3%80%82\">http://localhost:8080/community/activation/101/code，**LoginController**会提取id和随机码，让**userService.activation**判断有没有激活过，以及激活码是否和数据库中的一样，还需要注意有没有重复激活，然后返回一个结果页。激活成功就跳转登录页，否则其他情况就跳转到首页。</a></p>\n<h3 id=\"登录功能验证码\"><a href=\"#登录功能验证码\" class=\"headerlink\" title=\"登录功能验证码\"></a>登录功能验证码</h3><p>登录界面会有验证码，先引入依赖kaptcha，然后再config中配置<strong>KaptchaConfig</strong>由&#x2F;kaptcha响应图片，<strong>LoginController</strong>中的方法是getKaptcha，生成完验证码后存入session，并且将图片响应给浏览器，需要用到response。</p>\n<h3 id=\"登录功能\"><a href=\"#登录功能\" class=\"headerlink\" title=\"登录功能\"></a>登录功能</h3><p>需要输入账号，密码，验证码。<strong>LoginController</strong>首先获取验证码，利用session来获取，首先来判断验证码是否正确，其他都不判断先，还要注意我们验证码本身是否没有响应。验证码正确后接着检查是否选择记住我，注意这是一个布尔值。将前台输入的信息交给<strong>Userservice的login</strong>来判断，判断成功后生成一个登录凭证（每次登录都是一个随机的凭证），这个凭证和id相关联，这样会安全一点，不需要暴露账号密码，用session来保存这个凭证，并由response响应给浏览器。</p>\n<p><strong>关于前台传数据到后台，前台定义了username，password，code，接收也是有这三个值，和注册不太一样，注册直接用实例，我觉得可能这里因为多了一个验证码的原因，user中没有验证码，所以直接定义来获取</strong></p>\n<h3 id=\"登出功能\"><a href=\"#登出功能\" class=\"headerlink\" title=\"登出功能\"></a>登出功能</h3><p><strong>LoginCtroller</strong>首先获取String ticket，用@CookieValue来获取，然后调用<strong>userService.logout</strong>来注销，把登录状态改为1（也就是失效），然后重定向到登录页</p>\n<h3 id=\"拦截器\"><a href=\"#拦截器\" class=\"headerlink\" title=\"拦截器\"></a>拦截器</h3><p>上面的登出功能单纯把数据库表的ticket变成失效，而拦截器是用来检查登录状态的，比如你登录了就显示你的信息。首先是定义<strong>HostHolder</strong>。里面有用户执行的方法，比如设置用户，移除用户。接下来写<strong>LoginTicketInterceptor</strong>，拦截前pre要去数据库看看ticket是否有效，然后到到了post，把信息放到modelAndView的loginUser属性里，这样可以在前端判断是否正确登录了然后并显示，登出之后会销毁。这里和logout的联系关系是，logout设置数据库状态为1，然后pre的时候就可以判断了，如果注销了就执行after把hostHolder销毁掉。</p>\n<h3 id=\"忘记密码并重置\"><a href=\"#忘记密码并重置\" class=\"headerlink\" title=\"忘记密码并重置\"></a>忘记密码并重置</h3><p>前台输入邮箱，然后点击获取验证码，这里需要注意用到了javascript来获取验证码，跳到了路径&#x2F;forget&#x2F;code，然后<strong>Controller的getForgetCode</strong>开始验证邮箱是否存在（<strong>Userservice.verifyEmail</strong>），若存在就发送邮件并且把 验证码传到session中保存，输入验证码提交跳转到&#x2F;forget&#x2F;password。由<strong>controller的resetPassword</strong>进行校验和修改密码<strong>Userservice的resetPassword</strong>别忘了更新密码的时候要获取盐再md5保存。可以学习下<strong>setting.json写法</strong></p>\n<h3 id=\"更新密码\"><a href=\"#更新密码\" class=\"headerlink\" title=\"更新密码\"></a>更新密码</h3><p>这个情况是已经登录了在设置中进行更新密码。所以首先在Controller中用hostHolder获取用户信息，然后由<strong>userService.updatePassword</strong>来校验原始密码并修改，注意了，新密码和确认密码前台来判断即可。老样子，更新密码别忘了盐。</p>\n<h2 id=\"Spring-Boot进阶，开发社区核心功能-1\"><a href=\"#Spring-Boot进阶，开发社区核心功能-1\" class=\"headerlink\" title=\"Spring Boot进阶，开发社区核心功能\"></a>Spring Boot进阶，开发社区核心功能</h2><h3 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h3><p>有了这个功能可以自定义过滤词来替换一些不好言论，需要注意的是要考虑☆赌☆博☆这种情况，因为大家一般不会直接写赌博。首先是定义前缀树的数据结构，然后把我们的过滤敏感词加载到前缀树中初始化。</p>\n<p>1号指针指向前缀树，2号指针和3号指针指向我们的文本，如图所示，敏感词有abc,bf,be，我们的文本是xwabfacff，还要注意的是前缀树需要在叶子节点处标记末端，用false标记</p>\n<p>这里大概讲讲是怎么个过程，详细的具体回顾请debug。第一步生成一个StringBuilder来保存没有敏感文字，然后1号指针指向root，注意root不存储任何的敏感文字，2号指针(begin)是大循环，先判断begin是否超过文本长度，然后进入循环，判断3号指针是否超过文本长度。<strong>情况1</strong>先判断是否有非法符号，比如☆，就跳过这些。然后把字符放进前缀树中查找子节点是否有，没有的话把这个字符加进StringBuilder，然后begin移动一位，同时position移到begin的位置，然后注意了，这时候指针1重新指向根节点，<strong>情况2</strong>继续while循环，如果下级结点和我们的字符匹配到了，然后移动position，然后begin先不动，<strong>情况3</strong>继续while循环，如果下级结点匹配到了叶子节点，也就是发现了敏感词，StringBuilder中存入<em><strong>，position移动一位，begin也移动到position的位置，</strong>情况4</em>*还有一种情况是如果发现了符号，比如☆，如果这时候前缀树还指向根节点，那我们就把符号加进去StringBuilder，如果前缀树指向不在根节点，就直接移动position，跳出循环。<strong>最后一种情况5</strong>，也就是position越界了，但是还没匹配到敏感词，这时候先把begin指向的字符加进去StringBuilder，然后begin移动一位，接着position回到begin的位置，还有前缀树重新回到根节点。</p>\n<p>情况5不好理解，可以试试敏感词为 fabcd，abc。text为ccfabc，debug后你可以可以知道怎么回事了。</p>\n<p>涉及<strong>SensitiveFilter和sensitive-word.txt</strong></p>\n<h3 id=\"发布帖子\"><a href=\"#发布帖子\" class=\"headerlink\" title=\"发布帖子\"></a>发布帖子</h3><p>Contoller用于生成对象DiscussPost来获取题目和内容。然后交给service来处理这些数据写到数据库中，需要注意的是，service部分需要判断用户输入的内容是否合法。前端是在index上用ajax来触发post的，具体看index.js，具体的逻辑是button上点击提交后，ajax会调用一个函数，然后函数传到指定的路径来请求。数据库插入在xml文件中，mapper中有数据库的操作函数</p>\n<h3 id=\"帖子详情\"><a href=\"#帖子详情\" class=\"headerlink\" title=\"帖子详情\"></a>帖子详情</h3><p>首页上出现帖子，点击后请求&#x2F;discuss&#x2F;detail&#x2F;${map.post.id}|}”，具体在128行，controller在DiscussPostController，DiscussPostService有查找post_id的方法，然后显示在discuss-detail.html上</p>\n<h3 id=\"显示评论\"><a href=\"#显示评论\" class=\"headerlink\" title=\"显示评论\"></a>显示评论</h3><p>先解释下comment这个数据表，entity_type表示实体类型，比如1代表帖子，2代表用户，3代表题，4代表用户课程。entity_id表示id为多少的这个帖子。target_id比如你可以对某个帖子评论，或者在评论中回复别人，有指向性。status表示这个评论是正常还是被删除了。</p>\n<p>这个业务比较繁琐，首先我们上面说了实体类型有不同，而且还要考虑回复的回复。具体代码看DisCussPostController的帖子详情内部方法。这里面可以仔细看看代码部分，因为涉及的逻辑比较多。还要就是看discuss-detail.html是怎么读取内容的</p>\n<h3 id=\"添加评论\"><a href=\"#添加评论\" class=\"headerlink\" title=\"添加评论\"></a>添加评论</h3><p>评论的话有三类，第一类是直接对帖子进行评论，第二类是评论中的普通评论，第三类是评论中的回复。</p>\n<p>还需要注意的是，在评论完之后 要更新帖子评论的数量，这是一个事务，必须两个一起完成，具体看Commentservice.还需要看commentcontroller。涉及操作的网页是discus-detail。包含了三种回复帖子的不一样格式，比如实体类型不一样，如果是回复别人，还需要拿到target的id。</p>\n<h3 id=\"私信列表\"><a href=\"#私信列表\" class=\"headerlink\" title=\"私信列表\"></a>私信列表</h3><p>数据表如图，fromid发送人,fromid为1是系统通知，toid收件人，status 0-未读;1-已读;2-删除。coversation_id比如111发给112就拼为111_112，注意112发给111也是111_112，永远都是小号在前，当然了，其实这个数据是冗余的，但是为了后面我们查询方便才加入这个字段</p>\n<p>这个章节需要理解数据库的查表sql语句，有些不好理解，在message-mapper.xml中。</p>\n<p>涉及的网页有letter.html和letter-detail.html（这个网页有个js，在下面的back()）。还有仔细看MessageControl的代码，需要注意一个业务细节，就是我们查私信都是通过会话来查，会话id是两个人的id组合，然后显示来自xxx的私信，必须是对方的名字，controller中特地写了getLetterTarget这个方法，可以看看。</p>\n<h3 id=\"发送私信\"><a href=\"#发送私信\" class=\"headerlink\" title=\"发送私信\"></a>发送私信</h3><p>业务逻辑就是点击消息，然后根据名字来发，用户点击消息代表已读然后设置状态为1，具体实现在MessageController，这里发送内容用到了异步请求，具体看letter.js。有一个sql语句第一次见，具体看message-mapper.xml，更新信息状态那个，因为是多个消息，用到foreach</p>\n<h3 id=\"统一处理异常\"><a href=\"#统一处理异常\" class=\"headerlink\" title=\"统一处理异常\"></a>统一处理异常</h3><p>具体看control包下的advice包的ExceptionAdvice。需要注意有异步请求的错误，有普通页面的错误。<strong>网页一个问题</strong>：这节课一开始说把错误页面的模板放到error文件夹下，服务器出错了就会自动连接到那个页面打开，那为什么后来还要专门定义一个类然后出错了在方法里重定向到错误页面呢？<strong>回答</strong>服务器只是在错误发生时跳转到错误页面，但是我们还需要记录日志，并且在异步请求中不是返回页面，而是返回json，这些是服务器不会帮你做的事情。总的来说，这个功能不也是不需要每个功能里具体写异常。</p>\n<h3 id=\"统一日志管理\"><a href=\"#统一日志管理\" class=\"headerlink\" title=\"统一日志管理\"></a>统一日志管理</h3><p>这里有个抽象的概念叫AOP，具体可以百度，实现方法在aspect中，可以做到对所有Service类进行记录，当然也可以其他类，这样就不需要在某个controller上具体写某个日志。拦截器是AOP思想的一种实现，Spring AOP也是一种实现。</p>\n<h3 id=\"删除私信\"><a href=\"#删除私信\" class=\"headerlink\" title=\"删除私信\"></a>删除私信</h3><p>开发删除私信功能，即点击某条私信的删除按钮时，将其状态设置为删除态。在没做之前考虑的难点，界面上是有一个x的，那么怎么触发这个x的操作？没错 ，这个功能也是要用到异步请求的。这里很重要的一点是，需要在letter-detail.html中设计一个隐藏的数值来保存这个会话的id（127行），然后用js异步请求。js获取到id后交给controller处理，controller交给service把状态改成2，并返回0。需要注意，只要有一个人删除了，对方都看不见这个消息，这是设计表没有考虑的问题。</p>\n<h2 id=\"Redis，一站式高性能存储方案\"><a href=\"#Redis，一站式高性能存储方案\" class=\"headerlink\" title=\"Redis，一站式高性能存储方案\"></a>Redis，一站式高性能存储方案</h2><h3 id=\"redis配置\"><a href=\"#redis配置\" class=\"headerlink\" title=\"redis配置\"></a>redis配置</h3><p>redis需要配置依赖，并且在application.properties中配置相关redis，重新设置序列化方式。然后还要一个点注意，需要重写bean，具体看config中的redisconfig。可以看看test中的各种测试来巩固。redis就不写dao了，直接在service上操作存储。</p>\n<h3 id=\"点赞\"><a href=\"#点赞\" class=\"headerlink\" title=\"点赞\"></a>点赞</h3><p>先写生成key的工具，看util代码</p>\n<p>三个地方点赞，一个是帖子，另外是两种评论(一个回复，一个普通)点赞 。需要在HomeControl中处理首页的赞，同时在DiscussPostController处理3个地方的点赞，这里解释下js语句的这个： href&#x3D;”javascript:;” th:onclick&#x3D;”|like(this,1,${post.id});|” 这里写用空的javascript，如果识别到空，就触发点击事件的like函数，因为里面有静态值，所以加||，第一个this的作用是获取这个赞是点哪里的，因为我们说了一共有3个地方有，然后1代表是帖子的赞，然后2代表评论和回复的赞，获取完后用异步来刷新界面。这里具体代码看likeservice和likecontroller，因为不需要用数据库，不写mapper。最后提一个没有实现的功能，就是未登录状态下你是不能点赞的(虽然报错服务器异常)，后期老师说用spring security来实现</p>\n<h3 id=\"我收到的赞\"><a href=\"#我收到的赞\" class=\"headerlink\" title=\"我收到的赞\"></a>我收到的赞</h3><p>先写生成key的工具，看util代码</p>\n<p>这个需求需要把上一个点赞功能重写一下，本功能重写在likeservice中，总体的思路就是用userid来标记获得的赞，然后最后查询redis中的赞数量即可。这里理清楚两个key，一个是followee(单词意思为被追随者，也就是偶像，可以理解为里面的值是我的偶像，用来记录我关注了谁)，一个是follower(单词意思为追随者，也就是粉丝，用来记录我被谁关注，可以理解为里面存的值是我的粉丝)，</p>\n<p>比如xixi(151)关注了aaa(111)。那么 followee:151:3的值是111 ，follower:3:111的值是151，如果xixi再关注niuke(149)，此时 followee:151:3的值是111，149。3代表是关注用户，因为1代表关注帖子，2代表关注评论。</p>\n<p>具体涉及的代码有UserController，FollowService，profile.html中有一个修改样式的代码，在关注TA那里，当判断已经关注就改变一个样式，这里还用到了JS的异步请求，可以仔细看看。</p>\n<h3 id=\"关注列表\"><a href=\"#关注列表\" class=\"headerlink\" title=\"关注列表\"></a>关注列表</h3><p>先写生成key的工具，看util代码</p>\n<p>需要写的方法有查询关注实体的数量，查询实体的粉丝的数量，查询当前用户是否已经关注该实体，查询某个用户关注的人，查询某个用户的粉丝。均在followservice中写，还有followcontroller中。涉及的网页有followee.html，follower.html。</p>\n<h3 id=\"优化登录模块\"><a href=\"#优化登录模块\" class=\"headerlink\" title=\"优化登录模块\"></a>优化登录模块</h3><p><strong>验证码部分</strong></p>\n<p>先写生成key的工具，看util代码</p>\n<p>对验证码存入redis中，并设置过期时间，首先需要浏览器给一个临时凭证，然后存入cookie中，然后redis凭证的保存的值就是验证码，有效期为60秒，比如 kaptcha:ba60a25644194e438007dac1129d45f2存的验证码值是N2IZ，这段代码在LoginController的getKaptcha操作，取消原来的session。然后在login中用cookie来提取信息，判断是否有效，去掉原来的session，并添加cookie取值。这里一开始不能理解为什么要一个随机凭证，因为我们通过随机凭证可以取到验证码的值，而随机凭证是用cookie来保存</p>\n<p><strong>ticket部分</strong></p>\n<p>先写生成key的工具，看util代码</p>\n<p>在userservice中处理，同时废弃之前写的loginticketmapper。首先在userservice的login方法中存入loginTicket，注意这是一个对象。在我们进入每个业务的时候都会寻找这个ticket，所以在findloginticket中就是返回redis的ticket，那么退出的时候，我们是把状态设置为1，然后再重新存入这个ticket，，在处理过程中注意要转化。</p>\n<p>在登录的时候，redis是这样的：</p>\n<p>ticket:b7d3e1f966fc44ee975586c992fccc91，他的值是”{&quot;@class&quot;:&quot;com.nowcoder.community.entity.LoginTicket&quot;,&quot;id&quot;:0,&quot;userId&quot;:151,&quot;ticket&quot;:&quot;b7d3e1f966fc44ee975586c992fccc91&quot;,&quot;status&quot;:0,&quot;expired&quot;:[&quot;java.util.Date&quot;,1653314918710]}”然后如果你退出登录，那么status就为1</p>\n<p>需要注意，这个信息是永久保存的，而不是像验证码有那样，因为我们可以用来做一些统计信息</p>\n<p><strong>缓存用户信息</strong></p>\n<p>先写生成key的工具，看util代码</p>\n<p>因为每次调用ticket的时候都要去调用用户id，所以这个功能也是比较频繁的。</p>\n<p>在UserService中需要写三个方法，1.优先从缓存中取值2.取不到值就初始化缓存3.当数据变更，清除缓存数据。</p>\n<p>那么在哪里会用到呢？首先是<strong>findUserById</strong>，如果redis中有，那么就用，没有的话就初始化，初始化的时候会调用一次mysql，然后再也不需要频繁调用了，直接用redis。其次还用到更新，比如<strong>激活码如果激活成功</strong>，那么状态就会改变，这时候就删除原来的缓存，然后如果系统识别不到缓存，就又重新生成一个redis，还有一个更新操作，就是<strong>更换头像</strong>，会更新headerurl，如果更新了，那么也会清除原来的缓存然后重新生成。</p>\n<p>这里举个例子，当我们访问首页的时候，会有帖子，这些帖子的信息有发帖子的资料，我们就可以从redis中获取，然后会生成以下资料</p>\n<p>然后每个key的具体值就是mysql中的信息</p>\n<p>{&quot;@class&quot;:&quot;com.nowcoder.community.entity.User&quot;,&quot;id&quot;:145,&quot;username&quot;:&quot;lhh&quot;,&quot;password&quot;:&quot;d980a16ea0b3c8a81062ee806e65a4bc&quot;,&quot;salt&quot;:&quot;5abfc&quot;,&quot;email&quot;:&quot;<a href=\"mailto:&#x6e;&#111;&#x77;&#99;&#111;&#100;&#101;&#114;&#x31;&#x34;&#53;&#x40;&#115;&#105;&#x6e;&#97;&#46;&#x63;&#x6f;&#x6d;\">&#x6e;&#111;&#x77;&#99;&#111;&#100;&#101;&#114;&#x31;&#x34;&#53;&#x40;&#115;&#105;&#x6e;&#97;&#46;&#x63;&#x6f;&#x6d;</a>&quot;,&quot;type&quot;:0,&quot;status&quot;:1,&quot;activationCode&quot;:&quot;f217b637e9544e2a9b4a88f78c583d03&quot;,&quot;headerUrl&quot;:&quot;<a href=\"http://images.nowcoder.com/head/145t.png/%22,/%22createTime/%22:[/%22java.util.Date/%22,1556436636000]%7D\">http://images.nowcoder.com/head/145t.png\\&quot;,\\&quot;createTime\\&quot;:[\\&quot;java.util.Date\\&quot;,1556436636000]}</a>“</p>\n<h3 id=\"我的回复\"><a href=\"#我的回复\" class=\"headerlink\" title=\"我的回复\"></a>我的回复</h3><p>我的帖子和我的回复是差不多的，对于这两个操作是在usercontroller中完成视图操作。首先需要传回去userid，在路径中进行拼写，之前我们在redis中重写userService.findUserById，通过userid来获取账号的信息，再用findUserComments获取全部的回复信息，这里的sql语句是新写的，可以看看，另外还有一个评论数量的sql语句也是新写的。同时需要注意，因为我们是在帖子中回复，所以还要找到相应的帖子，可以链接过去，所以在保存信息的时候，需要存post的内容</p>\n<h3 id=\"我的帖子\"><a href=\"#我的帖子\" class=\"headerlink\" title=\"我的帖子\"></a>我的帖子</h3><p>我的帖子查询之前已经写了sql语句了。那么除了获取帖子，还需获取一个点赞的数量，同样在UserController中写。</p>\n<h2 id=\"Kafka，构建TB级异步消息系统\"><a href=\"#Kafka，构建TB级异步消息系统\" class=\"headerlink\" title=\"Kafka，构建TB级异步消息系统\"></a>Kafka，构建TB级异步消息系统</h2><h3 id=\"发送系统通知\"><a href=\"#发送系统通知\" class=\"headerlink\" title=\"发送系统通知\"></a>发送系统通知</h3><p>首先设计好event的实体属性，这里可以好好看一个点，因为部分属性进行了，接下来设计好生产者和消费者（在event包下），本项目对帖子，评论，回复，点赞和关注会发送系统消息，需要在CommentController，FollowController以及LikeController进行添加通知的方法，为此有些数据库操作多了一些，可以看xml的数据库操作语句，对于controller中，我们要学习一个写法，就是set那一部分，new完event后马上set，第一次看到这种写法。</p>\n<h3 id=\"显示系统通知\"><a href=\"#显示系统通知\" class=\"headerlink\" title=\"显示系统通知\"></a>显示系统通知</h3><p>首先要清楚，只会显示最新的那个通知，可以看sql具体怎么操作提取最新。通知一共有三类，一个是评论通知，一个是点赞通知，一个是关注通知，其中评论和点赞的详情页都会链接到帖子处，关注的详情可以链接到这个人的主页。除此之外，还需要统计未读数量，以及已读设置，这个已读设置是点击详情页，然后你当前页都会设置已读。涉及的网页有notice.html，notice-detail.html。在messagecontroller，messageservice，message-mapper.xml。</p>\n<p>朋友私信和系统通知都可以提取未读数量，然后相加就是消息的未读数量。这里要用拦截器，拦截器为MessageInterceptor，写完拦截器后需要在config的webmvcconfig中配置，最后再index.html中读取消息的总数量。</p>\n<h2 id=\"Elasticsearch，分布式搜索引擎\"><a href=\"#Elasticsearch，分布式搜索引擎\" class=\"headerlink\" title=\"Elasticsearch，分布式搜索引擎\"></a>Elasticsearch，分布式搜索引擎</h2><h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>除了[安装elasticsearch](<a href=\"https://www.elastic.co/cn\">免费且开放的搜索：Elasticsearch、ELK 和 Kibana 的开发者 | Elastic</a>)，还需要安装<a href=\"https://github.com/medcl/elasticsearch-analysis-ik\">中文的分词</a>,需要注意ES的版本要匹配spring boot，同时中文的分词ik也要对应ES。需要把ik解压到ES的plugins的ik目录下（自己创建）。另外还需要安装postman（非必要软件）来模拟客户端。需要注意的是，老师用6.x的版本，而我现在用7.x的版本，是有很大差别的，具体可以看(<a href=\"https://blog.csdn.net/wpw2000/article/details/115704320?spm=1001.2014.3001.5502\">SpringBoot整合ElasticSearch7.12实现增删改查及高亮分词查询_夜中听雪的博客-CSDN博客</a>)。还有这个(<a href=\"https://www.cnblogs.com/Deng-23-binb/p/15489043.html\">ElasticSearch(2)-RestHighLevelClient - 快乐的海盗 - 博客园</a>)。</p>\n<p>还有一个地方需要注意，redis是基于netty，elsaticsecrch也是基于netty，然后如果一起运行的话会冲突，在main方法上做了一个配置。</p>\n<p>本章节的安装涉及页面有Esconfig，DiscussPostRepository，当然也要在application.properties配置。</p>\n<h3 id=\"开发社区搜索功能\"><a href=\"#开发社区搜索功能\" class=\"headerlink\" title=\"开发社区搜索功能\"></a>开发社区搜索功能</h3><p>最开始的时候老师完善了一个bug，在discusspost-mapper.xml中的insertDiscussPost方法中了加了keyProperty&#x3D;”id”，如果不声明这个，mybatis就不知道增加的时候哪个是主键，就不会把生成的主键增加到实体类去，所以后面要想用到这个实体类，就需要加上。</p>\n<p>为什么评论也要异步更新到搜索？因为最终呈现搜索结果的界面每一条帖子的最后面都有对应的点赞和回复信息，所以得刷新es。</p>\n<p>首先在comment和discusspost的controller设置触发事件，也就是当我们发布帖子，或者评论的时候，都需要触发事件，这个就要用到消息队列，然后消费者可以根据id来覆盖帖子或者新建帖子，这样搜索引擎就收录了这些信息。</p>\n<p>具体代码看Elasticsearchservice，EventConsumer,searchcontroller,在service代码中搜索部分是配合下面的分页来操作的，这个和老师不一样，因为版本的问题，这个分页用到pagehelper包</p>\n<h2 id=\"项目进阶，构建安全高效的企业服务\"><a href=\"#项目进阶，构建安全高效的企业服务\" class=\"headerlink\" title=\"项目进阶，构建安全高效的企业服务\"></a>项目进阶，构建安全高效的企业服务</h2><h3 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h3><p>退出登录要用post请求，可以变成表单</p>\n<h3 id=\"权限控制\"><a href=\"#权限控制\" class=\"headerlink\" title=\"权限控制\"></a>权限控制</h3><p>之前做的登录拦截废弃掉，在webmvc中废弃，现在用spring security来控制。需要注意的是spring security自带csrf拦截，，提交表单的时候会有一个随机token，但是你得去配置才能有最好的效果,有点麻烦，比如index有个例子，本项目我们disable了csrf这个功能。我们只做了授权配置，也就是用户类别的判断，没有做认证，还是用原来的认证方案，如果想了解可以看7.1的视频。</p>\n<p>首先在<strong>CommunityConstant</strong>中声明三种权限，然后在<strong>SecurityConfig</strong>中来说明哪些权限能登录哪些页面，这些是需要自己统计的页面，然后写没有登录或者没有权限的时候是如何返回信息，这个可以好好看哦，还有这里多设计了一个拒绝访问的页面，在<strong>HomeControl</strong>中加入，也就是你权限不足相当于没有这个网页。那么在<strong>UserService</strong>中则写一个根据用户来获取用户权限的方法，写完这些还需要在<strong>LoginTicketInterceptor</strong>中获取用户凭证后面来构建用户认证的结果。对于退出登录，需要在<strong>LoginController</strong>中的logout方法清理内容。</p>\n<p>评论中老师的一个说法：</p>\n<p>1. Security提供了认证和授权两个功能，我们在DEMO里也做了演示，而在项目中应用时，我们并没有使用它的 认证功能，而单独的使用了它的授权功能，所以需要对认证的环节做一下特殊的处理，以保证授权的正常进行；2. Security的所有功能，都是基于Filter实现的，而Filter的执行早于Interceptor和Controller，关于Security的拦截器原理，可以参考<a href=\"http://www.spring4all.com/article/458%EF%BC%9B3\">http://www.spring4all.com/article/458；3</a>. 我们的解决方案是，在Interceptor中判断登录与否，然后人为的将认证结果添加到了SecurityContextHolder里。这里要注意，由于Interceptor执行晚于Filter，所以认证的进行依赖于前一次请求的拦截器处理。比如，我登录成功了，然后请求自行重定向到了首页。在访问首页时，认证Filter其实没起作用，因为这个请求不需要权限，然后执行了Interceptor，此时才将认证结果加入SecurityContextHolder，这时你再访问&#x2F;letter&#x2F;list，可以成功，因为在这次请求里，Filter根据刚才的认证结果，判断出来你有了权限；4. 退出时，需要将SecurityContextHolder里面的认证结果清理掉，这样下次请求时，Filter才能正确识别用户的权限；5. LoginTicketInterceptor中的afterCompletion中其实不用清理SecurityContextHolder，将这句话删掉。</p>\n<h3 id=\"置顶，加精，删除\"><a href=\"#置顶，加精，删除\" class=\"headerlink\" title=\"置顶，加精，删除\"></a>置顶，加精，删除</h3><p>增加两个sql语句，具体看discusspost.xml。其次要在<strong>SecurityConfig</strong>中声明权限，管理员可以删除帖子，版主可以置顶和加精，注意在删除贴子的时候，我们还需要把<strong>ES搜索引擎的帖子数据也要删除</strong>，所以在<strong>Event消费者</strong>中添加消费删除的主题。在<strong>DiscussPostController</strong>中写好三个方法。涉及的前端页面是discuss-detail.html。我自己还修改了下js文件，加上取消置顶和取消加精。还有前端需要配合thymeleaf的spring security来检验权限，让没有权限的人看不到相关按钮。</p>\n<h3 id=\"统计用户数据\"><a href=\"#统计用户数据\" class=\"headerlink\" title=\"统计用户数据\"></a>统计用户数据</h3><p>一个是访问量(UV)，一个是活跃用户(DAU)，这两个用的数据类型是不一样的，首先访问量用的是HyperLogLog,可以大致统计，DAU用Bitmap，可以精确统计。先在<strong>RedisKeyUtil</strong>中写好DAU和UV的数据格式，接着在<strong>DataSercice</strong>中写好方法，之前我们说过，redis不需要用mapper，直接在service中写好存数据的方法，然后要做一个拦截器，具体看<strong>DateInterceptor</strong>，到<strong>WebMVC</strong>中配置，再写一个<strong>DataController</strong>设置好访问的路径，只有管理员可以访问&#x2F;data，这个在security中配置。涉及的网页在site&#x2F;admin&#x2F;data。</p>\n<p>需要理解下DAU用OR运算的原因。</p>\n<p>关于Bitmap和HyperLogLog有测试类，可以去看看。</p>\n<h3 id=\"任务执行和调度\"><a href=\"#任务执行和调度\" class=\"headerlink\" title=\"任务执行和调度\"></a>任务执行和调度</h3><p>需要配置quartz和线程池的东西哦，在application.properites</p>\n<p>比如我们想半个小时统计一次帖子热度，清理临时文件，就需要用到这个任务。JDK和Spring的线程池只能各自为战，在分布式中不好用，而Quartz可以用在分布式中比较好用。</p>\n<p>本节课讲了好多配置，测试类可以看ThreadPoolTests（我们还在AlphaSercice中写了相关方法），QuartzTests，</p>\n<p>配置类看ThreadPoolConfig(里面单纯配置了下，好像是测试的时候可以用到@Async)，还有QuartzConfig</p>\n<p>quartz包还有一个AlphaJob</p>\n<h3 id=\"热帖排行\"><a href=\"#热帖排行\" class=\"headerlink\" title=\"热帖排行\"></a>热帖排行</h3><p>思路就是每隔多少时间计算一次，注意不是每个帖子都计算，而是如果触发了某些行为，比如点赞，加精，评论，还有新发布的帖子，这些帖子才计算，先把这些帖子放到redis中，然后到了时间就计算。</p>\n<p>首先要设计rediskey，在RedisKeyUtil中，接来下就是写任务job了，在PostScoreRefreshJob中，写完Job后要配置Quartz，具体看QuartzConfig。最后还需要修改下数据库discusspostmapper的selectDiscussPosts方法，具体看xml的sql语法，相应的service中也要改方法哦，最后则是改变下HomeController的传参，这是新的一个例子，我们默认如果orderMode是1就热度排行，否则0就是默认排序，所以在index上和原来要改变下，注意看page.setPath的路径，多了一个order，然后model中也要加入这个属性。那么在index.html中传参也注意下，这是第一次看到的。</p>\n<h3 id=\"生成图片\"><a href=\"#生成图片\" class=\"headerlink\" title=\"生成图片\"></a>生成图片</h3><p>分享的时候要用到，需要用到消息队列哦，用的技术是属于wkhtmltoimage</p>\n<p>首先配置相关信息，生成图片命令和保存图片路径。然后在WKconfig中写一个生成文件夹的工具，因为程序会首先运行config类，接着写share的消费者，因为我们是用队列来运行的，最后写sharecontroller，除了生成长图，我们还要展示长图，输入正确的url后会返回一个链接，这个链接打开就可以在浏览器中展示图片。</p>\n<h3 id=\"上传文件到七牛云\"><a href=\"#上传文件到七牛云\" class=\"headerlink\" title=\"上传文件到七牛云\"></a>上传文件到七牛云</h3><p>配置好相关七牛云的信息哦</p>\n<p>上传人物图像是属于客户端上传，分享图片是服务器直传。</p>\n<p>首先是人物图像，要重写之前在本地保存的路径，具体看UserController,写完之后，需要在setting中修改上传图片相关代码，大概在setting.html的90行，另外还有js文件也要看哦。</p>\n<p>分享的图片保存到七牛云，同样也是通过消息队列，所以要对eventconsumer进行一个重写。另外在sharecontroller中的map部分修改了下，主要大改的代码还是消费者那里，上传图片的时候需要考虑图片生成完没有呀，因为我们知道图片生成是稍微慢一点的，还要防止图片一直上传占用服务器的资源，所以我们要用上传时间和次数来限制这个失败的情况。</p>\n<h3 id=\"优化网站性能\"><a href=\"#优化网站性能\" class=\"headerlink\" title=\"优化网站性能\"></a>优化网站性能</h3><p>和用户相关联的最好不要用本地缓存，比如登录凭证，因为我们是分布式部署，可能下次就不是请求这个服务器了。对于redis，服务器1第一次请求DB然后存到redis，服务2请求的话可以直接访问redis，就不需要用DB(database数据库)。本地缓存是比redis快的，而redis适用性广。</p>\n<p>数据变化的频率相对较低适用缓存，默认的首页不适用哦，因为经常有人发帖子，而热门帖子适用。</p>\n<p>不建议用spring来整合那几个常用缓存工具，因为他是统一管理，而每个工具都有自己独特的性能，如果单独设置又比较麻烦。</p>\n<p>我们用的是Caffeine</p>\n<p>先在配置上定义一些常量，然后主要是优化热门帖子和帖子行数，具体看DiscusspostService。</p>\n<p>可以用jmeter来测试，具体看吞吐量来对比。</p>\n<h3 id=\"删除分享图片的本地资源\"><a href=\"#删除分享图片的本地资源\" class=\"headerlink\" title=\"删除分享图片的本地资源\"></a>删除分享图片的本地资源</h3><p>因为我们把图片是先保存到本地，然后再传给七牛云。所以在本地上的图片传完后可以删除，先写一个WKimageDeletejob，然后再quartz中写任务和触发器</p>\n<h2 id=\"项目发布与总结\"><a href=\"#项目发布与总结\" class=\"headerlink\" title=\"项目发布与总结\"></a>项目发布与总结</h2><h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><p>很有意思的是，以前我不写@RunWith(SpringRunner.class)也能运行，但是这次不行。代码在SpringBootTests，感觉跟之前的差不多呀。但是写了一些判断条件，然后自己可以运行下看看，跟以前的测试感觉差不多呀，不过多了一些判断。</p>\n<h3 id=\"项目监控\"><a href=\"#项目监控\" class=\"headerlink\" title=\"项目监控\"></a>项目监控</h3><p>依赖spring的actuator，我们可以在配置类中配置相关类，官方手册是20+把。然后也可以自己自定义来写，比如看actuator包中的DatabaseEndpoint这个例子,当然了，这个需要管理员才可以看，我们还要在SecurityConfig中配置。</p>\n<h3 id=\"部署\"><a href=\"#部署\" class=\"headerlink\" title=\"部署\"></a>部署</h3><p>centos，能用yum就这个命令下载，但是可能版本比较旧，可以从官方网站上下载链接更新。</p>\n<h1 id=\"数据库表及一些业务逻辑整理\"><a href=\"#数据库表及一些业务逻辑整理\" class=\"headerlink\" title=\"数据库表及一些业务逻辑整理\"></a>数据库表及一些业务逻辑整理</h1><h2 id=\"数据库表\"><a href=\"#数据库表\" class=\"headerlink\" title=\"数据库表\"></a>数据库表</h2><p>comment</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `comment` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `user_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#用于表示发这条评论的用户id</span><br><span class=\"line\">  `entity_type` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#表示评论的类型 <span class=\"number\">1</span>表示回复帖子的评论 <span class=\"number\">2</span>表示回复评论的评论</span><br><span class=\"line\">  `entity_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL, #如果entity_type是<span class=\"number\">1</span>，这里的entity_id就表示帖子的id，如果entity_type是<span class=\"number\">2</span>，这里的entity_id就表示评论的id</span><br><span class=\"line\">  `target_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#表示回复时回复对象的id，如果id=<span class=\"number\">0</span>说明这是一条回复帖子的评论，如果id!=<span class=\"number\">0</span>说明这是回复target_id用户的评论</span><br><span class=\"line\">  `content` text,#评论内容</span><br><span class=\"line\">  `status` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#<span class=\"number\">0</span>表示有用的评论 <span class=\"number\">1</span>表示已删除的评论</span><br><span class=\"line\">  `create_time` timestamp NULL DEFAULT NULL,#创建时间</span><br><span class=\"line\">  PRIMARY <span class=\"title function_\">KEY</span> <span class=\"params\">(`id`)</span>,</span><br><span class=\"line\">  KEY `index_user_id` (`user_id`) <span class=\"comment\">/*!80000 INVISIBLE */</span>,</span><br><span class=\"line\">  KEY `index_entity_id` (`entity_id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>\n\n<p>discuss_post</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `discuss_post` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `user_id` varchar(<span class=\"number\">45</span>) DEFAULT NULL,#发帖人的id</span><br><span class=\"line\">  `title` varchar(<span class=\"number\">100</span>) DEFAULT NULL,#标题</span><br><span class=\"line\">  `content` text,#内容</span><br><span class=\"line\">  `type` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL COMMENT <span class=\"string\">&#x27;0-普通; 1-置顶;&#x27;</span>,</span><br><span class=\"line\">  `status` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL COMMENT <span class=\"string\">&#x27;0-正常; 1-精华; 2-拉黑;&#x27;</span>,</span><br><span class=\"line\">  `create_time` timestamp NULL DEFAULT NULL,#发帖日期</span><br><span class=\"line\">  `comment_count` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#表示帖子的评论数，是一个冗余参数</span><br><span class=\"line\">  `score` <span class=\"type\">double</span> DEFAULT NULL,#分数，计算热度用的</span><br><span class=\"line\">  PRIMARY <span class=\"title function_\">KEY</span> <span class=\"params\">(`id`)</span>,</span><br><span class=\"line\">  KEY `index_user_id` (`user_id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>\n\n<p>login_ticket，这张表到了后期是用不到了，因为ticket存在redis中，但是可以参考下redis中也是这样设置参数的</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `login_ticket` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `user_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL,#用户id</span><br><span class=\"line\">  `ticket` varchar(<span class=\"number\">45</span>) NOT NULL,#凭证号</span><br><span class=\"line\">  `status` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;0-有效; 1-无效;&#x27;</span>,</span><br><span class=\"line\">  `expired` timestamp NOT NULL,#到期时间</span><br><span class=\"line\">  PRIMARY <span class=\"title function_\">KEY</span> <span class=\"params\">(`id`)</span>,</span><br><span class=\"line\">  KEY `index_ticket` (`ticket`(<span class=\"number\">20</span>))</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>\n\n<p>message</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `message` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `from_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#发消息的人的id</span><br><span class=\"line\">  `to_id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL,#收消息人的id</span><br><span class=\"line\">  `conversation_id` varchar(<span class=\"number\">45</span>) NOT NULL,#发消息和收消息人的id组合在一起，比如<span class=\"number\">111_112</span>，前小后大，是一个冗余参数，为了方便查询</span><br><span class=\"line\">  `content` text,#内容</span><br><span class=\"line\">  `status` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL COMMENT <span class=\"string\">&#x27;0-未读;1-已读;2-删除;&#x27;</span>,</span><br><span class=\"line\">  `create_time` timestamp NULL DEFAULT NULL,#创建时间</span><br><span class=\"line\">  PRIMARY <span class=\"title function_\">KEY</span> <span class=\"params\">(`id`)</span>,</span><br><span class=\"line\">  KEY `index_from_id` (`from_id`),</span><br><span class=\"line\">  KEY `index_to_id` (`to_id`),</span><br><span class=\"line\">  KEY `index_conversation_id` (`conversation_id`)</span><br><span class=\"line\">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>\n\n<p>user</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">CREATE TABLE `user` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) NOT NULL AUTO_INCREMENT,</span><br><span class=\"line\">  `username` varchar(<span class=\"number\">50</span>) DEFAULT NULL,#用户账号</span><br><span class=\"line\">  `password` varchar(<span class=\"number\">50</span>) DEFAULT NULL,#密码，这里是md5（密码+盐值）</span><br><span class=\"line\">  `salt` varchar(<span class=\"number\">50</span>) DEFAULT NULL,#盐值</span><br><span class=\"line\">  `email` varchar(<span class=\"number\">100</span>) DEFAULT NULL,#邮箱</span><br><span class=\"line\">  `type` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL COMMENT <span class=\"string\">&#x27;0-普通用户; 1-超级管理员; 2-版主;&#x27;</span>,</span><br><span class=\"line\">  `status` <span class=\"type\">int</span>(<span class=\"number\">11</span>) DEFAULT NULL COMMENT <span class=\"string\">&#x27;0-未激活; 1-已激活;&#x27;</span>,</span><br><span class=\"line\">  `activation_code` varchar(<span class=\"number\">100</span>) DEFAULT NULL,#激活码</span><br><span class=\"line\">  `header_url` varchar(<span class=\"number\">200</span>) DEFAULT NULL,#用户图像路径</span><br><span class=\"line\">  `create_time` timestamp NULL DEFAULT NULL,#创建时间</span><br><span class=\"line\">  PRIMARY <span class=\"title function_\">KEY</span> <span class=\"params\">(`id`)</span>,</span><br><span class=\"line\">  KEY `index_username` (`username`(<span class=\"number\">20</span>)),</span><br><span class=\"line\">  KEY `index_email` (`email`(<span class=\"number\">20</span>))</span><br><span class=\"line\">) ENGINE=InnoDB AUTO_INCREMENT=<span class=\"number\">101</span> DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"部分业务逻辑梳理\"><a href=\"#部分业务逻辑梳理\" class=\"headerlink\" title=\"部分业务逻辑梳理\"></a>部分业务逻辑梳理</h2><h3 id=\"注册和登录\"><a href=\"#注册和登录\" class=\"headerlink\" title=\"注册和登录\"></a>注册和登录</h3><p>1.先说注册，需要的数据有：账号，密码，确认密码，邮箱<br>密码和确认密码由前端进行判断<br>后端要养成一个习惯，空值处理，然后判断账号和邮箱是否存在，如果都不存在就注册成功并发送邮件让用户激活<br>这里有个用户体验的地方，就是如果用户即便注册不成功，也要显示他之前写的数据在网页上，而不是刷新变成空</p>\n<p>2.然后是激活，会发一个邮件给用户的邮箱，里面是含有有激活码的链接，点击即可激活，这样账号才能使用，注意要有用户重复激活和自己故意输入错误激活码的行为</p>\n<p>3.最后是登录<br>登录的时候需要验证码，这个验证码用redis来存储，可以用若干时间后失效，如果验证码失效，需要重新更新redis<br>先判断三种情况1.验证码本身是否有问题，因为可能刷新不出来，这是我们的锅2.用户没有写验证码3.用户验证码是错误的<br>通过了上面判断，我们再检查账号密码，正确无误后，我们生成一个用户凭证，也就是ticket，每次登录都会生成，这是为了判断是哪个用户，同时这样也不会泄露用户的信息<br>同时为了避免每次都要看数据库来确认用户，我们把凭证存到redis中，对于用户的话，这个ticke是放在cookie中的</p>\n<p>4.登出<br>把redis的loginticket状态设置为1，也就是无效。</p>\n<p>这里提一下拦截器，拦截器是用来判断用户是否登录的，用户登录成功cookied就包含这个ticket，然后拦截器的pre先来判断是否有效，然后用hostHolder设置持有用户<br>然后查询他的用户权限，比如是否版主，交给spring security认证和授权。接着在执行模板前获取信息，返回loginUser到网页中，登出的话拦截器也会进行清理。</p>\n<h3 id=\"帖子，评论\"><a href=\"#帖子，评论\" class=\"headerlink\" title=\"帖子，评论\"></a>帖子，评论</h3><p>在没有登录之前，也会有帖子的信息，有默认帖子和热门帖子，热门帖子是根据分来来进行排序的，默认帖子则是根据置顶，加精以及时间来排序的。<br>那么一个帖子会展示发帖人，帖子标题，点赞数量（redis中）以及回复的数量(数据表本身存有这个，不是放在redis中的)，统一放在List&lt;Map&lt;String, Object&gt;&gt;中。</p>\n<p>发布帖子，登录后才会显示我要发布帖子的按钮，这个显示就是拦截器的loginUser来判断的，发布帖子之前也要判断是否存在用户，虽然我们有拦截器<br>系统获取id，标题，内容，创建时间后，然后通过发帖服务来加到数据库中，同时触发发帖事件，这个的意义是为了把帖子的信息慢慢加入到搜索引擎ES中，所以才用kafka的消息队列，还有就是计算分数放在redis中</p>\n<p>查看帖子，每个帖子的链接都有一个id来识别，需要查询的信息比较多，帖子的基本信息（标题，发帖人，点赞数），同时如果有用户登录，还需要判断是否点赞，接下来就是获取评论的信息了，包括评论，回复之类的，回复数量。<br>同时如果你是版主的话，是可以置顶和加精的，这两个操作也是用到消息队列，和发帖的topic是一样的，因为是为了更新ES的数据，ES是把整个帖子的数据库信息都录进去，所以要更新</p>\n<p>评论，首先就是判断你的登录状态了，然后获取你的信息，评论更新到数据库后，同样触发消息队列的评论&#x2F;回复，会通知相应的用户，显示到消息中，评论帖子操作是会触发更新分数的，同时也要放到消息队里中更新ES（因为帖子分数变了）</p>\n<p>管理员是可以删帖子的，这个也会触发消息队列，因为要发ES中的内容删除</p>\n<p>另外别忘了上面所以涉及文字内容，都需要过滤敏感词哦</p>\n<h3 id=\"私信，消息功能\"><a href=\"#私信，消息功能\" class=\"headerlink\" title=\"私信，消息功能\"></a>私信，消息功能</h3><p>发送私信，需要输入另外一个人的账号（独一无二的），写好内容发送后更新到数据库，这里没有用消息队列，只用了一个status来判断是否已读。</p>\n<p>消息展示分为朋友私信和系统通知</p>\n<p>私信一页会展示最多5个联系人，每个联系人上面会显示最新的一个对话，具体是用sql语句的select max(id) from message来获取，接下来就是获取时间以及数量之类的<br>点进联系人会是你们的详细聊天记录，url用一个固定conversationid来设置，然后通过这个id查询，这里还有一个设置已读的操作，具体实现就是，你每点击一页（消息也是分页的），就把这一页的都设置已读，因为你看到这一页的是经过查询才看到的，所以查询到东西就可以设置已读，每点击一页查询一页。<br>删除私信就是把状态设置为2的操作</p>\n<p>还有个系统消息，分为评论，点赞，关注，然后分别点进去就是详细的内容，大概逻辑和私信差不多<br>评论点赞消息就不说了，这里讲下关注，关注有人，帖子和回复（这两个没实现，单纯用entitytype来提前记录），关注会用到消息队列来发送系统通知，<br>同时redis中用到一个事务，这个事务包括两个操作，更新我关注的人，同时更新这个被关注人的粉丝情况，取消关注也是用事务，一起更新。<br>当然，在个人信息（也可以看别人的）可以显示我关注的人和关注我的人，以及一共获得点赞数，这些都是存在redis中的数据</p>\n<h3 id=\"账号设置，更新密码，忘记密码\"><a href=\"#账号设置，更新密码，忘记密码\" class=\"headerlink\" title=\"账号设置，更新密码，忘记密码\"></a>账号设置，更新密码，忘记密码</h3><p>账号设置中只有两个操作，更换图像和设置密码</p>\n<p>更换图像这里后面改成用七牛云才存储，这个也用到了消息队列，生成文件名是随机的，避免冲突</p>\n<p>至于更新密码，则是输入旧密码，然后输入两次新密码即可，新密码判断是否一样在前台判断</p>\n<p>忘记密码是在登录页面中的，具体逻辑是通过邮箱来修改，输入正确邮箱后会异步请求forget&#x2F;code这个地址会生成一个验证码，然后发送一个随机验证码到邮箱上，同时session来存这个验证码用于后续判断用户是否输入正确。</p>\n<h3 id=\"其他杂七杂八\"><a href=\"#其他杂七杂八\" class=\"headerlink\" title=\"其他杂七杂八\"></a>其他杂七杂八</h3><p>分享图片，也就是截图该页面保存到七牛云，这个只能手动输入url</p>\n<p>统计日活，权限控制，threadlocal用在保存user信息中，保证并发时隔离线程（代替了session）</p>\n<h1 id=\"牛客网部署\"><a href=\"#牛客网部署\" class=\"headerlink\" title=\"牛客网部署\"></a>牛客网部署</h1><h2 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h2><p>注意这个要下载yum仓库，安装了好多次，最后大概用的代码如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum clean all</span><br><span class=\"line\">rpm --rebuilddb</span><br><span class=\"line\">yum  -y update</span><br><span class=\"line\">rpm -ivh mysql57-community-release-el*-*.noarch.rpm</span><br><span class=\"line\">yum repolist enabled | grep &quot;mysql.*-community.*&quot;</span><br><span class=\"line\">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h2><p>不知道为什么在linux上一直构建不成功，索性直接在windows上构建，然后把war包放在tomcat目录下。</p>\n<h2 id=\"ES\"><a href=\"#ES\" class=\"headerlink\" title=\"ES\"></a>ES</h2><p>和老师用的6.x版本不一样，直接用7.12版本。需要注意的时候，启动不能用root用户，然后如果你没有给普通用户权限的话，可能会启动失败。</p>\n<h2 id=\"wk\"><a href=\"#wk\" class=\"headerlink\" title=\"wk\"></a>wk</h2><p>没有太重视这个功能，在上线的时候砍掉，安装的时候有点问题。</p>\n<h2 id=\"kafka\"><a href=\"#kafka\" class=\"headerlink\" title=\"kafka\"></a>kafka</h2><p>也没啥注意的，正常安装运行。</p>\n<h2 id=\"redis\"><a href=\"#redis\" class=\"headerlink\" title=\"redis\"></a>redis</h2><p>没啥注意的，直接安装即可。</p>\n<h2 id=\"tomcat\"><a href=\"#tomcat\" class=\"headerlink\" title=\"tomcat\"></a>tomcat</h2><p>这个比较坑，在window上用的是tomcat9，但是服务器一开始安装了一个10，死活启动不成功，最后换成9可以了。</p>\n","categories":["学习笔记"],"tags":["JAVA项目-仿牛客网"]},{"title":"写在开头","url":"/2020/03/19/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A4%B4/","content":"<p>自己搭建博客是一件很cool的事情，大三一年都在忙着考研没时间做这件事。<br>等到结束考研，总算有时间去做这些事，得益于互联网的开源精神，搭建博客变得更加容易。<br>免费的Github可以不用租用服务器，强悍的hexo框架让管理博客变得非常快捷方便。<br>今天终于完成这件很cool的事，也是这个博客的第一篇文章！</p>\n","categories":["杂谈"]},{"title":"基础理论学习","url":"/2020/06/26/%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0/","content":"<p>记录一些学习资源，均来源于网络资源，点击文字即可跳转链接</p>\n<p><a href=\"https://study.163.com/course/courseMain.htm?courseId=1003649037\">线性代数</a><br><a href=\"https://zhuanlan.zhihu.com/p/45707832\">线性代数笔记</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=1\">计算机图形学</a><br>计算机图形学笔记——<a href=\"https://zhuanlan.zhihu.com/c_1249465121615204352\">知乎笔记点这里</a>——-<a href=\"https://blog.csdn.net/qq_38065509/category_9873936.html\">CSDN笔记点这里</a><br><a href=\"https://eigen.tuxfamily.org/dox/group__TutorialMatrixArithmetic.html\">C++用的线性代数运算库API</a><br><a href=\"http://games-cn.org/\">计算机图形学与混合现实研讨会</a></p>\n","categories":["学习资源"],"tags":["学习网址"]},{"title":"天津大雪","url":"/2021/12/12/%E5%A4%A9%E6%B4%A5%E5%A4%A7%E9%9B%AA/","content":"<p>时间刚好在立冬这一天(2021年11月7日)，是天津近年来少有的大雪，那就记录这个美好瞬间。</p>\n<span id=\"more\"></span> \n<p><img src=\"/images/tj_snow/1.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/2.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_074341.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_074401.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_075811.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080303.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080317.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080418.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080419.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080433.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080624.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080723.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080929.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_080932.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_081446.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_081651.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_081655.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_082611.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_095434.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_095456.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_095641.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_095643.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_095646.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_115201.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_151046.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_151326.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_151329.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_151848.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_151954.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_155657.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_155942.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_155946.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_160227.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211107_194119.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211108_112219.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211108_181712.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/IMG_20211108_181722.jpg\" alt=\"雪\"><br><img src=\"/images/tj_snow/mmexport1636336685792.jpg\" alt=\"雪\"></p>\n","categories":["美好回忆"],"tags":["天津的雪"]},{"title":"技术学习","url":"/2020/08/04/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/","content":"<p>记录一些学习资源，均来源于网络资源，点击文字即可跳转链接</p>\n<p><a href=\"https://github.com/XiangLinPro/IT_book\">计算机书籍合集项目</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV12E411A7ZQ?p=1\">Python爬虫入门</a><br><a href=\"https://gitee.com/han__Feng/python_notebook/tree/master/python%20_PDF%E7%AC%94%E8%AE%B0\">Python笔记</a>——<a href=\"https://gitee.com/han__Feng/python_notebook/tree/master/python%20_PDF%E7%AC%94%E8%AE%B0\">笔记讲解视频</a></p>\n","categories":["学习资源"]},{"title":"文献","url":"/2020/08/19/%E6%96%87%E7%8C%AE/","content":"<center>记录文献，方便回顾</center>\n<span id=\"more\"></span>\n\n<p>知乎上的方法：<br>1、作者试图解决的问题是什么？为什么它很重要？<br>2、如果这是我的论文项目，我可以采取什么样的实验方法来解决这个问题？<br>3、我需要生成什么样的数据来支持这篇论文的结论？<br>4、这个结论是否符合我之前对这个问题的理解？需要注意的是，需要我（读者）从自己的角度提出一些问题，比如我将如何处理这个问题，我需要什么数据等等</p>\n<p>文献阅读推荐顺序：标题，摘要，引言，结论，相关工作，模型，实验，评论。</p>\n<center><b>神经网络用于多模光纤传输图像</b></center>\n\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>文章名称</th>\n<th>文章背景</th>\n<th>创新点or方法or结论</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>数字散斑的仿真建模与变形场测量(2009)</td>\n<td></td>\n<td></td>\n<td>懵逼</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Image Classification and Reconstruction through Multimode Fibers by Deep Neural Networks(2018)</td>\n<td></td>\n<td>深度学习,VGG</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>基于空间光调制器的多强度测量相位恢复方法(2011)</td>\n<td></td>\n<td>引入内－外层迭代方法，进一步提高了 相位恢复的精度</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>数字激光散斑图像的仿真建模和位移测量算法研究(2006)</td>\n<td>1.缺少动态激光散斑模型 2.散斑图像位移测量计算量大、测量时间较长的不足</td>\n<td>1.基于高斯相关表面的动态激光散斑模型 2.基于傅里叶分析（相位分析？）的数字散斑图像位移测量新方法(同频率相位比较法) 3.提高测量速度、减少图像的采样面积，提出了边缘相关位移摘要测量法 4.减小散斑图像的数据量，提出了利用激光散斑图像的特征点的极值位移测量法和多层平截算法</td>\n<td>博士毕业论文，比较详细，光学部分懵逼</td>\n</tr>\n<tr>\n<td>5</td>\n<td>基于深度卷积神经网络的图像重建算法(2018)</td>\n<td>视频或者图像在传输过程中, 可能出现随机性的误码、突发性的误码、传输中的丢包等等, 对解码出的图像数据也会有严重的影响</td>\n<td>提出了一种基于图像背景预测模糊区域内容的无监督图像重建神经网络模型, 引入了对抗神经网络模型计算重建图像的对抗损失, 重建损失主要反映了新生成的图像内容纹理细节与真值图像的距离, 对抗损失使用对抗神经网络模型测度重建图像和真值图像在结构上的差异. 最后模型在三个不同的数据集下进行了实验</td>\n<td>需要了解对抗神经网络，反卷积，算法评估</td>\n</tr>\n<tr>\n<td>6</td>\n<td>随机介质成像图像重建技术及单光纤成像探索(2015)</td>\n<td></td>\n<td></td>\n<td>硕士毕业论文，较为详细，光学部分懵逼</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Object recognition through a multi‑mode fiber(2016)</td>\n<td></td>\n<td>SVM,神经网络，adaptive boosting(没听过这个方法)</td>\n<td>基于机器学习，将通过多模光纤传输的许多散斑图案提供给分类器</td>\n</tr>\n<tr>\n<td>8</td>\n<td>利用神经网络实现多模光纤传输散斑的识别(2020)</td>\n<td>背景如题目所示</td>\n<td>3层神经网络CNN，4层神经网络CNN，SVM+CNN，决策树，KNN</td>\n<td>CNN原来可以结合SVM算法，论文有介绍如何采集输入的图</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Deep speckle correlation a deep learning approach toward scalable imaging through scattering media(2018)</td>\n<td>一对一的映射很容易受到散斑相关的影响——散射介质的小扰动会导致模型误差和成像性能的严重下降</td>\n<td>研究人员开发了一个卷积神经网络(CNN)，它能够学习在一组具有相同宏观参数的扩散器上捕获的散斑强度模式所包含的统计信息</td>\n<td>没太看懂，用了漫射体(扩散器？),U-NET网络。已抄摘要</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Optical Fiber Specklegram Sensor for Measurement of Force Myography Signals(2016)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>通过光斑预测手势？</td>\n</tr>\n<tr>\n<td>11</td>\n<td><b>（精读）Learning to see through multimode fibers(2018)</b></td>\n<td>各种成像方法都有一定缺陷，能不能用更好的方法进行成像</td>\n<td>用了深度学习对散斑进行分类，用强度检测？</td>\n<td>这个文章应该比较符合我现在的方向的一个思路，主要是对经过光纤传输的图像进行一个重建和分类。已抄摘要</td>\n</tr>\n<tr>\n<td>12</td>\n<td><b>Lensless computational imaging through deep learning(2017)</b></td>\n<td>文章背景</td>\n<td>残差神经网络？</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Deep-Learning-Based Image Reconstruction and Enhancement in Optical Microscopy(2019)</td>\n<td>文章背景</td>\n<td>讲述了各种重建方法</td>\n<td>有点多，可详细看</td>\n</tr>\n<tr>\n<td>14</td>\n<td><b>Deep Hybrid Scattering Image Learning(2018)</b></td>\n<td>列出传统方法的缺点：波前整形，光学相位共轭，传输矩阵(TM)测量</td>\n<td>用深度学习重建</td>\n<td>跟课题方向有点类似。已抄摘要</td>\n</tr>\n<tr>\n<td>15</td>\n<td><b>Deep learning-based object classification through multimode fiber via a CNN-architecture SpeckleNet(2018)</b></td>\n<td>文章背景</td>\n<td>Alex+SVM?</td>\n<td>跟课题方向有点类似</td>\n</tr>\n<tr>\n<td>16</td>\n<td>End-to-End Deep Learning of Optical Fiber Communications(2018)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>晦涩难懂</td>\n</tr>\n<tr>\n<td>17</td>\n<td><b>Multimode optical fiber transmission with a deep learning network(2018)</b></td>\n<td>文章背景</td>\n<td>VGG，RES-NET,Transfer Learning</td>\n<td>在第一部分中，我们证明了深度CNN能够学习两种类型的非线性逆问题:1-振幅到振幅和2-振幅到相位。已抄摘要</td>\n</tr>\n<tr>\n<td>18</td>\n<td>单根多模光纤成像(2019)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>硕士论文</td>\n</tr>\n<tr>\n<td>19</td>\n<td>基于散斑相关性的散射介质后成像研究(2019)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>博士论文，看了前两章，介绍得可以</td>\n</tr>\n<tr>\n<td>20</td>\n<td>计算光学成像在散射中的应用(2019)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>介绍都挺全，综合讲解各种成像方法</td>\n</tr>\n<tr>\n<td>21</td>\n<td>Image reconstruction through a multimode fiber with a simple neural network architecture(2020)</td>\n<td>重建MMF的图像</td>\n<td>Single Hidden Layer Dense Neural Network</td>\n<td>需要了解SSIM(在论文补充材料后面有)SSIM取值范围[0,1]，值越大，表示图像失真越小</td>\n</tr>\n<tr>\n<td>22</td>\n<td>Light scattering control in transmission and reflection with neural networks(2018)</b></td>\n<td>文章背景</td>\n<td>证明了神经网络可以用来找出透射光和反射光之间的函数关系，即它们可以从反射散斑图案中预测透射散斑图案，并具有足够的精度来通过不透明材料进行光控制。然后，利用这个关系，我们证明了神经网络可以用来在使用反射光的传输中进行聚焦</td>\n<td>神经网络的输入是散斑图，输出是照明度(不确定这个专业名词)？</td>\n</tr>\n<tr>\n<td>23</td>\n<td>Learning from simulation: An end-to-end deep-learning approach for computational ghost imaging(2019)</td>\n<td>深度学习结合鬼成像</td>\n<td>新的神经网络架构，用仿真数据训练的网络可以用于实验生成的数据</td>\n<td>与方向相关</td>\n</tr>\n<tr>\n<td>24</td>\n<td>Deep-learning-based ghost imaging(2017)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>25</td>\n<td><b>Learning-based lensless imaging through optically thick scattering media(2019)</b></td>\n<td>厚散射介质成像</td>\n<td>HNN新的网络结构</td>\n<td>司徒国海团队</td>\n</tr>\n<tr>\n<td>26</td>\n<td><b>Imaging through glass diffusers using densely connected convolutional networks(2018)</b></td>\n<td>扩散器介质成像</td>\n<td>IDiff网络+不同的损失函数</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>27</td>\n<td><b>Image reconstruction through a multimode fiber with a simple neural network architecture(2020)</b></td>\n<td>光纤散斑成像</td>\n<td>用SHL-DNN对比CNN</td>\n<td>和课题简直差不多</td>\n</tr>\n<tr>\n<td>28</td>\n<td><b>Learning-based method to reconstruct complex targets through scattering medium beyond the memory effect(2020)</b></td>\n<td>散射介质成像</td>\n<td>新的网络架构对比U-NET</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>29</td>\n<td><b>Imaging through scattering media using speckle pattern classification based support vector regression(2018)</b></td>\n<td>散射介质成像</td>\n<td>先分类再训练，用SVR</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>30</td>\n<td><b>Object recognition for remarkably small field-of-view with speckles(2020)</b></td>\n<td>散斑图像分类</td>\n<td>视场小的也能识别</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>31</td>\n<td>Detecting objects behind scattering media using vortex beams and deep learning(2021)</td>\n<td>重建散斑</td>\n<td>新网络架构</td>\n<td>网络架构描述比较清晰</td>\n</tr>\n<tr>\n<td>32</td>\n<td><b>High-fidelity imaging through multimode fibers via deep learning(2021)</b></td>\n<td>光纤作为传感介质</td>\n<td>创新点or方法or结论</td>\n<td>有和作者邮件联系过，论文中的accuracy是分类</td>\n</tr>\n<tr>\n<td>33</td>\n<td><b>Photon-limited imaging through scattering medium based on deep learning(2019)</b></td>\n<td>文章背景</td>\n<td>学习网络架构</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>34</td>\n<td>Predicting optical transmission through complex scattering media from reflection patterns with deep neural networks(2021)</td>\n<td>文章背景</td>\n<td>用了不同厚度散射介质，越厚越不清晰</td>\n<td>提及到的transmission spkecle不知道是什么</td>\n</tr>\n<tr>\n<td>35</td>\n<td><b>Deep learning the high variability and randomness inside multimode fibers(2019)</b></td>\n<td>有光纤哦</td>\n<td>创新点or方法or结论</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>36</td>\n<td><b>Deep Learning: High-quality Imaging through Multicore Fiber(2020)</b></td>\n<td>文章背景</td>\n<td>和optica的dense+Unet网络一样</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>37</td>\n<td><b>Image reconstruction through a hollow core fiber via deep learning(2021)</b></td>\n<td>文章背景</td>\n<td>U-NET</td>\n<td>发过邮件给作者，感觉他心虚</td>\n</tr>\n<tr>\n<td>38</td>\n<td>Ghost imaging based on Y-net a dynamic coding and decoding approach(2020)</td>\n<td>鬼成像</td>\n<td>把仿真和实验结合起来，但是不知道是怎么找到ccd的成像公式</td>\n<td>diffuser含糊不清，可以参考2018optica那篇，也有diffuser</td>\n</tr>\n<tr>\n<td>39</td>\n<td><b>Experimental Demonstration of a Multimode Fiber Imaging System Based on Generative Adversarial Networks(2019)</b></td>\n<td>散斑成像</td>\n<td>用了对抗神经网络</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>40</td>\n<td><b>High-speed multimode fiber imaging system based on conditional generative adversarial network(2021)</b></td>\n<td>散斑成像</td>\n<td>创新点or方法or结论</td>\n<td>和上一篇是一个实验室出来的，差别不大，换了些指标</td>\n</tr>\n<tr>\n<td>41</td>\n<td>Image reconstruction through dynamic scattering media based on deep learning(2019)</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>本文GAN，有5种动态散斑，然后分类再训练，不太明白为什么还要弄一个分类网络，你不是早就知道哪个是哪个类别了吗，想不懂这个操作</td>\n</tr>\n<tr>\n<td>42</td>\n<td>U2-Net: Going Deeper with Nested U-Structure for Salient Object Detection(2020)</td>\n<td>改进的U-NET，有源代码</td>\n<td>创新点or方法or结论</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>43</td>\n<td>Phase recovery and holographic image reconstruction using deep learning in neural networks(2017)</td>\n<td>全息图重建+深度学习</td>\n<td>创新点or方法or结论</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>44</td>\n<td><b>High definition images transmission through single multimode fiber using deep learning and simulation speckles(2021)</b></td>\n<td>文章背景</td>\n<td>计算实验的传输矩阵+深度学习</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>45</td>\n<td><b>Imaging through multimode fibers using deep learning The effects of intensity versus holographic recording of the speckle pattern(2019)</b></td>\n<td>文章背景</td>\n<td>用全息图，强度图，振幅，相位来分类</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>46</td>\n<td><b>Mutual Transfer Learning of Reconstructing Images Through a Multimode Fiber or a Scattering Medium(2021)</b></td>\n<td>文章背景</td>\n<td>用了迁移学习</td>\n<td>网络：UNET+dense(特制复用)+mobilenet（轻量）</td>\n</tr>\n<tr>\n<td>47</td>\n<td><b>Swin Transformer: Hierarchical Vision Transformer using Shifted Windows(2021)</b></td>\n<td>非常强！！！替代CNN</td>\n<td>提出swin-transformer用于CV领域中</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>48</td>\n<td><b>Swin-Unet: Unet-like Pure Transformer for Medical Image Segmentation(2021)</b></td>\n<td>医学分割用transformer</td>\n<td>swin-transformer改成Unet形状，其中expand层是作者改的</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>49</td>\n<td>Masked Autoencoders Are Scalable Vision Learners(2021)</td>\n<td>NLP的东西应用到视觉</td>\n<td>提出MAE(掩码自编码器)方法</td>\n<td>备注</td>\n</tr>\n<tr>\n<td>50</td>\n<td>Swin Transformer V2: Scaling Up Capacity and Resolution(2021)</td>\n<td>swin——transformer第二个版本</td>\n<td>提出后归一化和缩放余弦注意力</td>\n<td>-</td>\n</tr>\n<tr>\n<td>51</td>\n<td>An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale</td>\n<td>谷歌团队应用Transformer在CV领域</td>\n<td>做到尽量不改变Transformer架构</td>\n<td>-</td>\n</tr>\n</tbody></table>\n<center><b>深度学习，机器学习</b></center>\n\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>文章名称</th>\n<th>文章背景</th>\n<th>创新点or方法or结论</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Convolutional Neural Network</td>\n<td>文章背景</td>\n<td>创新点or方法or结论</td>\n<td>李宏毅写的，不是论文，更多的是图</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzA3MzI4MjgzMw==&mid=2650786169&idx=3&sn=78daf0132ed86258bca062d69688788a&chksm=871a0d07b06d8411fe2f92abf753f6737acab1cc2119883fb1fad5b370178e2ec728968c7823&scene=21#wechat_redirect\">炼丹技巧</a><br><a href=\"https://zhuanlan.zhihu.com/p/145009250\">图像分割</a></p>\n<style>\ntable th:first-of-type {\n    width: 3%;\n}\ntable th:nth-of-type(2) {\n    width: 25%;\n}\ntable th:nth-of-type(3) {\n    width: 25%;\n}\ntable th:nth-of-type(4) {\n    width: 35%;\n}\ntable th:nth-of-type(5) {\n    width: 12%;\n}\n\n</style>\n","categories":["研究生阶段--科研工具，科研网址及科研记录"],"tags":["文献"]},{"title":"断墨寻径","url":"/2021/12/08/%E6%96%AD%E5%A2%A8%E5%AF%BB%E5%BE%84/","content":"<p>记录公众号《超智能体》中的一个视频内容,主要讲怎么学习。</p>\n<span id=\"more\"></span> \n<h1 id=\"断墨寻径\"><a href=\"#断墨寻径\" class=\"headerlink\" title=\"断墨寻径\"></a>断墨寻径</h1><ol>\n<li><p>记忆的目的是重现。学习的目的是泛化，去解决一些从来没有遇到过的情况，让我们去生成新的信息。这也是信息和知识的区别。</p>\n</li>\n<li><p>指令学习（看书看定义），归纳学习（做题，也就是有实例），要做到混合使用。</p>\n</li>\n<li><p>合理做题，就是要总结。只会旧题，不会新题，会让大脑构建以偏概全的局部规律，就是过拟和（1.做更多不同题目，2.还有增加题目的通用型，如无必要，勿增实体，不要用繁琐方法做，而是用通用方法）。欠拟和，就是拟和的规律结果旧情况也不满足，这时候需要反复去找规律，大脑的意识基本都可以找到。方法总结1选定知识2指令学习3做练习题4归纳比较5测试新题。</p>\n</li>\n<li><p>如何正确用知识。学习任何一个知识，要知道知识的适用范围，也就是前提条件，把握使用条件。所以，为什么有的人看了很多付费课程（课程的知识很多例子都是为围绕这个故事归纳的，所以我们会觉得很有道理），听过那么多道理，依旧过不好这一生。</p>\n</li>\n<li><p>看不懂书怎么办？先说下什么是完整实例。也就是要有完整的起因结果。所以看论文并不是去记忆论文，而是是搞懂论文中的名词。还有数学语言，我们觉得不懂，是因为我们只把当中的数学符号当做字母，而不是去了解他们的指代是什么，所以会认为我们数学不好。</p>\n</li>\n<li><p>超越学习的瓶颈。1材料瓶颈。当我们学习到一定程度时候，会遇到很多重复的材料，无论怎么背诵，都无法去提升我们的泛化能力，这就是材料所引起的瓶颈，所以，应该去搜集更多的新材料，而不是去重复旧材料。2对于模型瓶颈（旧认识引起来的瓶颈），我们则需要用实例材料来解除抗拒，而不是用指令材料（比如当一个人不相信一太阳从东边升起来，那你就直接带他去看，而不是描述给他听），否则只会加强抗拒。</p>\n</li>\n<li><p>大脑🧠如何存储信息。需要反复用不同材料训练大脑，让大脑神经元不断去调整到普遍性状态（达到泛化），而不是变成过拟和或者欠拟和状态。需要做到有效材料，有效训练，以及有效睡眠。</p>\n</li>\n<li><p>有效训练。刺激相关细胞的方法最好方式是实际执行并得到结果。看三遍不如自己去做一遍。做题要经过完整的思考过程。建立新旧知识之间关联。还有把书读薄并不是说对书本进行删减，而是在状态上把书读薄，这样才能去泛化其他知识。</p>\n</li>\n<li><p>验证我们学习的知识，也就是用在新问题上。对于指令学习，要用自己的话去表述。所以，教别人是一种巩固知识的方法，教别人用到了可以是举个例子别人听，或者用自己的话去描述这个知识。</p>\n</li>\n<li><p>看下面总结图片，归根到底，也就是学以致用。</p>\n</li>\n</ol>\n<p><img src=\"/images/superai/1.png\" alt=\"总结\"></p>\n","categories":["学习笔记"],"tags":["如何学习"]},{"title":"树莓派HomeAssistant系列（三）天气，邮箱，RSS订阅，自动化(每日天气邮件提醒，RSS通知)","url":"/2022/03/18/%E6%A0%91%E8%8E%93%E6%B4%BEHomeAssistant%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%A4%A9%E6%B0%94%EF%BC%8C%E9%82%AE%E7%AE%B1%EF%BC%8CRSS%E8%AE%A2%E9%98%85%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%96-%E6%AF%8F%E6%97%A5%E5%A4%A9%E6%B0%94%E9%82%AE%E4%BB%B6%E6%8F%90%E9%86%92%EF%BC%8CRSS%E9%80%9A%E7%9F%A5/","content":"<p>HomeAassistant系列</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-天气设置\"><a href=\"#1-天气设置\" class=\"headerlink\" title=\"1.天气设置\"></a>1.天气设置</h1><p>提供两种天气设置，任君选择，也可以都要哦</p>\n<h2 id=\"1-1彩云天气设置\"><a href=\"#1-1彩云天气设置\" class=\"headerlink\" title=\"1.1彩云天气设置\"></a>1.1彩云天气设置</h2><h3 id=\"1-1-1集成中搜索colorfulcloud并安装。\"><a href=\"#1-1-1集成中搜索colorfulcloud并安装。\" class=\"headerlink\" title=\"1.1.1集成中搜索colorfulcloud并安装。\"></a>1.1.1集成中搜索colorfulcloud并安装。</h3><h3 id=\"1-1-2彩云天气申请api\"><a href=\"#1-1-2彩云天气申请api\" class=\"headerlink\" title=\"1.1.2彩云天气申请api\"></a>1.1.2彩云天气申请api</h3><p><a href=\"https://dashboard.caiyunapp.com/v1/token/\">https://dashboard.caiyunapp.com/v1/token/</a></p>\n<h3 id=\"1-1-3使用配套的样式来展示天气\"><a href=\"#1-1-3使用配套的样式来展示天气\" class=\"headerlink\" title=\"1.1.3使用配套的样式来展示天气\"></a>1.1.3使用配套的样式来展示天气</h3><p>在HACS的前端中搜索Colorfulclouds Weather Card下载。</p>\n<h3 id=\"1-1-4配置天气\"><a href=\"#1-1-4配置天气\" class=\"headerlink\" title=\"1.1.4配置天气\"></a>1.1.4配置天气</h3><p>输入好你的api，居住地方所在的经纬度即可。<br>当然，如果你在configuration.yaml中提前填入你的经纬度，彩云天气会自动获取。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">homeassistant:</span><br><span class=\"line\">  name: Home</span><br><span class=\"line\">  latitude: xxxx</span><br><span class=\"line\">  longitude: xxx</span><br><span class=\"line\">  time_zone: &quot;Asia/Shanghai&quot;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2和风天气设置\"><a href=\"#1-2和风天气设置\" class=\"headerlink\" title=\"1.2和风天气设置\"></a>1.2和风天气设置</h2><p>首先非常感谢这个作者的开源，链接如下：<br><a href=\"https://github.com/morestart/HeWeather\">https://github.com/morestart/HeWeather</a></p>\n<h3 id=\"1-2-1和风天气申请api\"><a href=\"#1-2-1和风天气申请api\" class=\"headerlink\" title=\"1.2.1和风天气申请api\"></a>1.2.1和风天气申请api</h3><h3 id=\"1-2-2下载集成到HA中\"><a href=\"#1-2-2下载集成到HA中\" class=\"headerlink\" title=\"1.2.2下载集成到HA中\"></a>1.2.2下载集成到HA中</h3><p>打开你HA所在路径，然后在custom_components中创建文件夹HeWeather</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">mkdir -p custom_components/HeWeather</span><br></pre></td></tr></table></figure>\n<p>使用命令下载集成</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd custom_components/HeWeather/</span><br><span class=\"line\">curl -O https://raw.githubusercontent.com/morestart/HeWeather/More-than-0.63/sensor.py</span><br><span class=\"line\">curl -O https://raw.githubusercontent.com/morestart/HeWeather/More-than-0.63/manifest.json</span><br></pre></td></tr></table></figure>\n<p>配置天气，在configuration.yaml中填入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sensor:</span><br><span class=\"line\">  - platform: HeWeather</span><br><span class=\"line\">    city: auto_ip 或者 填写城市名称 eg（北京，beijing）</span><br><span class=\"line\">    appkey: 你的密钥（即API）</span><br><span class=\"line\">    options:</span><br><span class=\"line\">      - fl</span><br><span class=\"line\">      - tmp</span><br><span class=\"line\">      - cond_txt</span><br><span class=\"line\">      - wind_spd</span><br><span class=\"line\">      - hum</span><br><span class=\"line\">      - pcpn</span><br><span class=\"line\">      - pres</span><br><span class=\"line\">      - vis</span><br><span class=\"line\">      - wind_sc</span><br><span class=\"line\">      - aqi</span><br><span class=\"line\">      - main</span><br><span class=\"line\">      - qlty</span><br><span class=\"line\">      - pm10</span><br><span class=\"line\">      - pm25</span><br><span class=\"line\">      - comf</span><br><span class=\"line\">      - cw</span><br><span class=\"line\">      - drsg</span><br><span class=\"line\">      - flu</span><br><span class=\"line\">      - sport</span><br><span class=\"line\">      - trav</span><br><span class=\"line\">      - uv</span><br><span class=\"line\">      - wind_dir</span><br><span class=\"line\">      - tmp_max</span><br><span class=\"line\">      - tmp_min</span><br><span class=\"line\">      - pop</span><br></pre></td></tr></table></figure>\n<p>重启HA即可</p>\n<h1 id=\"2-邮箱设置\"><a href=\"#2-邮箱设置\" class=\"headerlink\" title=\"2.邮箱设置\"></a>2.邮箱设置</h1><h2 id=\"2-1在configuration-yaml设置如下信息，以QQ邮箱为例\"><a href=\"#2-1在configuration-yaml设置如下信息，以QQ邮箱为例\" class=\"headerlink\" title=\"2.1在configuration.yaml设置如下信息，以QQ邮箱为例\"></a>2.1在configuration.yaml设置如下信息，以QQ邮箱为例</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">notify:</span><br><span class=\"line\">  - name: &quot;send_email&quot;</span><br><span class=\"line\">    platform: smtp</span><br><span class=\"line\">    server: &quot;smtp.qq.com&quot;</span><br><span class=\"line\">    port: 465</span><br><span class=\"line\">    timeout: 15</span><br><span class=\"line\">    sender: &quot;xx@qq.com&quot;</span><br><span class=\"line\">    encryption: tls</span><br><span class=\"line\">    username: &quot;xx@qq.com&quot;</span><br><span class=\"line\">    password: xx</span><br><span class=\"line\">    recipient:</span><br><span class=\"line\">      - &quot;xx@qq.com&quot;</span><br><span class=\"line\">    sender_name: &quot;智能家庭助手&quot;</span><br></pre></td></tr></table></figure>\n<p>注意的点：<br>1.这是用SMTP来设置的邮箱提醒，需要确保你的邮箱开启SMTP服务<br>2.server，不同邮箱是不一样的，比如163邮箱是smtp.163.com<br>3.port，一般是465，采用是SMTP SSL<br>4.password，不是你的邮箱密码！是SMTP授权码！<br>5.username和recipient就是发送者和接受者的邮箱，自己发给自己就填一样的。</p>\n<h1 id=\"3-RSS订阅\"><a href=\"#3-RSS订阅\" class=\"headerlink\" title=\"3.RSS订阅\"></a>3.RSS订阅</h1><p>在configuration.yaml设置如下信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">feedreader:</span><br><span class=\"line\">  urls:#订阅的网址，可以订阅多个RSS</span><br><span class=\"line\">    - xxxx.xml</span><br><span class=\"line\">    - xxxx.xml</span><br><span class=\"line\">  scan_interval:</span><br><span class=\"line\">    minutes: 1   #扫描时间间隔</span><br><span class=\"line\">  max_entries: 10</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-自动化（每日天气邮件提醒，RSS通知）\"><a href=\"#4-自动化（每日天气邮件提醒，RSS通知）\" class=\"headerlink\" title=\"4.自动化（每日天气邮件提醒，RSS通知）\"></a>4.自动化（每日天气邮件提醒，RSS通知）</h1><p>以下配置均在automations.yaml中填写(请大家注意，下面参数前面的空格不要丢掉，如-alias前面有空格)</p>\n<h2 id=\"4-1每天日出的时候发送天气到邮件\"><a href=\"#4-1每天日出的时候发送天气到邮件\" class=\"headerlink\" title=\"4.1每天日出的时候发送天气到邮件\"></a>4.1每天日出的时候发送天气到邮件</h2><p>需要设置和风天气（1.2），以及设置你们家的经纬度信息来判断日出（1.1.4的configuration.yaml设置）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- alias: 每日天气邮件提醒</span><br><span class=\"line\">  trigger:</span><br><span class=\"line\">    platform: sun</span><br><span class=\"line\">    event: sunrise</span><br><span class=\"line\">    offset: &#x27;0&#x27;</span><br><span class=\"line\">  action:</span><br><span class=\"line\">    service: notify.send_email</span><br><span class=\"line\">    data:</span><br><span class=\"line\">      message: 早上好鸭，小陈同学!现在外面的温度是&#123;&#123;states(&#x27;sensor.shi_shi_shi_wai_wen_du&#x27;)&#125;&#125;°C，今日最低温度&#123;&#123;states(&#x27;sensor.jin_ri_zui_di_wen_du&#x27;)&#125;&#125;°C，最高温度&#123;&#123;states(&#x27;sensor.jin_ri_zui_gao_wen_du&#x27;)&#125;&#125;°C。今天&#123;&#123;state_attr(&#x27;sensor.chuan_yi_zhi_shu&#x27;,&#x27;生活建议&#x27;) &#125;&#125;今天也要加油呀！！ </span><br></pre></td></tr></table></figure>\n<p>上面有两点注意，和风天气的传感器有状态和属性，比如如果你要提取状态，就写如下信息，下面是实时室外温度</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123;states(&#x27;sensor.shi_shi_shi_wai_wen_du&#x27;)&#125;&#125;</span><br><span class=\"line\">提取属性需要填写如下信息，一般来说，属性有很多参数，比如可能有生活建议，更新时间，friendly_name，填写你需要的属性即可提取</span><br><span class=\"line\">&#123;&#123;state_attr(&#x27;sensor.chuan_yi_zhi_shu&#x27;,&#x27;生活建议&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2RSS订阅提醒\"><a href=\"#4-2RSS订阅提醒\" class=\"headerlink\" title=\"4.2RSS订阅提醒\"></a>4.2RSS订阅提醒</h2><p>需要先提前设置好RSS订阅</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- alias: &quot;RSS订阅更新&quot;</span><br><span class=\"line\">  trigger:</span><br><span class=\"line\">    platform: event</span><br><span class=\"line\">    event_type: feedreader</span><br><span class=\"line\">  action:</span><br><span class=\"line\">    service: persistent_notification.create</span><br><span class=\"line\">    data:</span><br><span class=\"line\">      title: &#x27;&#123;&#123;trigger.event.data.link&#125;&#125;&#x27;</span><br><span class=\"line\">      message: &quot;RSS更新啦 - &#123;&#123; as_timestamp(now()) | timestamp_custom(&#x27;%I:%M:%S %p %d%b%Y&#x27;, true) &#125;&#125;&quot;</span><br><span class=\"line\">      notification_id: &quot;&#123;&#123; trigger.event.data.title &#125;&#125;&quot;</span><br></pre></td></tr></table></figure>\n<p>这里需要注意一点，就是上面的自动化信息我都是在automations.yaml，然后的话在配置-场景自动化中也能手动创建自动化，但是如果在这里创建了新的自动化，会显示不出来，可能与automations.yaml的冲突。</p>\n","categories":["HomeAassistant"]},{"title":"树莓派HomeAssistant系列（二）MQTT监控你的树莓派","url":"/2022/03/05/%E6%A0%91%E8%8E%93%E6%B4%BEHomeAssistant%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89MQTT%E7%9B%91%E6%8E%A7%E4%BD%A0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE/","content":"<p>HomeAassistant系列</p>\n<span id=\"more\"></span>\n<h1 id=\"1-安装MQTT\"><a href=\"#1-安装MQTT\" class=\"headerlink\" title=\"1. 安装MQTT\"></a>1. 安装MQTT</h1><h2 id=\"1-1-使用Docker安装\"><a href=\"#1-1-使用Docker安装\" class=\"headerlink\" title=\"1.1 使用Docker安装\"></a>1.1 使用Docker安装</h2><p>首先我们要创建要3个文件夹，用来等下挂载容器用的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mkdir -p /mosquitto/config</span><br><span class=\"line\">sudo mkdir -p /mosquitto/data</span><br><span class=\"line\">sudo mkdir -p /mosquitto/log</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-2-创建好配置文件\"><a href=\"#1-2-创建好配置文件\" class=\"headerlink\" title=\"1.2 创建好配置文件\"></a>1.2 创建好配置文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vim /mosquitto/config/mosquitto.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-3-写入内容并保存\"><a href=\"#1-3-写入内容并保存\" class=\"headerlink\" title=\"1.3 写入内容并保存\"></a>1.3 写入内容并保存</h2><p>这里就是遇到终极大坑，很多博主都是写前三行，包括官方文档确实也是这样，但是！官方升级2.x版本后，如果你没有设置账号密码，是不允许匿名连接MQTT的，害我找了2天资料才发现，也就是allow_anonymous true这一行非常关键，因为当时急着用这个功能，就不创建账号密码，结果折腾死我。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">persistence true</span><br><span class=\"line\">persistence_location /mosquitto/data/</span><br><span class=\"line\">log_dest file /mosquitto/log/mosquitto.log</span><br><span class=\"line\">allow_anonymous true</span><br><span class=\"line\">listener 1883</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-4-授权文件运行\"><a href=\"#1-4-授权文件运行\" class=\"headerlink\" title=\"1.4 授权文件运行\"></a>1.4 授权文件运行</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">chmod -R 755 /mosquitto</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-5-安装MQTT\"><a href=\"#1-5-安装MQTT\" class=\"headerlink\" title=\"1.5 安装MQTT\"></a>1.5 安装MQTT</h2><p>还有需要说明一点，MQTT其实有好几家做的，然后eclipse-mosquitto是比较欢迎的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -it --name=mosquitto --privileged \\</span><br><span class=\"line\">-p 1883:1883 -p 9001:9001 \\</span><br><span class=\"line\">-v /mosquitto/config/mosquitto.conf:/mosquitto/config/mosquitto.conf \\</span><br><span class=\"line\">-v /mosquitto/data:/mosquitto/data \\</span><br><span class=\"line\">-v /mosquitto/log:/mosquitto/log \\</span><br><span class=\"line\">eclipse-mosquitto</span><br></pre></td></tr></table></figure>\n<h1 id=\"2-验证MQTT是否启动成功\"><a href=\"#2-验证MQTT是否启动成功\" class=\"headerlink\" title=\"2. 验证MQTT是否启动成功\"></a>2. 验证MQTT是否启动成功</h1><h2 id=\"2-1-配置MQTT\"><a href=\"#2-1-配置MQTT\" class=\"headerlink\" title=\"2.1 配置MQTT\"></a>2.1 配置MQTT</h2><p>在configuration.yaml中加入以下信息来添加MQTT：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mqtt:</span><br><span class=\"line\">  # MQTT Broker的IP地址或者域名</span><br><span class=\"line\">  broker: 192.168.1.104</span><br><span class=\"line\">  # MQTT Broker的端口号，缺省为1883</span><br><span class=\"line\">  port: 1883</span><br><span class=\"line\">  # 配置自动发现</span><br><span class=\"line\">  discovery: true</span><br><span class=\"line\">  # 自动发现使用的主题位置前缀，缺省为homeassistant</span><br><span class=\"line\">  discovery_prefix: homeassistant</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-监控树莓派\"><a href=\"#3-监控树莓派\" class=\"headerlink\" title=\"3.监控树莓派\"></a>3.监控树莓派</h1><h2 id=\"3-1-安装好一些必备包\"><a href=\"#3-1-安装好一些必备包\" class=\"headerlink\" title=\"3.1 安装好一些必备包\"></a>3.1 安装好一些必备包</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git python3 python3-pip python3-tzlocal python3-sdnotify python3-colorama python3-unidecode python3-paho-mqtt</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2-下载源文件\"><a href=\"#3-2-下载源文件\" class=\"headerlink\" title=\"3.2 下载源文件\"></a>3.2 下载源文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo git clone https://github.com/ironsheep/RPi-Reporter-MQTT2HA-Daemon.git /opt/RPi-Reporter-MQTT2HA-Daemon</span><br><span class=\"line\">cd /opt/RPi-Reporter-MQTT2HA-Daemon</span><br><span class=\"line\">sudo pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3-复制并修改配置文件\"><a href=\"#3-3-复制并修改配置文件\" class=\"headerlink\" title=\"3.3 复制并修改配置文件\"></a>3.3 复制并修改配置文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo cp /opt/RPi-Reporter-MQTT2HA-Daemon/config.&#123;ini.dist,ini&#125;</span><br><span class=\"line\">sudo vim /opt/RPi-Reporter-MQTT2HA-Daemon/config.ini</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-4-我的配置信息\"><a href=\"#3-4-我的配置信息\" class=\"headerlink\" title=\"3.4 我的配置信息\"></a>3.4 我的配置信息</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Configuration file for RPi-Reporter-MQTT2HA-Daemon</span><br><span class=\"line\"># Source: https://github.com/ironsheep/RPi-Reporter-MQTT2HA-Daemon</span><br><span class=\"line\">#</span><br><span class=\"line\"># Uncomment and adapt all settings as needed.</span><br><span class=\"line\"># Some settings can be configured by environment variables.</span><br><span class=\"line\"># If an env variable is set, it takes precedence over settings in this file</span><br><span class=\"line\"></span><br><span class=\"line\">[Daemon]</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable or Disable an endless execution loop (Default: true)</span><br><span class=\"line\">enabled = true</span><br><span class=\"line\"></span><br><span class=\"line\"># This script reports RPi values at a fixed interval in minutes [2-30], [Default: 5]</span><br><span class=\"line\">interval_in_minutes = 5</span><br><span class=\"line\"></span><br><span class=\"line\"># default domain to use when hostname -f doesn&#x27;t return a proper fqdn</span><br><span class=\"line\">#fallback_domain = home</span><br><span class=\"line\"></span><br><span class=\"line\">[MQTT]</span><br><span class=\"line\"></span><br><span class=\"line\"># The hostname or IP address of the MQTT broker to connect to (Default: localhost)</span><br><span class=\"line\"># Also read from the MQTT_HOSTNAME environment variable</span><br><span class=\"line\">hostname = localhost</span><br><span class=\"line\"></span><br><span class=\"line\"># The TCP port the MQTT broker is listening on (Default: 1883)</span><br><span class=\"line\"># Also read from the MQTT_PORT environment variable</span><br><span class=\"line\">port = 1883</span><br><span class=\"line\"></span><br><span class=\"line\"># Maximum period in seconds between ping messages to the broker. (Default: 60)</span><br><span class=\"line\">keepalive = 60</span><br><span class=\"line\"></span><br><span class=\"line\"># by default Home Assistant listens to the /homeassistant but it can be changed for a given installation</span><br><span class=\"line\">#  likewise, by default this script advertises on the same default topic. If you use a different </span><br><span class=\"line\">#  discovery prefix then specify yours here.  [default: homeassistant]</span><br><span class=\"line\">discovery_prefix = homeassistant</span><br><span class=\"line\"></span><br><span class=\"line\"># NOTE: The MQTT topic used for this device is constructed as:</span><br><span class=\"line\">#  &#123;base_topic&#125;/&#123;sensor_name&#125;</span><br><span class=\"line\">#</span><br><span class=\"line\"># The MQTT base topic under which to publish the Raspberry Pi sensor data topics.</span><br><span class=\"line\">base_topic = home/nodes</span><br><span class=\"line\"></span><br><span class=\"line\"># The MQTT name for this Raspberry Pi as a sensor</span><br><span class=\"line\">sensor_name = rpi-localhost</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"># The MQTT broker authentification credentials (Default: no authentication)</span><br><span class=\"line\"># Will also read from MQTT_USERNAME and MQTT_PASSWORD environment variables</span><br><span class=\"line\">#username = user</span><br><span class=\"line\">#password = pwd123</span><br><span class=\"line\"></span><br><span class=\"line\"># Enable TLS/SSL on the connection</span><br><span class=\"line\">#tls = false</span><br><span class=\"line\"></span><br><span class=\"line\"># Path to CA Certificate file to verify host</span><br><span class=\"line\">#tls_ca_cert =</span><br><span class=\"line\"></span><br><span class=\"line\"># Path to TLS client auth key file</span><br><span class=\"line\">#tls_keyfile =</span><br><span class=\"line\"></span><br><span class=\"line\"># Path to TLS client auth certificate file</span><br><span class=\"line\">#tls_certfile =</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5-测试\"><a href=\"#3-5-测试\" class=\"headerlink\" title=\"3.5 测试\"></a>3.5 测试</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">python3 /opt/RPi-Reporter-MQTT2HA-Daemon/ISP-RPi-mqtt-daemon.py</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-6-设置守护程序帐户以允许访问温度值。\"><a href=\"#3-6-设置守护程序帐户以允许访问温度值。\" class=\"headerlink\" title=\"3.6 设置守护程序帐户以允许访问温度值。\"></a>3.6 设置守护程序帐户以允许访问温度值。</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">groups daemon</span><br><span class=\"line\">sudo usermod daemon -a -G video</span><br><span class=\"line\">groups daemon</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7-设置程序开机后台运行，至此我们已经全部设置完毕了！\"><a href=\"#3-7-设置程序开机后台运行，至此我们已经全部设置完毕了！\" class=\"headerlink\" title=\"3.7 设置程序开机后台运行，至此我们已经全部设置完毕了！\"></a>3.7 设置程序开机后台运行，至此我们已经全部设置完毕了！</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ln -s /opt/RPi-Reporter-MQTT2HA-Daemon/isp-rpi-reporter.service /etc/systemd/system/isp-rpi-reporter.service</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl enable isp-rpi-reporter.service</span><br><span class=\"line\">sudo systemctl start isp-rpi-reporter.service</span><br><span class=\"line\">sudo systemctl status isp-rpi-reporter.service</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-8-后期更新软件\"><a href=\"#3-8-后期更新软件\" class=\"headerlink\" title=\"3.8 后期更新软件\"></a>3.8 后期更新软件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /opt/RPi-Reporter-MQTT2HA-Daemon</span><br><span class=\"line\">sudo systemctl stop isp-rpi-reporter.service</span><br><span class=\"line\">sudo git pull</span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\">sudo systemctl start isp-rpi-reporter.service</span><br><span class=\"line\">systemctl status isp-rpi-reporter.service</span><br></pre></td></tr></table></figure>\n<h1 id=\"4-高颜值外表卡片设置\"><a href=\"#4-高颜值外表卡片设置\" class=\"headerlink\" title=\"4 高颜值外表卡片设置\"></a>4 高颜值外表卡片设置</h1><h2 id=\"4-1-下载地址\"><a href=\"#4-1-下载地址\" class=\"headerlink\" title=\"4.1 下载地址\"></a>4.1 下载地址</h2><p><a href=\"https://github.com/ironsheep/lovelace-rpi-monitor-card\">https://github.com/ironsheep/lovelace-rpi-monitor-card</a></p>\n<h2 id=\"4-2-卡片配置代码\"><a href=\"#4-2-卡片配置代码\" class=\"headerlink\" title=\"4.2 卡片配置代码\"></a>4.2 卡片配置代码</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type: entities</span><br><span class=\"line\">entities:</span><br><span class=\"line\">  - sensor.rpi_cpu_use_raspberrypi</span><br><span class=\"line\">  - sensor.rpi_monitor_raspberrypi</span><br><span class=\"line\">  - sensor.rpi_temp_raspberrypi</span><br><span class=\"line\">  - sensor.rpi_used_raspberrypi</span><br><span class=\"line\">title: RPi-raspberrypi</span><br><span class=\"line\">state_color: true</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">type: custom:rpi-monitor-card</span><br><span class=\"line\">entity: sensor.rpi_monitor_raspberrypi</span><br><span class=\"line\">card_style: full</span><br><span class=\"line\">temp_scale: C</span><br><span class=\"line\">fs_severity:</span><br><span class=\"line\">  - color: Green</span><br><span class=\"line\">    from: 0</span><br><span class=\"line\">    to: 25</span><br><span class=\"line\">  - color: Orange</span><br><span class=\"line\">    from: 26</span><br><span class=\"line\">    to: 50</span><br><span class=\"line\">  - color: Red</span><br><span class=\"line\">    from: 51</span><br><span class=\"line\">    to: 100</span><br><span class=\"line\">temp_severity:</span><br><span class=\"line\">  - color: Green</span><br><span class=\"line\">    from: 0</span><br><span class=\"line\">    to: 59</span><br><span class=\"line\">  - color: Orange</span><br><span class=\"line\">    from: 60</span><br><span class=\"line\">    to: 79</span><br><span class=\"line\">  - color: Red</span><br><span class=\"line\">    from: 80</span><br><span class=\"line\">    to: 100</span><br></pre></td></tr></table></figure>","categories":["HomeAassistant"],"tags":["MQTT"]},{"title":"树莓派HomeAssistant系列（四）NodeRed安装配置","url":"/2022/04/01/%E6%A0%91%E8%8E%93%E6%B4%BEHomeAssistant%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89NodeRed%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/","content":"<p>HomeAassistant系列</p>\n<span id=\"more\"></span>\n<p>Nodered是为了方便实现自动化的一个工具，所以用在HA上很有必要。</p>\n<h2 id=\"1-新建目录nodered（用于映射docker中的nodered）\"><a href=\"#1-新建目录nodered（用于映射docker中的nodered）\" class=\"headerlink\" title=\"1.新建目录nodered（用于映射docker中的nodered）\"></a>1.新建目录nodered（用于映射docker中的nodered）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir /home/pi/nodered</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-docker安装nodered（注意里面的有刚才创建的路径-home-pi-nodered，如果你是其他路径，请修改）\"><a href=\"#2-docker安装nodered（注意里面的有刚才创建的路径-home-pi-nodered，如果你是其他路径，请修改）\" class=\"headerlink\" title=\"2.docker安装nodered（注意里面的有刚才创建的路径&#x2F;home&#x2F;pi&#x2F;nodered，如果你是其他路径，请修改）\"></a>2.docker安装nodered（注意里面的有刚才创建的路径&#x2F;home&#x2F;pi&#x2F;nodered，如果你是其他路径，请修改）</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -it -d -p 1880:1880 --name=nodered --restart=always --user=root --net=host -v /home/pi/nodered:/data -e TZ=Asia/Shanghai nodered/node-red</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-打开http-localhost-1880-进入nodered配置相关信息\"><a href=\"#3-打开http-localhost-1880-进入nodered配置相关信息\" class=\"headerlink\" title=\"3.打开http://localhost:1880/进入nodered配置相关信息\"></a>3.打开<a href=\"http://localhost:1880/%E8%BF%9B%E5%85%A5nodered%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF\">http://localhost:1880/进入nodered配置相关信息</a></h2><p><img src=\"/images/ha/4/1.png\"><br>搜索node-red-contrib-home-assistant-websocket并安装<br><img src=\"/images/ha/4/2.png\"><br>此时左边栏会出现home-assistant相关的节点，随便拉一个出来先<br><img src=\"/images/ha/4/3.png\"><br>然后鼠标左键编辑这个节点，会出现这个界面（因为我已经配置好才出现HomeAssistant），选择添加新的server节点并编辑。<br><img src=\"/images/ha/4/4.png\"><br>然后编辑好红框的信息，BaseUrl就是你的HA地址。<br><img src=\"/images/ha/4/5.png\"><br>Access Token在HA的这里获取，点击创建令牌，然后复制令牌到Access Token，并点击更新。<br><img src=\"/images/ha/4/6.png\"><br>最后请部署！请部署！请部署！全面在工作区部署所有内容！！！！！<br><img src=\"/images/ha/4/7.png\"><br>然后我们可以找到HA中的实体。<br><img src=\"/images/ha/4/8.png\"></p>\n<h2 id=\"4-HACS搜索nodered并下载，注意下载后要重启HA，然后在集成中安装\"><a href=\"#4-HACS搜索nodered并下载，注意下载后要重启HA，然后在集成中安装\" class=\"headerlink\" title=\"4.HACS搜索nodered并下载，注意下载后要重启HA，然后在集成中安装\"></a>4.HACS搜索nodered并下载，注意下载后要重启HA，然后在集成中安装</h2><h2 id=\"5-HA侧边栏加入nodered\"><a href=\"#5-HA侧边栏加入nodered\" class=\"headerlink\" title=\"5.HA侧边栏加入nodered\"></a>5.HA侧边栏加入nodered</h2><p>在configuration.yaml中填写以下信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">panel_iframe:</span><br><span class=\"line\"> nodered:</span><br><span class=\"line\">   title: &#x27;Node-Red&#x27;</span><br><span class=\"line\">   icon: &#x27;mdi:shuffle-variant&#x27;</span><br><span class=\"line\">   #填写node-red的地址</span><br><span class=\"line\">   url: &#x27;http://192.168.31.134:1880/&#x27;</span><br></pre></td></tr></table></figure>\n<p>全部安装配置大功告成！</p>\n<h2 id=\"6-初体验nodered\"><a href=\"#6-初体验nodered\" class=\"headerlink\" title=\"6.初体验nodered\"></a>6.初体验nodered</h2><p>现在我要创建一个自动化，当实时室外温度小于18°时，我的小爱音箱自动播报：天气冷了，记得加衣服。反之，如果大于等于18°，则播报：天气热了，记得脱衣服。<br>ps：需要安装好和风天气和小爱音箱<br>下面这是总览图<br>整体逻辑是首先检测到实体的状态，然后进行判断，最后做出相应动作<br><img src=\"/images/ha/4/9.jpg\"><br>室外温度状态设置，红框表示我设置的，其他地方是默认，因为图片太长，分两张上传<br><img src=\"/images/ha/4/10.jpg\"><br><img src=\"/images/ha/4/11.jpg\"><br>当前实体状态，可以用来作为判断条件，这里是写室外温度小于28度，注意这里还没进行判断<br><img src=\"/images/ha/4/12.jpg\"><br>那么是怎么判断的，我们看这个图，橙色小点写if state is true，我们上面那张图写的是温度小于28度，也就是当这个条件是成立的，那么就是true<br><img src=\"/images/ha/4/13.jpg\"><br>然后再看下面这个橙色点，写的是if state is false，对应成的话就是当温度不小于18度，这时候状态就是false，因为我们一开始设置的状态就是低于18度，所以你如果高于或者等于18度，这个状态就不成立了，不成立的意思就是false<br><img src=\"/images/ha/4/14.jpg\"><br>触发服务：这个是对应低于18度的服务，其中红框中的信息，你只要搜索相应字母就会显示出来（只要你配置好，他就会搜索到你HA中的信息），然后点击蓝色框框的load_example_data，绿色框框就会马上给你一个模板，然后输入对应信息即可，反之另外一个服务只需要复制一个，然后修改下对应数据即可<br><img src=\"/images/ha/4/15.jpg\"><br>最后把这几个服务拉起来连接，然后部署即可，这时候在HA中就会有这个实体！<br><img src=\"/images/ha/4/16.jpg\"></p>\n","categories":["HomeAassistant"]},{"title":"树莓派HomeAssistant系列（零）Docker安装","url":"/2022/01/01/%E6%A0%91%E8%8E%93%E6%B4%BEHomeAssistant%E7%B3%BB%E5%88%97%EF%BC%88%E9%9B%B6%EF%BC%89Docker%E5%AE%89%E8%A3%85/","content":"<p>HomeAassistant系列</p>\n<span id=\"more\"></span>\n<p>设备：树莓派4b 4G版本</p>\n<p>系统：官方32位界面系统</p>\n<p>HomeAssistant一句话介绍：all in one</p>\n<p>写这个系列的原因：利他思维，踩坑分析，没人看就当自己做笔记。</p>\n<p>废话少说，直接上代码！</p>\n<h1 id=\"1-安装Docker\"><a href=\"#1-安装Docker\" class=\"headerlink\" title=\"1.安装Docker\"></a>1.安装Docker</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class=\"line\">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"2-安装portainer2-x版本-可选，可视化管理Docker镜像太方便了\"><a href=\"#2-安装portainer2-x版本-可选，可视化管理Docker镜像太方便了\" class=\"headerlink\" title=\"2.安装portainer2.x版本(可选，可视化管理Docker镜像太方便了)\"></a>2.安装portainer2.x版本(可选，可视化管理Docker镜像太方便了)</h1><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name portainer portainer/portainer-ce</span><br><span class=\"line\">然后打开http://localhost:9000/即可。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3-安装HomeAssistant\"><a href=\"#3-安装HomeAssistant\" class=\"headerlink\" title=\"3.安装HomeAssistant\"></a>3.安装HomeAssistant</h1><p>需要注意，我创建了一个文件夹homeassistant，路径是&#x2F;home&#x2F;pi&#x2F;homeassistant，这里根据你的目录来修改即可。-v代表挂载文件，这是是为了方便修改镜像中的配置文件，然后我们就可以直接在宿主机上修改配置，不需要进入到容器里面。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  -p 8123:8123 \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">  -v /home/pi/homeassistant:/config \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n<p>然后打开<a href=\"http://localhost:8123/%E5%8D%B3%E5%8F%AF%E3%80%82\">http://localhost:8123/即可。</a></p>\n<h1 id=\"4-更新HomeAssistant\"><a href=\"#4-更新HomeAssistant\" class=\"headerlink\" title=\"4.更新HomeAssistant\"></a>4.更新HomeAssistant</h1><p>首先把最新的镜像下载完毕</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n<p>然后删除之前的旧镜像和旧容器（在portainer操作即可），再重新继续执行本文的3.安装HomeAssistant中的命令即可。</p>\n<h1 id=\"5-Other\"><a href=\"#5-Other\" class=\"headerlink\" title=\"5.Other\"></a>5.Other</h1><p>tips:这里还有个问题就是下载稍微比较慢，可以更新docker的下载源，我用的是网易的源，这里不再叙述，大家可以查资料怎么修改下载源。</p>\n<p>附上HomeAssistant手机客户端下载官方链接：</p>\n<p><a href=\"https://github.com/home-assistant/android/releases\">安卓APP下载地址</a></p>\n<p><a href=\"https://apps.apple.com/cn/app/home-assistant/id1099568401\">IOS下载地址</a></p>\n","categories":["HomeAassistant"]},{"title":"树莓派不吃灰行动","url":"/2021/12/27/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8D%E5%90%83%E7%81%B0%E8%A1%8C%E5%8A%A8/","content":"<p>别让你的树莓派吃灰！</p>\n<span id=\"more\"></span>\n\n<h1 id=\"1-开机自动发ip到邮箱\"><a href=\"#1-开机自动发ip到邮箱\" class=\"headerlink\" title=\"1.开机自动发ip到邮箱]()\"></a>1.开机自动发ip到邮箱]()</h1><h1 id=\"2-内网穿透\"><a href=\"#2-内网穿透\" class=\"headerlink\" title=\"2.内网穿透\"></a>2.内网穿透</h1><h1 id=\"3-Docker\"><a href=\"#3-Docker\" class=\"headerlink\" title=\"3.Docker\"></a>3.Docker</h1><h2 id=\"Docker安装\"><a href=\"#Docker安装\" class=\"headerlink\" title=\"Docker安装\"></a>Docker安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo curl -fsSL https://get.docker.com -o get-docker.sh</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo sh get-docker.sh</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"docker-compose安装\"><a href=\"#docker-compose安装\" class=\"headerlink\" title=\"docker-compose安装\"></a>docker-compose安装</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt-get update</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y python python-pip</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install libffi-dev</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pip3 install docker-compose -i https://pypi.mirrors.ustc.edu.cn/simple/  --trusted-host  pypi.mirrors.ustc.edu.cn</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"portainer安装-可视化管理镜像\"><a href=\"#portainer安装-可视化管理镜像\" class=\"headerlink\" title=\"portainer安装(可视化管理镜像)\"></a>portainer安装(可视化管理镜像)</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull portainer/portainer-ce</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock --restart=always --name portainer portainer/portainer-ce</span><br></pre></td></tr></table></figure>\n\n<p>更新portainer</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker stop portainer</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker rm portainer</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker pull portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"青龙面板\"><a href=\"#青龙面板\" class=\"headerlink\" title=\"青龙面板\"></a>青龙面板</h2><ol>\n<li></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -dit \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/config:/ql/config \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/log:/ql/log \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/db:/ql/db \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/repo:/ql/repo \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/raw:/ql/raw \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/scripts:/ql/scripts \\</span><br><span class=\"line\">-v /home/pi/qinglong/ql/jbot:/ql/jbot \\</span><br><span class=\"line\">-p 5700:5700 \\</span><br><span class=\"line\">--name qinglong \\</span><br><span class=\"line\">--hostname qinglong \\</span><br><span class=\"line\">--restart unless-stopped \\</span><br><span class=\"line\">whyour/qinglong:latest</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">直接拉库即可</span><br></pre></td></tr></table></figure>\n\n<p>3.<a href=\"https://plogin.m.jd.com/login/login?appid=828&returnurl=https://bean.m.jd.com/bean/signIndex.action\">京东获取cookie</a><br>4.环境变量设置JD_COOKIE<br>5.<a href=\"https://www.notion.so/1c598629675145988b43a37998a1604a\">教程合集</a></p>\n<h1 id=\"HomeAssistant-HA\"><a href=\"#HomeAssistant-HA\" class=\"headerlink\" title=\"HomeAssistant(HA)\"></a>HomeAssistant(HA)</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>使用docker进行安装，其中&#x2F;home&#x2F;pi&#x2F;home-assistant修改为您的路径 network设置为bridge</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  -p 8123:8123 \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">  -v /home/pi/home-assistant:/config \\</span><br><span class=\"line\">  --network=bridge \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d \\</span><br><span class=\"line\">  --name homeassistant \\</span><br><span class=\"line\">  -p 8123:8123 \\</span><br><span class=\"line\">  --privileged \\</span><br><span class=\"line\">  --restart=unless-stopped \\</span><br><span class=\"line\">  -e TZ=Asia/Shanghai \\</span><br><span class=\"line\">  -v /home/pi/homeassistant:/config \\</span><br><span class=\"line\">  --network=host \\</span><br><span class=\"line\">  ghcr.io/home-assistant/raspberrypi4-homeassistant:stable</span><br></pre></td></tr></table></figure>\n\n<p>vlc</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install vlc</span><br><span class=\"line\">vlc -I telnet --telnet-host 192.168.XX.XX --telnet-port 4212 --telnet-password XXXX</span><br></pre></td></tr></table></figure>\n\n<p>集成搜索VLC media player Telnet</p>\n<h2 id=\"内网穿透\"><a href=\"#内网穿透\" class=\"headerlink\" title=\"内网穿透\"></a>内网穿透</h2><p>直接用cpolar穿透会有问题，需要修改configuration.yaml，添加以下信息，其中172.17.0.1是docker中bridge的Gateway，在portainer中很容易能找到这个地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http:</span><br><span class=\"line\">  use_x_forwarded_for: true</span><br><span class=\"line\">  trusted_proxies:</span><br><span class=\"line\">    - 172.17.0.1</span><br></pre></td></tr></table></figure>\n\n<p>修改完毕后输入以下命令即可使用内网穿透，这样外网也能访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cpolar http 8123</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"文件管理\"><a href=\"#文件管理\" class=\"headerlink\" title=\"文件管理\"></a>文件管理</h2><p>发现一个不错的文件管理插件,<a href=\"https://github.com/shaonianzhentan/ha_file_explorer\">下载地址</a>.<br>把里面的ha_file_explorer-master\\custom_components\\ha_file_explorer中的这个文件夹移到HA的custom_components中，重启HA，然后<a href=\"https://my.home-assistant.io/redirect/config_flow_start/?domain=ha_file_explorer\">点击此链接配置</a></p>\n<h2 id=\"更换主题\"><a href=\"#更换主题\" class=\"headerlink\" title=\"更换主题\"></a>更换主题</h2><p>更换主题和更换UI前提需要安装HomeAssistant的HACS，HACS有主题和UI下载，下载主题完毕后修改configuration.yaml，添加以下信息后重启HA</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">frontend:</span><br><span class=\"line\">  themes: !include_dir_merge_named themes</span><br></pre></td></tr></table></figure>\n\n<p>重启完毕后在左下角选择用户资料，也就是通知下面那个栏目，右边有主题选择，此时会出现你下载你主题。</p>\n<h2 id=\"更换Lovelace\"><a href=\"#更换Lovelace\" class=\"headerlink\" title=\"更换Lovelace\"></a>更换Lovelace</h2><p>下载完毕后，编辑卡片，选择代码编辑器，默认为type: entities，此时你只需要查看你新的Lovelace名字，比如custom:mini-graph-card，把entities改成这个名字就可以了，更多设置请查看该Lovelace的文档。</p>\n<h2 id=\"nodered\"><a href=\"#nodered\" class=\"headerlink\" title=\"nodered\"></a>nodered</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -it -p 1880:1880 --name=nodered --restart=always --user=root --net=host -v /data/nodered:/data -e TZ=Asia/Shanghai nodered/node-red</span><br></pre></td></tr></table></figure>","categories":["捣鼓树莓派"]},{"title":"生产力工具和科研网址合集","url":"/2020/07/07/%E7%A7%91%E7%A0%94--%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7%E5%8F%8A%E7%BD%91%E5%9D%80/","content":"<h1>生产力工具</h1>\n<span id=\"more\"></span> \n\n<p><a href=\"http://www.gjw123.com/\">小工具合集</a>——各种在线小工具<br>notability——笔记软件<br>researcher——学术期刊文献阅读<br>zetero——论文管理<br>天若OCR——OCR识别工具<br>overleaf——Latex编辑工具<br><a href=\"https://app.grammarly.com/\">grammarly</a>——语法纠错<br><a href=\"https://quillbot.com/\">润色平台</a><br>知云文献翻译——论文翻译<br>SciencePlots——论文绘图<br><a href=\"https://hiplot.com.cn/basic\">hiplot</a>——论文绘图<br>Arxiv——最新科研动态，可用微信小程序Arxiv Express<br><a href=\"https://convertio.co/zh/\">文件转换神器</a><br><a href=\"https://www.deepl.com/translator\">DeepL翻译</a></p>\n<h1>科研网址</h1>\n\n<p><a href=\"http://9312.net/\">镜像网站</a>——科研干货导航<br><a href=\"https://scholar.chongbuluo.com/\">虫部落</a>——学术搜索合集<br><a href=\"https://xueshu.baidu.com/\">百度学术</a>——论文查询<br><a href=\"https://scholar.google.com/\">谷歌学术</a>——论文查询(需要VPN，或可用镜像网站打开)<br><a href=\"https://www.x-mol.com/\">x-mol</a>——学术期刊，行业资讯，导师信息<br><a href=\"http://www.sci-hub.ren/\">sci-hub</a>——打破科学障碍，免费论文下载<br><a href=\"https://www.scimagoir.com/\">排名神器</a></p>\n","categories":["研究生阶段--科研工具，科研网址及科研记录"],"tags":["科研"]},{"title":"树莓派到手","url":"/2020/03/20/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%B0%E6%89%8B/","content":"<p>考研前就打算买的树莓派，一直等到前几天才下单购买，今天终于到手了。<br>配置：树莓派4代4b  RAM：4GB<br>风扇安装：红色是正极，黑色是负极。引脚4接红线，引脚6接黑线。<br><img src=\"/images/pi/pin.png\" alt=\"pin\"><br><img src=\"/images/pi/pi.jpg\" alt=\"树莓派全家福\">\n </p>\n","categories":["捣鼓树莓派测试"],"tags":["树莓派"]},{"title":"记录第一次HomeAssistant开发插件的历程","url":"/2022/02/11/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1HomeAssistant%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%86%E7%A8%8B/","content":"<p><a href=\"https://github.com/chenwingsing/ha_face_detect\">插件地址</a></p>\n<span id=\"more\"></span>\n<p>其实已经有不少人用百度的接口来做人脸识别，但是看了一圈，没有我想要的效果，于是看了一些插件的写法就入手了。</p>\n<p>在开发的过程中遇到一些令人难忘的坑，接下来一一道来。</p>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h3><p>总体结构写完后，马上在自己的HA测试，一直没有效果，因为是用docker下运行的，所以又重新新建了一个空的HA进行测试，发现有信息显示，但是之前的HA一直没有效果，反反复复试了好多次，一直排查不出来是为什么。</p>\n<p>就这样测试了一天，还是没有效果，刚好遇上HA更新了，就重新更新下HA并安装，这下好了，两个docker都无法使用了。</p>\n<p>这时候突然想起来，把计算机运行的东西打印出来，就这样一个个像断点测试一样，打印出日志，每个地方排除错误，终于最后让我发现问题所在了，原因在baidu-aip这个包的版本问题，因为我用的接口是需要最新版本的，而开发HA插件中有一个manifest.json这个文件可以指定包的版本，而我因为是第一次开发，照着别人的代码进行改，刚好那个人没写这些，所以系统会自动帮我安装一个版本，所以，最后再这个文件中指定了版本，问题也就解决了。</p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>除了这个问题，在开发中还碰到一个偶然发生的Bug，重启初始化的时候，会有某个实体不可用，这个问题排查了好久，一直不知道哪里有问题，后来一直更改配置，发现代码是没有问题的，然后反复测试，直觉告诉我，实体的启动顺序有点问题，也就是本来是第一个启动的，却一直没有成功，然后导致不可用，那么我的想法是会不会启动太快了，然后我在关键部分加了个sleep缓冲了一下，果然问题解决了。</p>\n<h3 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h3><p>因为我是用了两个接口，需要返回两个结果，如果识别不到信息，某个接口可能会返回None，一般来说，这种可能发生异常的情况都在try,catch中完成，在代码结构中，我往往先用res1来接收第一个接口的结果，然后res2接收第二个接口的结果，在某次测试中发现，有个结果一直不出来，于是又用断点思路进行排查，把日志打印出来一个个看，发现了一个问题，如果第一个res没有结果，那么在try中你用res2是无效的，是没有办法接收到第二个接口的结果，所以最后我的解决方法是，对他们的接收过程进行一个排序，永远有结果的先接收，然后可能会返回没有结果的排在后面。</p>\n<h3 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h3><p>这个部分主要讲一些用户的体验，插件的本质是抓取每一秒的图片然后返回百度进行识别，也就是每次识别百度都会返回一个结果，在初始的时候插件是显示“未知”，有识别的时候会替换成相关信息，这里就有个问题是，插件如果返回None，要不要保留上一个用户的信息，还是说替换成”未知”，因为插件是每一刻都在运行，相当于每一秒就收到一个结果，思考了一下后，我觉得要一直保留上一次的人脸信息，直到有新的人脸信息，才进行刷新，而不会刷新成”未知”，因为这样会导致没有感知。当然，有一个实体例外，就是人脸识别这个，如果返回None，就会刷新成无，因为这个实体是返回真人名字，所以如果你一直保留直到下一个新名字出现才刷新的话，会有一种违和感，因为陌生人的信息是没有在百度中，所以会返回None，要是一直保留这个人脸信息，当我们需要识别陌生人的时候，而人脸识别还是显示上一个人的信息就很怪异，所以这个实体我是根据每次识别返回该有的信息进行展示。</p>\n<p>最后一句结束语，真-智能家居离我们还有多远？</p>\n"},{"title":"考研回顾","url":"/2020/05/28/%E8%80%83%E7%A0%94%E5%9B%9E%E9%A1%BE/","content":"<p>2020年5月19号下午6点08分，拟录取名单出来，用浏览器的查找功能快速定位到了自己的名字。历时400多天的考研正式拉下帷幕，心情略有激动，但是马上平复下来。</p>\n<p>2019年2月25号这天，是大三下学期开学的第一天，也就是在这一天，正式开始考研历程。早早买了书，目标并没有定的太高，本地区，本专业，本校，也算是考研难度中最小的。事实也证明，考研务必要选择合适自己的学校，不能好高骛远，考研形势越来越严峻，计算机行业更是处于水深火热中，无数人想涌进来，2019年计算机专业在很多学校报考人数出现“爆炸”的情况，所以当时猜到2020的情况只会更加糟糕。考完后从老师那里了解到，有800多人报我这个专业，在疫情扩招前，只录取79人，比江湖上传闻考研只有25%上岸的比例还要更低。</p>\n<p>为什么要选择考研？这个问题通常和上班结合，所以会经常看到有人问，上班三年获得社会经验值得还是去读研三年更值得？对于我来说，一定是考研。我一直都认为，教育一定是最好的投资。尤其现在疫情的情况之下，企业的基本盘关乎着能不能撑得过这场疫情，疫情让很多企业破产，倒闭，只有基本盘稳固的企业才能渡过这次疫情，对于个人而言，你的能力和学历就是基本盘，但是你可能还会听到这么一句话：你研究生出来还不是给我一个大专生打工。不否认有这种人存在，但是你别老盯着这种人，这叫幸存者偏差。读研本身不止是对你所学专业的更深入了解，更重要的是改变你的思维方式，而所谓工作三年，你完全可以读研之后去获得，而那些早早去工作的人可能会有自身的天花板。尤其对于互联网行业来说，你的老板只是希望你能漂亮完成当前工作，而你很可能麻木，没有继续学习，对于计算机行业来说，快速迭代及时更新自己才是王道。</p>\n<p>考研真的好累，每天过着三点一线的生活，而且大三还有课，有课就去上课，上课也是看着考研的东西，没课就早早去图书馆占位子，开始一天的学习生活。每天过着重复的生活，晚上等着图书馆关门才走。每天最舒服的时候是从图书馆回宿舍那段路，听着歌，看着一路上的风景，慢慢回到宿舍。</p>\n<p>这一年也没有回家，暑假留在学校泡图书馆，天津的夏天很热，印象中没有一天是自然醒的，中午也是躺着睡不着，深入睡眠的时间少之又少。考研除了考察学习能力，心理和生理压力也不少，从不熬夜的我也有了黑眼圈。</p>\n<p><img src=\"/images/university/2.jpg\" alt=\"考试前一天晚上的图书馆\"></p>\n<center><font size=\"2\">考试前一天晚上的图书馆</font></center>\n\n<p>初试那天，心情有点紧张，到了下午第二科英语的时候，已经发现有些人不参加考试了，坐在我前面的那个就放弃了，很难理解。第二天考完结束，心情慢慢放松下来，洗了个澡，收拾好考研的书，笔记。</p>\n<p>最难熬的除了备考过程，还有复试过程，由于疫情的影响，本来2月10号查询成绩改到了20号中午12点，20号的前一晚，醒了几次，加了个天津等成绩群，大家都在等着成绩。在20号那天早上10点，天津教育局的网提前公布了成绩，很忐忑输入自己的信息，输完验证码后点击查看。成绩还行，按照往年来说肯定能录取。到了12点，跑去研招网查询，成绩无误，但是多了个排名在备注-101，要知道，今年才招79个，以往我们学校一志愿都不满，今年就爆炸了，和我预料一样，考研开始严峻起来，79个人按照1.2的比例进复试大概是95人，我只能祈求在我前面的人有单科不过线。开始默默复习复试的内容。没过多久，教育部宣布今年扩招18.9万人，我考的专业也在重点扩招范围，这时候开始有了信心。再慢慢过了一两周，每个省份开始陆续公布扩招人数，3月9号，天津宣布扩招2537人，增长22.9%，对于我来说更加充满信心，但是，这2000多人我能不能占一个位置，毕竟天津的高校也不少，大家分起来后每个大学其实并没有多少人。每个大学还要对每个专业分名额，所以还是多多少少有点担心。再过几周，开始有小道消息，有人打电话问学校说能分500多人，但是如果按照整个市才2000多人的规模，一个学校能分500多人似乎不太可信。终于到了4月15号，学校确认这个消息，加上我这个专业是热门专业，肯定能分不少，这时候才安心下来。最后到了5月初，学院正式宣布招收139人，这个扩招幅度已经很不可思议了，于是每天都准备复试的内容。</p>\n<p>5月16号正式复试，这是头一回举行网络复试，没有人有经验，只能冲上去，排在5号的我早早开始等待，中间还发生一个小插曲，3号的复试时间不到2分钟就切换到4号，顿时开始紧张起来，喝了口水，等待老师接通我，复试整个过程20分钟，但是感觉很快就结束了，至此，整个考研只剩下等待录取名单。</p>\n<p>有人这么比喻考研，考研就好像在一个黑房间里洗衣服，你不知道洗得干不干净，你只能一遍又一遍去洗，一直到开灯那一刻，你才知道衣服干不干净。高考是一群人战斗，而考研你只能一个人战斗，考研并不是必须要去做的事，因为你是成年人了，你可以选择考研，也可以选择不考，但是，你选择了考研，就必须坚持下去，直到开灯那一刻。<br><img src=\"/images/university/1.jpg\" alt=\"回图书馆路上\"></p>\n","categories":["大学"],"tags":["考研回忆"]},{"title":"树莓派dashboard","url":"/2020/03/20/%E6%A0%91%E8%8E%93%E6%B4%BEdashboard/","content":"<p>折腾了一下午，总算把nginx+php（dashboard要用到）装好了，推荐更换国内源，这样安装软件更加快速。远程桌面用window自带的挺方便，不用桌面的话先打开SSH然后用putty登录。<br>Dashboard一个特别不错的开源项目，可以查看pi的温度，内存各种运行情况，强烈推荐使用。<br>把项目放在nginx的html目录下即可。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install git</span><br><span class=\"line\">cd /etc/nginx/html</span><br><span class=\"line\">sudo git clone https://github.com/nxez/pi-dashboard.git</span><br><span class=\"line\">sudo chown -R  pi-dashboard</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/pi/dashboard.png\" alt=\"dashboard\"></p>\n","categories":["捣鼓树莓派"],"tags":["dishboard"]}]