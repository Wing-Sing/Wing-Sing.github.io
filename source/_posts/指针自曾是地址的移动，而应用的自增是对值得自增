指针自曾是地址的移动，而应用的自增是对值得自增

若有定义；int a[8];，则以下表达式中不能代表数组元素a[1]的地址的是&a[0]++（注意是不能，也就是这个是错误的）ps：&a[0]+1表示元素a[0]的地址加1，也就是a[1]的地址;&a[1]当然表示元素a[1]的地址；a+1表示数组a的首地址（即a[0]的地址）加1，也是a[1]的地址;而&a[0]++包含有对&a[0]的赋值运算，本身是非法的。所以选择答案是C。
选项分别为：&a[0]+1 &a[1] &a[0]++（这个错误，其他正确） a+1

&可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作。
&&是表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true
C/C++ &与&& |与|| 的区别：
&&
表示逻辑与的意思，即为and。当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
比如 12&&23的结果就是1，12&&-1 的结果是1，123&&0的结果就是0
&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException
&
表示按位与。
&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。
二进制与运算规则:1&1=1  1&0=0  0&0=0
15&127为什么等于15啊？ 
 
15二进制： （0000 1111）
 
127二进制： （1111 1111）
 
按位与自然就是（0000 1111）＝15
 
  
 
||
 
表示逻辑或
 
 逻辑或，是逻辑运算符，符号是“||”(在PASCAL中为"or")。 “逻辑或”相当于生活中的“或者”，当两个条件中有任一个条件满足，“逻辑或”的运算结果就为“真”
 
12||1 =1  12||0 =1 0||0 =0
 
  
 
|
 
表示按位或
 
按位或运算 按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位（也就是最后一位）相或。只要对应的二个二进位有一个为1时，结果位就为1。
 
128：     （0001 0000 0000）
 
127：     （0000 1111 1111） （高位用0补齐）
 
按位或就是（0001 1111 1111）＝255



定义一个int类型的指针数组，数组元素个数为10个  int *a[10
解释：
A int a[10] 为int类型的数组;
B int (*a)[10]为int类型的数组的指针
C int *a[10]为int类型的指针的数组
D int (*a[10])(int)为函数指针的数组，[]有限级高于*，说明a是一个数组，数组元素的类型为函数指针
第二种解释
A:一个长度为10的数组，数组内部放着10个int数据
C：一个长度为10的数组，数组内部放着10个int*数据，就是A中数组内部存储的不是数据而是指针就是地址
B：a是指向一个长度为10的数组整体的指针，a的指针步长就是这个数组的长度
D:首先 *a[10]为一个和C一样的数组里面存储了10个指针数据，只是这里的这些指针数据是一个返回值为int,参数为int的的函数的入口地址，总共是10个函数的地址存储在数组中

友元函数不属于类，因此没有this指针


声明枚举变量三种方法
1、先声明枚举类型后定义枚举类型变量
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat  
};  
enum WeekdayType today,yesterday,tomorrow;
2、声明枚举类型的同时定义枚举类型变量
enum WeekdayType  
{  
    sun,mou,tue,wed,thu,fri,sat   
}today,yesterday,tomorrow;
3、直接定义枚举类型变量
enum  
{  
    sun,mou,tue,wed,thu,fri,sat  
}today,yesterday,tomorrow;



下面这个程序执行后会有什么错误或者效果:

#define MAX 255
int main()
{
     unsigned char A[MAX], i;
     for (i = 0; i <= MAX; i++)
         A[i] = i;
}
看看有什么错误？ 这个问题错误很隐蔽。。。
这个问题能将面试者的能力分为三类；
一：没错。。。那么说明面试者的C语言基础能力不行；
二：有个错，是哪个i<=MAX; 数组下标越界。。嗯，还行；
三：死循环，C的基本功很强。。达到了该题的测试目的；

分析了一下： 
出现了两个问题; 
一：下标越界可以说是个问题，但不是问题的本质； 当i=MAX；即i=MAX是，对数组来说，255是越界了，那如果我把数组下标改了是不是就对了呢？比如说如下：
#include <stdio.h>
#define MAX 255
int main() { 
unsigned char a[256],i;//这里改成256是不是就对了呢？ 还是不对；
for(i=0;i< =MAX;i++)
a[i]=i;
for(i=0;i< =MAX;i++) 
printf("%d ",a[i]); 
}   
其实越界了编译还是能通过的，因为编译器不检查越界问题；

问题二： 上例还是错的，原因在于unsigned char 这个数据类型，它占了 8位，表示范围是 0~255（00000000~11111111，八位）； 当改成256后，虽说看似数组下标没越界，但是当i=255; i++ ；因为 i本身是unsigned char类型，占8位，所以此时i+1变成了100000000 9位，又因为i只能占8位，所以舍掉了最高位，此时的i值又变成00000000了，即就是0；然后就成了死循环了。。