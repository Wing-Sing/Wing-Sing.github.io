---
title: MySql笔记
date: 2022-04-14 15:21:22
tags: [MySql]
categories: "学习笔记"
---
记录极客时间《MySql实战45讲》中的一些笔记。
<!--more--> 
![MySql的逻辑架构图](/images/mysql/logic.jpg)
MySql的逻辑架构图
# 第一讲
1.当一个表进行更新的时候，跟这个表有关的查询缓存就会失效。
2.mysql占用内存快，可以定期断开长连接，这样资源可以释放出来，或者每次进行一个大操作后，通过执行mysql_reset_connection来重新初始化资源。
# 第二讲
3.redo log（重做日志）是InnoDB（Mysql引擎之一）特有的，binlog（归档日志）是Server层的，任何引擎都能用。
4.redo log是物理日志，binlog是逻辑日志。
5.redo log是循环写的，会覆盖。binlog是可以追加写入，不会覆盖。
6.两阶段提交可以保证数据恢复是逻辑的一样的。
本讲问题：在什么场景下，一天一备会比一周一备更有优势，或者说，它影响了这个数据库系统的哪个指标？
# 第三讲
7.事务具有原子性，一致性，隔离性，持久性。
8.SQL标准事务隔离级别：读未提交，读提交，可重复读，串行化。
9.当数据库多个事务同时执行时，可能出现脏读，不可重复读，幻读的问题。
10.尽量不要使用长事务，不然占用资源，最终拖垮整个库。误用长事务具体看第三讲。
本讲问题：你是数据库负责人，你会怎么避免或者处理长事务这种情况？
# 第四讲
11.索引分为主键索引和普通索引，在应用中应该尽量使用主键查询。
12.InnoDB选择用B+树结构，可以配合磁盘的读写特性，减少单次查询磁盘访问的次数。
13.本讲最后是如何避免长事务对业务的影响。
本讲问题：对于上面例题的两个重建索引的作法，说出你的理解，或者你觉得有什么不合适的吗？
# 第五讲
14.数据库索引的概念包括：覆盖索引，前缀索引，索引下推。其中覆盖索引可以减少树的搜索次数，显著提示查询性能，是一个常用的优化手段。
15.满足语句需求的情况下，尽量少访问资源是数据库设计的重要原则之一。
16.建立联合索引时，如何安排索引内的字段顺序，第一原则是如果通过调整顺序可以少维护一个索引，那么这个顺序是优先考虑的。
本讲问题：这个例题，两个索引都是否是必须的，为什么？
# 第六讲
17.MySql的锁大致分为全局锁，表级锁，行锁三类。
18.表级锁又分为：表锁，元数据锁。
19.全局锁主要用在逻辑备份过程中，表锁一般是在数据库引擎不支持行锁的时候才会被用到。
20.MDL（元数据锁）会直到事务提交才释放，在做表结构变更的时候，一定小心不要导致锁住线上查询和更新。
21.DML:增修改数据 DDL：修改表结构
本讲问题：备份一般在备库上进行，你在用-single-transaction方法做逻辑备份的过程中，如果主库上一个小表做了一个DDL，这时候从备库上会看到什么现象。
# 第七讲
22.InnoDB支持行锁，MyISAM不支持，不支持行锁，一个表任何一个时刻只能由一个更新进行，会影响业务并发度。
23.两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不是需要了就立刻释放，而是要等到事务结束时才释放。
24.如果你的事务中需要锁多个行，要把最可能造成锁冲突，最可能影响并发度的锁尽量往后面放。
25.发生死锁的解决方案：1.直接进入等待，直到超时。2.主动发起死锁检测。
26.死锁检测在热点行更新会导致利用大量资源的解决方法：1.临时把死锁检测关掉，但是有风险。2.控制并发度，但是如果客户端很多，也是很耗资源，所以并发控制可以在数据库服务端做，可以考虑用中间件实现，或者有大牛修改MySQL源码，总之基本思路是：对于相同行的更新，在进入引擎之前排队。如果没有大牛，可以将一行改成多行的逻辑，比如电影院的账户总额等于10个记录的值，每次随机给一条记录添加，这样冲突的概率为1/10，但是你还要考虑如果有人发生退票，一部分记录会变成0，你要对代码有特殊处理。
本讲问题：关于删除表前面1000行数据，这三个方法你选择哪个，为什么？
# 第八讲
这篇文章需要好好消化，举例了一个具体的操作，关于事务隔离时候的情况。
27.InnoDB的行数据有多个版本，每个数据版本都有自己的row trx_id，每个事务或者语句有自己的一致性视图。
28.普通查询语句是一致性读，一致性读会根据row trx_id和一致性视图确定数据版本的可见性。
29.对于可重复读，查询只承认在事务启动前就已经提交完成的数据。
30.对于读提交，查询只承认在语句启动前就已经提交完成的数据。
31.而当前读，总是读取已经提交完成的最新版本。
32.MySQL中，有两个视图的概念，1.一个是view,它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是create view...，而他的查询方法与表一样。2.另一个是InnoDB在实现MVCC时用到的一致性读视图即consistent read view用于支持RC（read committed，读提交）和RR（repeatable read，可重复读）隔离级别的实现。
33.更新数据都是先读后写的，而这个读，只能读当前的值，称为当前读（current read）。
本讲问题：一个具体的业务操作出现的问题，具体看原文。
# 第九讲
34.身份证号字段比较大，不建议直接当主键，可以当唯一索引，因为这个业务代码上保证了不会写入重复的身份证号。
35.普通索引和唯一索引其实性能上差距不大，但是他们对更新语句性能有影响，但是非常小，只是在于一个判断。
36.change buffer只限于在普通索引下，不太适合唯一索引。
37.redo log主要是节省随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省随机读磁盘的IO消耗。
本讲问题：change buffer一开始是写内存，如果这个时候机器掉电重启，会不会导致change buffer丢失？
# 第十讲
38.优化器选择索引的目的是为了找到一个最优的方案，但是有时候会判断错误从而选错索引。
39.如何让优化器真正选择好的索引：1.我们可以采用force index强行选择一个索引。2.或者修改语句，引导MySql使用我们期待的索引。3.在有些场景下，可以新建一个更合适的索引，或者删掉误用的索引。
本讲问题：具体看文章，是本文例子的扩展问题。
