<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://unpkg.com/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"chenwingsing.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":true,"version":"8.14.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.json","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="按照《Leetcode101-A Leetcode Gringding Guide》顺序记录。除此之外，开始正视代码书写规范。">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode-JAVA">
<meta property="og:url" content="https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/index.html">
<meta property="og:site_name" content="小陈同学">
<meta property="og:description" content="按照《Leetcode101-A Leetcode Gringding Guide》顺序记录。除此之外，开始正视代码书写规范。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/4.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/4-4.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/5-4-1.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/5-4-2.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/5-5.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/221.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/139.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/300.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/1143-1.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/1143-2.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/bag-1.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/bag-2.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/bag-3.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/bag-4.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/bag-5.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/72.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/c-59.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/24.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/c-24.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/c-02.07.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/kmp.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/452.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/139.jpg">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/84.png">
<meta property="og:image" content="https://chenwingsing.github.io/images/leetcode-java/148.png">
<meta property="article:published_time" content="2021-09-20T02:48:01.000Z">
<meta property="article:modified_time" content="2022-10-26T01:10:38.000Z">
<meta property="article:author" content="小陈同学">
<meta property="article:tag" content="Leetcode">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenwingsing.github.io/images/leetcode-java/4.jpg">


<link rel="canonical" href="https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/","path":"2021/09/20/LeetCode-JAVA/","title":"LeetCode-JAVA"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode-JAVA | 小陈同学</title>
  






  <script async defer data-website-id="" src=""></script>

  <script defer data-domain="" src=""></script>

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="小陈同学" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">小陈同学</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#ACM%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0"><span class="nav-number">1.</span> <span class="nav-text">ACM模式练习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-A-B-I"><span class="nav-number">1.1.</span> <span class="nav-text">1.A+B I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-A-B-II"><span class="nav-number">1.2.</span> <span class="nav-text">2.A+B II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-A-B-III"><span class="nav-number">1.3.</span> <span class="nav-text">3.A+B III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AE%A1%E7%AE%97%E4%B8%80%E7%B3%BB%E5%88%97%E6%95%B0%E7%9A%84%E5%92%8C-I"><span class="nav-number">1.4.</span> <span class="nav-text">4.计算一系列数的和 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%AE%A1%E7%AE%97%E4%B8%80%E7%B3%BB%E5%88%97%E6%95%B0%E7%9A%84%E5%92%8C-II"><span class="nav-number">1.5.</span> <span class="nav-text">5.计算一系列数的和 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E8%AE%A1%E7%AE%97%E4%B8%80%E7%B3%BB%E5%88%97%E6%95%B0%E7%9A%84%E5%92%8C-III"><span class="nav-number">1.6.</span> <span class="nav-text">6.计算一系列数的和 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E8%AE%A1%E7%AE%97%E4%B8%80%E7%B3%BB%E5%88%97%E6%95%B0%E7%9A%84%E5%92%8C-IV"><span class="nav-number">1.7.</span> <span class="nav-text">7.计算一系列数的和 IV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F-I"><span class="nav-number">1.8.</span> <span class="nav-text">8.字符串排序 I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F-II"><span class="nav-number">1.9.</span> <span class="nav-text">9.字符串排序 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F-III"><span class="nav-number">1.10.</span> <span class="nav-text">10.字符串排序 III</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-A-B-IV"><span class="nav-number">1.11.</span> <span class="nav-text">11.A+B IV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#360%E4%B8%80%E9%81%93%E9%A2%98-acm"><span class="nav-number">1.12.</span> <span class="nav-text">360一道题 acm</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACM-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BE%93%E5%85%A5-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.13.</span> <span class="nav-text">ACM 二叉树输入 前序遍历为例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACM-%E9%93%BE%E8%A1%A8-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E4%B8%BA%E4%BE%8B"><span class="nav-number">1.14.</span> <span class="nav-text">ACM 链表 反转链表为例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#445-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-easy"><span class="nav-number">2.1.</span> <span class="nav-text">445 分发饼干 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-hard"><span class="nav-number">2.2.</span> <span class="nav-text">135 分发糖果 hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-medium-%E5%8F%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.3.</span> <span class="nav-text">435 无重叠区间 medium(可动态规划)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98-easy"><span class="nav-number">2.4.</span> <span class="nav-text">605 种花问题 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-medium-%E5%92%8C435%E7%9B%B8%E4%BC%BC"><span class="nav-number">2.5.</span> <span class="nav-text">452 用最少数量的箭引爆气球 medium(和435相似)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium"><span class="nav-number">2.6.</span> <span class="nav-text">763 划分字母区间 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2-easy-%E5%8F%AF%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.7.</span> <span class="nav-text">122 买卖股票的最佳时机2 easy(可动态规划)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-medium"><span class="nav-number">2.8.</span> <span class="nav-text">406 根据身高重建队列 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#665-%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97-easy"><span class="nav-number">2.9.</span> <span class="nav-text">665 非递减数列 easy</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="nav-number">3.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#167-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C2-easy"><span class="nav-number">3.1.</span> <span class="nav-text">167 两数之和2 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-easy"><span class="nav-number">3.2.</span> <span class="nav-text">88 合并两个有序数组 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A82-medium"><span class="nav-number">3.3.</span> <span class="nav-text">142 环形链表2 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-hard"><span class="nav-number">3.4.</span> <span class="nav-text">76 最小覆盖子串 hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="nav-number">3.5.</span> <span class="nav-text">633 平方数之和 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#680-%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B22-easy"><span class="nav-number">3.6.</span> <span class="nav-text">680 验证回文字符串2 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#524-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D-medium"><span class="nav-number">3.7.</span> <span class="nav-text">524 通过删除字母匹配到字典里最长单词 medium</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">4.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#69-Sqrt-x-easy"><span class="nav-number">4.1.</span> <span class="nav-text">69 Sqrt(x) easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-medium"><span class="nav-number">4.2.</span> <span class="nav-text">34 在排序数组中查找元素的第一个和最后一个位置 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II-medium"><span class="nav-number">4.3.</span> <span class="nav-text">81 搜索旋转排序数组 II medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-II-hard"><span class="nav-number">4.4.</span> <span class="nav-text">154 寻找旋转排序数组中的最小值 II hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#540-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0-meidum"><span class="nav-number">4.5.</span> <span class="nav-text">540. 有序数组中的单一元素 meidum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-hard"><span class="nav-number">4.6.</span> <span class="nav-text">4 寻找两个正序数组的中位数 hard</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">常用排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">5.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">5.3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.4.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">5.5.</span> <span class="nav-text">冒泡排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0-medium"><span class="nav-number">5.6.</span> <span class="nav-text">215 数组中的第K个最大元素 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#347-%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-%E6%A1%B6%E6%8E%92%E5%BA%8F-medium"><span class="nav-number">5.7.</span> <span class="nav-text">347 前K个高频元素(桶排序) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#451-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-medium"><span class="nav-number">5.8.</span> <span class="nav-text">451 根据字符出现频率排序(桶排序) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-medium"><span class="nav-number">5.9.</span> <span class="nav-text">75 颜色分类 medium</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E5%88%87%E7%9A%86%E5%8F%AF%E6%90%9C%E7%B4%A2"><span class="nav-number">6.</span> <span class="nav-text">一切皆可搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-DFS-medium"><span class="nav-number">6.1.</span> <span class="nav-text">695 岛屿的最大面积(DFS) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F-DFS-medium"><span class="nav-number">6.2.</span> <span class="nav-text">547 省份数量(DFS) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98-DFS-medium"><span class="nav-number">6.3.</span> <span class="nav-text">!417 太平洋大西洋水流问题(DFS) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%9E%E6%BA%AF%E6%B3%95-medium"><span class="nav-number">6.4.</span> <span class="nav-text">46 全排列(回溯法) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88-%E5%9B%9E%E6%BA%AF%E6%B3%95-medium"><span class="nav-number">6.5.</span> <span class="nav-text">77 组合(回溯法) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2-%E5%9B%9E%E6%BA%AF%E6%B3%95-medium"><span class="nav-number">6.6.</span> <span class="nav-text">79 单词搜索(回溯法) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-N%E7%9A%87%E5%90%8E-%E5%9B%9E%E6%BA%AF%E6%B3%95-hard"><span class="nav-number">6.7.</span> <span class="nav-text">51 N皇后(回溯法) hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#934-%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5-DFS-BFS-medium"><span class="nav-number">6.8.</span> <span class="nav-text">934 最短的桥(DFS+BFS) medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#126-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%992-%E5%9B%9E%E6%BA%AF-BFS-hard"><span class="nav-number">6.9.</span> <span class="nav-text">126 单词接龙2(回溯+BFS) hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#130-%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F-medium"><span class="nav-number">6.10.</span> <span class="nav-text">130 被围绕的区域 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy"><span class="nav-number">6.11.</span> <span class="nav-text">257 二叉树的所有路径 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%972-medium"><span class="nav-number">6.12.</span> <span class="nav-text">47 全排列2 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-medium"><span class="nav-number">6.13.</span> <span class="nav-text">40 组合总和 II medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E8%A7%A3%E6%95%B0%E7%8B%AC-hard-%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="nav-number">6.14.</span> <span class="nav-text">37 解数独 hard 未完成</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#310-%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91-medium-%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="nav-number">6.15.</span> <span class="nav-text">310 最小高度树 medium 未完成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">7.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="nav-number">7.1.</span> <span class="nav-text">70 爬楼梯 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium"><span class="nav-number">7.2.</span> <span class="nav-text">198 打家劫舍 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#413-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86-medium"><span class="nav-number">7.3.</span> <span class="nav-text">413 等差数列划分 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-medium"><span class="nav-number">7.4.</span> <span class="nav-text">64 最小路径和 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#542-01%E7%9F%A9%E9%98%B5-medium"><span class="nav-number">7.5.</span> <span class="nav-text">542 01矩阵 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2-medium"><span class="nav-number">7.6.</span> <span class="nav-text">221 最大正方形 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium"><span class="nav-number">7.7.</span> <span class="nav-text">279 完全平方数 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95-medium"><span class="nav-number">7.8.</span> <span class="nav-text">91 解码方法 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium"><span class="nav-number">7.9.</span> <span class="nav-text">139 单词拆分 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="nav-number">7.10.</span> <span class="nav-text">300 最长递增子序列 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="nav-number">7.11.</span> <span class="nav-text">1143 最长公共子序列 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-medium%EF%BC%880-1%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">7.12.</span> <span class="nav-text">416 分割等和子集 medium（0-1背包）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%85%A8%E7%90%86%E8%A7%A3"><span class="nav-number">7.12.1.</span> <span class="nav-text">背包问题全理解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#474-%E4%B8%80%E5%92%8C%E9%9B%B6-medium-%EF%BC%880-1%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">7.13.</span> <span class="nav-text">474 一和零 medium （0-1背包）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium%EF%BC%88%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%EF%BC%89"><span class="nav-number">7.14.</span> <span class="nav-text">322 零钱兑换 medium（完全背包）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-hard"><span class="nav-number">7.15.</span> <span class="nav-text">72 编辑距离 hard</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#650-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98-medium"><span class="nav-number">7.16.</span> <span class="nav-text">650 只有两个键的键盘 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-hard-%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="nav-number">7.17.</span> <span class="nav-text">10 正则表达式匹配 hard(未完成)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy"><span class="nav-number">7.18.</span> <span class="nav-text">121 买卖股票的最佳时机 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="nav-number">7.19.</span> <span class="nav-text">188 买卖股票的最佳时机 IV</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-medium"><span class="nav-number">7.20.</span> <span class="nav-text">309 最佳买卖股票时机含冷冻期 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#213"><span class="nav-number">7.21.</span> <span class="nav-text">213</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53"><span class="nav-number">7.22.</span> <span class="nav-text">53</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#343"><span class="nav-number">7.23.</span> <span class="nav-text">343</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#583"><span class="nav-number">7.24.</span> <span class="nav-text">583</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#646"><span class="nav-number">7.25.</span> <span class="nav-text">646</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#376"><span class="nav-number">7.26.</span> <span class="nav-text">376</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#494"><span class="nav-number">7.27.</span> <span class="nav-text">494</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#714"><span class="nav-number">7.28.</span> <span class="nav-text">714</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">分治法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#241-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7-medium"><span class="nav-number">8.1.</span> <span class="nav-text">241 为运算表达式设计优先级 medium</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#932"><span class="nav-number">8.2.</span> <span class="nav-text">932</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#312"><span class="nav-number">8.3.</span> <span class="nav-text">312</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95"><span class="nav-number">9.</span> <span class="nav-text">代码随想录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">9.1.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-easy"><span class="nav-number">9.1.1.</span> <span class="nav-text">704 二分查找 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-easy"><span class="nav-number">9.1.2.</span> <span class="nav-text">27 移除元素 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-easy"><span class="nav-number">9.1.3.</span> <span class="nav-text">977 有序数组的平方 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="nav-number">9.1.4.</span> <span class="nav-text">209 长度最小的子数组 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B52-medium"><span class="nav-number">9.1.5.</span> <span class="nav-text">59 螺旋矩阵2 medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">9.2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-easy"><span class="nav-number">9.2.1.</span> <span class="nav-text">203 移除链表元素 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-medium"><span class="nav-number">9.2.2.</span> <span class="nav-text">707 设计链表 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-easy"><span class="nav-number">9.2.3.</span> <span class="nav-text">206 反转链表 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-meduim"><span class="nav-number">9.2.4.</span> <span class="nav-text">24 两两交换链表中的节点 meduim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-medium"><span class="nav-number">9.2.5.</span> <span class="nav-text">19 删除链表的倒数第 N 个结点 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4-easy-%E5%90%8C160%E9%A2%98"><span class="nav-number">9.2.6.</span> <span class="nav-text">面试题 02.07. 链表相交 easy 同160题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">9.2.7.</span> <span class="nav-text">环形链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-easy"><span class="nav-number">9.2.7.1.</span> <span class="nav-text">141 环形链表 easy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-medium"><span class="nav-number">9.2.7.2.</span> <span class="nav-text">142 环形链表II medium</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">9.3.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-easy"><span class="nav-number">9.3.1.</span> <span class="nav-text">242 有效的字母异位词 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-easy"><span class="nav-number">9.3.2.</span> <span class="nav-text">1 两数之和 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A02-medium"><span class="nav-number">9.3.3.</span> <span class="nav-text">454 四数相加2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#383-%E8%B5%8E%E9%87%91%E4%BF%A1-easy"><span class="nav-number">9.3.4.</span> <span class="nav-text">383 赎金信 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-medium-%E9%9D%9E%E5%93%88%E5%B8%8C%E6%B3%95"><span class="nav-number">9.3.5.</span> <span class="nav-text">15 三数之和 medium(非哈希法)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-medium"><span class="nav-number">9.3.6.</span> <span class="nav-text">18 四数之和 medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">9.4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-easy"><span class="nav-number">9.4.1.</span> <span class="nav-text">344 反转字符串 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B22-easy"><span class="nav-number">9.4.2.</span> <span class="nav-text">541 反转字符串2 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-easy"><span class="nav-number">9.4.3.</span> <span class="nav-text">剑指 Offer 05. 替换空格 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#151-%E9%A2%A0%E5%80%92%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-medium"><span class="nav-number">9.4.4.</span> <span class="nav-text">151 颠倒字符串中的单词 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%91%E6%8C%87-Offer-58-II-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-easy"><span class="nav-number">9.4.5.</span> <span class="nav-text">剑指 Offer 58 - II. 左旋转字符串 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr-easy-KMP"><span class="nav-number">9.4.6.</span> <span class="nav-text">28 实现 strStr() easy(KMP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-easy-KMP"><span class="nav-number">9.4.7.</span> <span class="nav-text">459 重复的子字符串 easy(KMP)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">9.5.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-easy"><span class="nav-number">9.5.1.</span> <span class="nav-text">232 用栈实现队列 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-easy"><span class="nav-number">9.5.2.</span> <span class="nav-text">225 用队列实现栈 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-easy"><span class="nav-number">9.5.3.</span> <span class="nav-text">20 有效的括号 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-easy"><span class="nav-number">9.5.4.</span> <span class="nav-text">1047 删除字符串中的所有相邻重复项 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-medium"><span class="nav-number">9.5.5.</span> <span class="nav-text">150 逆波兰表达式求值 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-hard"><span class="nav-number">9.5.6.</span> <span class="nav-text">239 滑动窗口最大值 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-medium"><span class="nav-number">9.5.7.</span> <span class="nav-text">347 前k个高频元素 medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.6.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#94-144-145-%E4%BA%8C%E5%8F%89%E6%95%B0%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E6%B3%95%EF%BC%89-easy"><span class="nav-number">9.6.1.</span> <span class="nav-text">94&#x2F;144&#x2F;145 二叉数递归遍历（递归法） easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-144-145-%E4%BA%8C%E5%8F%89%E6%95%B0%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89-easy"><span class="nav-number">9.6.2.</span> <span class="nav-text">94&#x2F;144&#x2F;145 二叉数递归遍历（迭代法） easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-144-145-%E4%BA%8C%E5%8F%89%E6%95%B0%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%88%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95%EF%BC%89-easy"><span class="nav-number">9.6.3.</span> <span class="nav-text">94&#x2F;144&#x2F;145 二叉数递归遍历（统一迭代法） easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-medium"><span class="nav-number">9.6.4.</span> <span class="nav-text">102 二叉树的层序遍历 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="nav-number">9.6.5.</span> <span class="nav-text">226 翻转二叉树 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="nav-number">9.6.6.</span> <span class="nav-text">101 对称二叉树 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-easy"><span class="nav-number">9.6.7.</span> <span class="nav-text">104 二叉树最大深度 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-easy"><span class="nav-number">9.6.8.</span> <span class="nav-text">111 二叉树的最小深度 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-medium"><span class="nav-number">9.6.9.</span> <span class="nav-text">222 完全二叉树的节点个数 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="nav-number">9.6.10.</span> <span class="nav-text">110 平衡二叉树 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy-1"><span class="nav-number">9.6.11.</span> <span class="nav-text">257 二叉树的所有路径 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-easy"><span class="nav-number">9.6.12.</span> <span class="nav-text">404 左叶子之和 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-medium"><span class="nav-number">9.6.13.</span> <span class="nav-text">513 找树左下角的值 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">9.6.14.</span> <span class="nav-text">路径总和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-easy"><span class="nav-number">9.6.14.1.</span> <span class="nav-text">112 路径总和 easy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C2-easy"><span class="nav-number">9.6.14.2.</span> <span class="nav-text">113 路径总和2 easy</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%89%8D%E5%BA%8F-%E5%90%8E%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">9.6.15.</span> <span class="nav-text">通过中序和前序&#x2F;后序构建二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="nav-number">9.6.15.1.</span> <span class="nav-text">105 从前序与中序遍历序列构造二叉树 medium</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="nav-number">9.6.15.2.</span> <span class="nav-text">106 从中序与后序遍历序列构造二叉树 medium</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-medium"><span class="nav-number">9.6.16.</span> <span class="nav-text">654 最大二叉树 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-easy"><span class="nav-number">9.6.17.</span> <span class="nav-text">617 合并二叉树 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%90%9C%E7%B4%A2-easy"><span class="nav-number">9.6.18.</span> <span class="nav-text">700 二叉搜索树的搜索 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="nav-number">9.6.19.</span> <span class="nav-text">98 验证二叉搜索树 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-medium"><span class="nav-number">9.6.20.</span> <span class="nav-text">530 二叉搜索树的最小绝对差 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E4%BC%97%E6%95%B0-easy"><span class="nav-number">9.6.21.</span> <span class="nav-text">501 二叉搜索树的众数 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-medium"><span class="nav-number">9.6.22.</span> <span class="nav-text">236 二叉树的最近公共祖先 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-easy"><span class="nav-number">9.6.23.</span> <span class="nav-text">235 二叉搜索树的最近公共祖先 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-medium"><span class="nav-number">9.6.24.</span> <span class="nav-text">701 二叉搜索树中的插入操作 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-medium"><span class="nav-number">9.6.25.</span> <span class="nav-text">450 删除二叉搜索树中的节点 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="nav-number">9.6.26.</span> <span class="nav-text">669 修剪二叉搜索树 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-easy"><span class="nav-number">9.6.27.</span> <span class="nav-text">108 将有序数组转换为二叉搜索树 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-medium"><span class="nav-number">9.6.28.</span> <span class="nav-text">538 把二叉搜索树转换为累加树 medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95"><span class="nav-number">9.7.</span> <span class="nav-text">回溯算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#77-%E7%BB%84%E5%90%88-medium"><span class="nav-number">9.7.1.</span> <span class="nav-text">77 组合 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III-medium"><span class="nav-number">9.7.2.</span> <span class="nav-text">216 组合总和 III medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88-medium"><span class="nav-number">9.7.3.</span> <span class="nav-text">17 电话号码的字母组合 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-medium"><span class="nav-number">9.7.4.</span> <span class="nav-text">39 组合总和 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II-medium-1"><span class="nav-number">9.7.5.</span> <span class="nav-text">40 组合总和 II medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2-medium"><span class="nav-number">9.7.6.</span> <span class="nav-text">131 分割回文串 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80-medium"><span class="nav-number">9.7.7.</span> <span class="nav-text">93 复原ip地址 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#78-%E5%AD%90%E9%9B%86-medium"><span class="nav-number">9.7.8.</span> <span class="nav-text">78 子集 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-%E5%AD%90%E9%9B%862-medium"><span class="nav-number">9.7.9.</span> <span class="nav-text">90 子集2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="nav-number">9.7.10.</span> <span class="nav-text">491 递增子序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E5%85%A8%E6%8E%92%E5%88%97-medium"><span class="nav-number">9.7.11.</span> <span class="nav-text">46 全排列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-%E5%85%A8%E6%8E%92%E5%88%972-medium-1"><span class="nav-number">9.7.12.</span> <span class="nav-text">47 全排列2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B-hard"><span class="nav-number">9.7.13.</span> <span class="nav-text">332 重新安排行程 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N%E7%9A%87%E5%90%8E-hard"><span class="nav-number">9.7.14.</span> <span class="nav-text">51 N皇后 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E8%A7%A3%E6%95%B0%E7%8B%AC-hard"><span class="nav-number">9.7.15.</span> <span class="nav-text">21 解数独 hard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-1"><span class="nav-number">9.8.</span> <span class="nav-text">贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2-easy"><span class="nav-number">9.8.1.</span> <span class="nav-text">455 分发饼干 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97-medium"><span class="nav-number">9.8.2.</span> <span class="nav-text">376 摆动序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium"><span class="nav-number">9.8.3.</span> <span class="nav-text">53 最大子数组和 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-medium"><span class="nav-number">9.8.4.</span> <span class="nav-text">122 买卖股票的最佳时机II medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-medium"><span class="nav-number">9.8.5.</span> <span class="nav-text">55 跳跃游戏 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F2-medium"><span class="nav-number">9.8.6.</span> <span class="nav-text">45 跳跃游戏2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1005-K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-easy"><span class="nav-number">9.8.7.</span> <span class="nav-text">1005 K 次取反后最大化的数组和 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99-medium"><span class="nav-number">9.8.8.</span> <span class="nav-text">134 加油站 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C-hard-1"><span class="nav-number">9.8.9.</span> <span class="nav-text">135 分发糖果 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%A0%91%E6%89%BE%E9%9B%B6-easy"><span class="nav-number">9.8.10.</span> <span class="nav-text">860 柠檬树找零 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97-medium-1"><span class="nav-number">9.8.11.</span> <span class="nav-text">406 根据身高重建队列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%8F%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83-medium"><span class="nav-number">9.8.12.</span> <span class="nav-text">452 用最小数量的箭引爆气球 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4-medium"><span class="nav-number">9.8.13.</span> <span class="nav-text">435 无重叠区间 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4-medium-1"><span class="nav-number">9.8.14.</span> <span class="nav-text">763 划分字母区间 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-mediun"><span class="nav-number">9.8.15.</span> <span class="nav-text">56 合并区间 mediun</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="nav-number">9.9.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0-easy"><span class="nav-number">9.9.1.</span> <span class="nav-text">509 斐波那契数 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-easy-1"><span class="nav-number">9.9.2.</span> <span class="nav-text">70 爬楼梯 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF-easy"><span class="nav-number">9.9.3.</span> <span class="nav-text">746 使用最小花费爬楼梯 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-medium"><span class="nav-number">9.9.4.</span> <span class="nav-text">62 不同路径 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%842-medium"><span class="nav-number">9.9.5.</span> <span class="nav-text">63 不同路径2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86-medium"><span class="nav-number">9.9.6.</span> <span class="nav-text">343 整数拆分 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-medium"><span class="nav-number">9.9.7.</span> <span class="nav-text">96 不同的二叉搜索树 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86-medium"><span class="nav-number">9.9.8.</span> <span class="nav-text">416 分割等和子集 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII-medium"><span class="nav-number">9.9.9.</span> <span class="nav-text">1049 最后一块石头的重量II medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C-medium"><span class="nav-number">9.9.10.</span> <span class="nav-text">494 目标和 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#474-%E9%9B%B6%E5%92%8C%E4%B8%80-medium"><span class="nav-number">9.9.11.</span> <span class="nav-text">474 零和一 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86"><span class="nav-number">9.9.12.</span> <span class="nav-text">背包问题解析合集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3-medium"><span class="nav-number">9.9.13.</span> <span class="nav-text">377 组合总和Ⅳ medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-medium"><span class="nav-number">9.9.14.</span> <span class="nav-text">518 零钱兑换II medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-medium"><span class="nav-number">9.9.15.</span> <span class="nav-text">322 零钱兑换 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-medium-1"><span class="nav-number">9.9.16.</span> <span class="nav-text">279 完全平方数 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-medium-1"><span class="nav-number">9.9.17.</span> <span class="nav-text">139 单词拆分 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-medium-1"><span class="nav-number">9.9.18.</span> <span class="nav-text">198 打家劫舍 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2-medium"><span class="nav-number">9.9.19.</span> <span class="nav-text">213 打家劫舍2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#337-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%AE%BE3-medium"><span class="nav-number">9.9.20.</span> <span class="nav-text">337 打家劫设3 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-easy-1"><span class="nav-number">9.9.21.</span> <span class="nav-text">121 买卖股票的最佳时机 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA2-medium"><span class="nav-number">9.9.22.</span> <span class="nav-text">122 买卖股票的最佳时机2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA3-hard"><span class="nav-number">9.9.23.</span> <span class="nav-text">123 买卖股票最佳时机3 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA4-hard"><span class="nav-number">9.9.24.</span> <span class="nav-text">188 买卖股票最佳时机4 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F-medium-1"><span class="nav-number">9.9.25.</span> <span class="nav-text">309 最佳买卖股票时机含冷冻期 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9-medium"><span class="nav-number">9.9.26.</span> <span class="nav-text">714 买卖股票的最佳时机含手续费 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-medium-1"><span class="nav-number">9.9.27.</span> <span class="nav-text">300 最长递增子序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#674-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97-easy"><span class="nav-number">9.9.28.</span> <span class="nav-text">674 最长连续递增序列 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#718-%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="nav-number">9.9.29.</span> <span class="nav-text">718 最长重复子数组 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97-medium-1"><span class="nav-number">9.9.30.</span> <span class="nav-text">1143 最长公共子序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%BA%8F%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="nav-number">9.9.31.</span> <span class="nav-text">最长序列问题总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1035-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF-medium"><span class="nav-number">9.9.32.</span> <span class="nav-text">1035 不相交的线 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-medium-1"><span class="nav-number">9.9.33.</span> <span class="nav-text">53 最大子数组和 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#392-%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="nav-number">9.9.34.</span> <span class="nav-text">392 判断子序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-hard"><span class="nav-number">9.9.35.</span> <span class="nav-text">115 不同的子序列 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-medium"><span class="nav-number">9.9.36.</span> <span class="nav-text">583 两个字符串的删除操作 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB-hard-1"><span class="nav-number">9.9.37.</span> <span class="nav-text">72 编辑距离 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="nav-number">9.9.38.</span> <span class="nav-text">647 回文子串 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-medium"><span class="nav-number">9.9.39.</span> <span class="nav-text">516 最长回文子序列 medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">9.10.</span> <span class="nav-text">单调栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-medium"><span class="nav-number">9.10.1.</span> <span class="nav-text">739 每日温度 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#496-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01-easy"><span class="nav-number">9.10.2.</span> <span class="nav-text">496 下一个更大元素1 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#503-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A02-medium"><span class="nav-number">9.10.3.</span> <span class="nav-text">503 下一个更大元素2 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4-hard"><span class="nav-number">9.10.4.</span> <span class="nav-text">42 接雨水 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-hard"><span class="nav-number">9.10.5.</span> <span class="nav-text">84 柱状图中最大的矩形 hard</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#hot100"><span class="nav-number">9.11.</span> <span class="nav-text">hot100</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2"><span class="nav-number">9.11.1.</span> <span class="nav-text">3 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-medium"><span class="nav-number">9.11.2.</span> <span class="nav-text">5 最长回文子串 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8-medium"><span class="nav-number">9.11.3.</span> <span class="nav-text">11 盛水最多的容器 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97-medium"><span class="nav-number">9.11.4.</span> <span class="nav-text">128 最长连续序列 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU%E7%BC%93%E5%AD%98-medium"><span class="nav-number">9.11.5.</span> <span class="nav-text">146 LRU缓存 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="nav-number">9.11.6.</span> <span class="nav-text">152 乘积最大子数组 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="nav-number">9.11.7.</span> <span class="nav-text">136 只出现一次的数字 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6-easy"><span class="nav-number">9.11.8.</span> <span class="nav-text">283 移动零 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0-easy"><span class="nav-number">9.11.9.</span> <span class="nav-text">169 多数元素 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8-easy"><span class="nav-number">9.11.10.</span> <span class="nav-text">234 回文链表 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#448-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-easy"><span class="nav-number">9.11.11.</span> <span class="nav-text">448 找到所有数组中消失的数字 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#287-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0-medium"><span class="nav-number">9.11.12.</span> <span class="nav-text">287 寻找重复数 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="nav-number">9.11.13.</span> <span class="nav-text">560 和为 K 的子数组 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84-medium"><span class="nav-number">9.11.14.</span> <span class="nav-text">581 最短无序连续子数组 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB-easy"><span class="nav-number">9.11.15.</span> <span class="nav-text">461 汉明距离 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-medium"><span class="nav-number">9.11.16.</span> <span class="nav-text">2 两数相加 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#338-%E6%AF%94%E7%89%B9%E4%BD%8D%E8%AE%A1%E6%95%B0-easy"><span class="nav-number">9.11.17.</span> <span class="nav-text">338 比特位计数 easy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8-hard"><span class="nav-number">9.11.18.</span> <span class="nav-text">23 合并K个升序链表 hard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF-medium"><span class="nav-number">9.11.19.</span> <span class="nav-text">238 除自身以外数组的乘积 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-medium"><span class="nav-number">9.11.20.</span> <span class="nav-text">148 排序链表 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-medium"><span class="nav-number">9.11.21.</span> <span class="nav-text">200 岛屿数量 medium</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#208-%E5%AE%9E%E7%8E%B0Trie-%E5%89%8D%E7%BC%80%E6%A0%91-medium"><span class="nav-number">9.11.22.</span> <span class="nav-text">208 实现Trie(前缀树) medium</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%9D%E5%A4%96%E7%BB%83%E4%B9%A0"><span class="nav-number">10.</span> <span class="nav-text">额外练习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8-easy"><span class="nav-number">10.1.</span> <span class="nav-text">21 合并两个有序链表 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%88%E9%80%92%E5%A2%9E%E5%86%8D%E9%80%92%E5%87%8F%E6%95%B0%E7%BB%84%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">10.2.</span> <span class="nav-text">先递增再递减数组找最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-easy"><span class="nav-number">10.3.</span> <span class="nav-text">14 最长公共前缀 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97-easy"><span class="nav-number">10.4.</span> <span class="nav-text">83 删除排序链表中的重复数字 easy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84-easy-1"><span class="nav-number">10.5.</span> <span class="nav-text">88 合并两个有序数组 easy</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">小陈同学</p>
  <div class="site-description" itemprop="description">求知若饥，虚心若愚，虚化若谷</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/chenwingsing" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chenwingsing" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chen-yongcheng@outlook.com" title="E-Mail → mailto:chen-yongcheng@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fa fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="小陈同学">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小陈同学">
      <meta itemprop="description" content="求知若饥，虚心若愚，虚化若谷">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode-JAVA | 小陈同学">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode-JAVA
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-20 10:48:01" itemprop="dateCreated datePublished" datetime="2021-09-20T10:48:01+08:00">2021-09-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-26 09:10:38" itemprop="dateModified" datetime="2022-10-26T09:10:38+08:00">2022-10-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>按照<a target="_blank" rel="noopener" href="https://github.com/changgyhub/leetcode_101">《Leetcode101-A Leetcode Gringding Guide》</a>顺序记录。除此之外，开始正视代码书写规范。</p>
<span id="more"></span> 
<h1 id="ACM模式练习"><a href="#ACM模式练习" class="headerlink" title="ACM模式练习"></a>ACM模式练习</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next()、nextInt()、nextLine()都是Scanner内置的方法，他们的区别主要在于对于对空格的处理方式不同，以及返回值不同。</span><br><span class="line">nextLine()方法，空格不作为两个字符串的间隔，而是看作字符串的一部分。</span><br><span class="line">next()和nextInt()方法遇到空格时会停止读取，nextInt()的返回值为int类型，next()、nextLine()的返回值均为String类型。</span><br></pre></td></tr></table></figure>
<h2 id="1-A-B-I"><a href="#1-A-B-I" class="headerlink" title="1.A+B I"></a>1.A+B I</h2><p>单纯简单计算两个数的和，但是有n组数据</p>
<p>输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000),输入数据包括多组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123; <span class="comment">//注意这里没有()，没有String[] args</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(a + b);  <span class="comment">// System.out.println(in.nextInt() + in.nextInt()); //或者可以把三行代码改成这个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-A-B-II"><a href="#2-A-B-II" class="headerlink" title="2.A+B II"></a>2.A+B II</h2><p>需要先声明要输入多少组数字之和</p>
<p>输入第一行包括一个数据组数t(1 &lt;&#x3D; t &lt;&#x3D; 100)<br>接下来每行包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 1000)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(a-- != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            System.out.println(b + c);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-A-B-III"><a href="#3-A-B-III" class="headerlink" title="3.A+B III"></a>3.A+B III</h2><p>和第一题不一样的是碰到0 0 则结束</p>
<p>输入包括两个正整数a,b(1 &lt;&#x3D; a, b &lt;&#x3D; 10^9),输入数据有多组, 如果输入为0 0则结束输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span> &amp;&amp; b == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(a + b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-计算一系列数的和-I"><a href="#4-计算一系列数的和-I" class="headerlink" title="4.计算一系列数的和 I"></a>4.计算一系列数的和 I</h2><p>先输入需要计算多少个数，然后求和，遇到第一个数为0则结束</p>
<p>输入数据包括多组。<br>每组数据一行,每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100), n为0的时候结束输入。<br>接下来n个正整数,即需要求和的每个正整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count-- != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-计算一系列数的和-II"><a href="#5-计算一系列数的和-II" class="headerlink" title="5.计算一系列数的和 II"></a>5.计算一系列数的和 II</h2><p>和第四题的区别是先声明需要输入多少组,而第四题是用0来结束的</p>
<p>输入的第一行包括一个正整数t(1 &lt;&#x3D; t &lt;&#x3D; 100), 表示数据组数。<br>接下来t行, 每行一组数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">group</span> <span class="operator">=</span> in.nextInt(); <span class="comment">//这个是输入需要计算多少组</span></span><br><span class="line">        <span class="keyword">while</span>(group-- != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt(); <span class="comment">//每组多少个数字需要计算</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count-- != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-计算一系列数的和-III"><a href="#6-计算一系列数的和-III" class="headerlink" title="6.计算一系列数的和 III"></a>6.计算一系列数的和 III</h2><p>和4，5的区别是这个没有限制，只需要提供每组多少个数，也就是每行表示一组数据</p>
<p>输入数据有多组, 每行表示一组输入数据。<br>每行的第一个整数为整数的个数n(1 &lt;&#x3D; n &lt;&#x3D; 100)。<br>接下来n个正整数, 即需要求和的每个正整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(count-- != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += in.nextInt(); </span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-计算一系列数的和-IV"><a href="#7-计算一系列数的和-IV" class="headerlink" title="7.计算一系列数的和 IV"></a>7.计算一系列数的和 IV</h2><p>这个题和上面的区别是 没有指定每组数字有多少个</p>
<p>输入数据有多组, 每行表示一组输入数据。<br>每行不定有n个整数，空格隔开。(1 &lt;&#x3D; n &lt;&#x3D; 100)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;<span class="comment">//注意这个Next是大写的</span></span><br><span class="line">            String[] str = in.nextLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//在每个空格字符处进行分解</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(str));如果输入1 2 3，可以看到是处理成[1,2,3]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">                sum += Integer.parseInt(str[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-字符串排序-I"><a href="#8-字符串排序-I" class="headerlink" title="8.字符串排序 I"></a>8.字符串排序 I</h2><p>只排序一组数据，先输入这组需要排序多少个字符</p>
<p>输入有两行，第一行n<br>第二行是n个字符串，字符串之间用空格隔开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> in.nextInt();</span><br><span class="line">        String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[count];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            str[i] = in.next();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(str);<span class="comment">//调库侠</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">            System.out.print(str[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//注意输出格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-字符串排序-II"><a href="#9-字符串排序-II" class="headerlink" title="9.字符串排序 II"></a>9.字符串排序 II</h2><p>和上一题的区别是不需要输入一组需要排序多少个字符 但是需要排序n组，也就是一次性输入一组的数据</p>
<p>多个测试用例，每个测试用例一行。<br>每行通过空格隔开，有n个字符，n＜100</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;<span class="comment">//注意这个Next是大写的</span></span><br><span class="line">            String[] str = in.nextLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//注意这个next是小写的</span></span><br><span class="line">            Arrays.sort(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++)&#123;</span><br><span class="line">                System.out.print(str[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//注意输出格式</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&#x27;\n&#x27;</span>);<span class="comment">//注意输出格式</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-字符串排序-III"><a href="#10-字符串排序-III" class="headerlink" title="10.字符串排序 III"></a>10.字符串排序 III</h2><p>这个和上一题的区别是输出格式是逗号隔开，上一题是空格，但是注意的是上一题最后一个字符后面是空格，这一题如果按照上一题的逻辑去做会输出一个逗号，而题目不希望出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">            String[] str = in.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            Arrays.sort(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">                System.out.print(str[i] + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(str[str.length - <span class="number">1</span>]);<span class="comment">//避免最后一个后面有个逗号，同时加一个回车</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-A-B-IV"><a href="#11-A-B-IV" class="headerlink" title="11.A+B IV"></a>11.A+B IV</h2><p>和第一题的区别是数据范围不一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123; <span class="comment">//注意这里没有()，没有String[] args</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNext())&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> in.nextLong();</span><br><span class="line">            <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> in.nextLong();</span><br><span class="line">            System.out.println(a + b);  <span class="comment">// System.out.println(in.nextLong() + in.nextLong()); //或者可以把三行代码改成这个</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="360一道题-acm"><a href="#360一道题-acm" class="headerlink" title="360一道题 acm"></a>360一道题 acm</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有一种特殊的DNA，仅仅由核酸A和T组成，长度为n，顺次连接</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">科学家有一种新的手段，可以改变这种DNA。每一次，科学家可以交换该DNA上两个核酸的位置，也可以将某个特定位置的核酸修改为另一种核酸。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">现在有一个DNA，科学家希望将其改造成另一种DNA，希望你计算最少的操作次数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ATTTAA</span></span><br><span class="line"><span class="comment">TTAATT</span></span><br><span class="line"><span class="comment">输出3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">样例解释：</span></span><br><span class="line"><span class="comment">1.首先修改第一个位置的核酸（从A修改为T）</span></span><br><span class="line"><span class="comment">2.交换3和5位置的核酸</span></span><br><span class="line"><span class="comment">3.交换4和6位置的核酸</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    String a,b;</span><br><span class="line">    a = sc.nextLine();</span><br><span class="line">    b = sc.nextLine();</span><br><span class="line">    <span class="comment">//return dna(a,b);</span></span><br><span class="line">    System.out.println(dna(a,b));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dna</span><span class="params">(String a, String b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a.charAt(i) == <span class="string">&#x27;A&#x27;</span> &amp;&amp; b.charAt(i) != <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">        c++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (a.charAt(i) == <span class="string">&#x27;T&#x27;</span> &amp;&amp; b.charAt(i) != <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">        d++;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(c,d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACM-二叉树输入-前序遍历为例"><a href="#ACM-二叉树输入-前序遍历为例" class="headerlink" title="ACM 二叉树输入 前序遍历为例"></a>ACM 二叉树输入 前序遍历为例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hi;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">tree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = sc.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> construct(arr);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorder(root, list);</span><br><span class="line">        System.out.print(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;<span class="comment">//前序来举个例子</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        preorder(root.left, list);</span><br><span class="line">        preorder(root.right, list);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span> <span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span> <span class="params">(<span class="type">int</span> val, TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; treeNodeList = arr.length &gt; <span class="number">0</span> ? <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr.length) : <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != -<span class="number">1</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                node = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            treeNodeList.add(node);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                root = node;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i * <span class="number">2</span> + <span class="number">1</span> &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> treeNodeList.get(i);</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                node.left = treeNodeList.get(<span class="number">2</span> * i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">2</span> &lt; arr.length)<span class="comment">//这个必须加上，不然越界了</span></span><br><span class="line">                node.right = treeNodeList.get(<span class="number">2</span> * i + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ACM-链表-反转链表为例"><a href="#ACM-链表-反转链表为例" class="headerlink" title="ACM 链表 反转链表为例"></a>ACM 链表 反转链表为例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hi;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">listnode</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        String[] param = sc.nextLine().split(<span class="string">&quot; &quot;</span>);<span class="comment">//输入的时候就是1 2 3 4 5</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">for</span> (String x : param) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(Integer.parseInt(x));</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> reverse(dump.next);</span><br><span class="line">        <span class="keyword">while</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(res.val);</span><br><span class="line">            <span class="keyword">if</span> (res.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = res.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="445-分发饼干-easy"><a href="#445-分发饼干-easy" class="headerlink" title="445 分发饼干 easy"></a>445 分发饼干 easy</h2><p>依次满足胃口最小的孩子。可以想到先排序，然后再去分配。注意当满足了孩子后,cookie再加一，因为一个饼干只能用一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//知识点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">length()：String类的一个方法</span></span><br><span class="line"><span class="comment">字符串.length()</span></span><br><span class="line"><span class="comment">length() 方法用于返回字符串的长度。</span></span><br><span class="line"><span class="comment">长度等于字符串中 16 位 Unicode 代码单元的数量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">length：类的属性</span></span><br><span class="line"><span class="comment">数组.length</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(child &lt; g.length &amp;&amp; cookie &lt; s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child] &lt;= s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;<span class="comment">//饼干只能用一次，满足条件再加1。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="135-分发糖果-hard"><a href="#135-分发糖果-hard" class="headerlink" title="135 分发糖果 hard"></a>135 分发糖果 hard</h2><p>首先建立一个数组，然后初始化为1，也就是每个人都先分到一颗糖。然后从左往右边遍历，如果右边的孩子得分高于左边，则右边的孩子糖果数&#x3D;左边的孩子糖果数+1，注意这里不是直接加1.因为分数可能是依次增加，还要求分数高的糖果多。然后从右往左遍历，如果左边的孩子分数大于右边孩子分数并且左边孩子的糖果数不如右边孩子糖果数，则左边孩子糖果数&#x3D;右边孩子糖果数+1，这种情况对应于左边分数大于右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//根据书上的思路写的，写法比较冗余。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span> candys[] = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">            candys[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ratings.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i+<span class="number">1</span>] &gt; ratings[i])&#123;</span><br><span class="line">                candys[i+<span class="number">1</span>] = candys[i] +<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length-<span class="number">1</span>; i &gt; <span class="number">0</span> ; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i-<span class="number">1</span>] &gt; ratings[i] &amp;&amp; candys[i-<span class="number">1</span>] &lt;=  candys[i])&#123;</span><br><span class="line">                candys[i-<span class="number">1</span>] = candys[i] +<span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ratings.length; i++)&#123;</span><br><span class="line">            count += candys[i]; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//这个有点不一样，分别创建两个数组，对应满足左右两个规则。然后分别取两个数组的最大值，为什么这样做可以？有个评论写得很清晰,如下。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么取最大值是正确的思考：</span></span><br><span class="line"><span class="comment">很多人说这个问题显而易见，不值得讨论，但我相信还是有人像我一样不理解，在这里说一下我的想法</span></span><br><span class="line"><span class="comment">我疑惑的问题不是取最大值为啥是最优解，而是取最大值后为啥不影响某一规则的成立。</span></span><br><span class="line"><span class="comment">我们取序列中的任意两点，A B</span></span><br><span class="line"><span class="comment">如果 A &gt; B ,则按照左规则处理后，B不会比A多；按照右规则处理后，A一定比B多，那么A一定会被更新（变大），但L、R规则仍然成立：B不会比A多，A一定比B多；</span></span><br><span class="line"><span class="comment">同理可讨论 A&lt;B;</span></span><br><span class="line"><span class="comment">当 A == B，A、B的值无论如何更新，都不影响 L、R规则</span></span><br><span class="line"><span class="comment">综上，取最大值后不影响某一规则的成立。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] left = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="type">int</span>[] right = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        Arrays.fill(left, <span class="number">1</span>);</span><br><span class="line">        Arrays.fill(right, <span class="number">1</span>);<span class="comment">//把right数组全部填充为1，如果长度是长，则right=[1,1,1]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++)</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> left[ratings.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            count += Math.max(left[i], right[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：jyd</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="435-无重叠区间-medium-可动态规划"><a href="#435-无重叠区间-medium-可动态规划" class="headerlink" title="435 无重叠区间 medium(可动态规划)"></a>435 无重叠区间 medium(可动态规划)</h2><p>这里学到了Arrays.sort()新写法，开头一直纠结怎么把书上C++的排序用java表达(java用得少)。这里是要移除区间的最小个数，贪心的策略是：在选择要保留区间时，选择的区间结尾越小，余留给其他区间的空间就越大，就能保留更多的区间。首先对尾巴进行递增排序，也就是每个区间的第二个数字排序。然后对prve赋值为第一个区间的尾巴。开始进入for循环，如果第二个区间的头是小于prev，也就是在第一个的区间内，需要进行移除，如果大于了prev，则保留区间，然后prev赋值给第二个区间的尾巴，以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先是知识点笔记，部分来源于网络 Arrays.sort()</span></span><br><span class="line">System.out.println(Arrays.deepToString(intervals));<span class="comment">//这样可以输出二维数组的样子</span></span><br><span class="line">System.out.println(Arrays.toString(intervals));<span class="comment">//输出的貌似是地址，反正是这样的[[I@49993335, [I@20322d26, [I@192b07fd, [I@64bfbc86]</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法一、使用Comparable接口：</span></span><br><span class="line"><span class="comment">让待排序对象所在的类实现Comparable接口，并重写Comparable接口中的compareTo() 。方法缺点是只能按照一种规则排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法二、使用Comparator接口 （推荐使用）</span></span><br><span class="line"><span class="comment">如果一个类要实现java.util.Comparator接口：它一定要实现</span></span><br><span class="line"><span class="comment">int compare(T o1, T o2) 函数，而另一个可以不实现（boolean equals(Object obj)） 。</span></span><br><span class="line"><span class="comment">使用编写排序方式类实现Comparator接口，并重写新Comparator接口中的compare()方法。优点：想用什么方式排就用什么方式排。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">原理：观察Arrays.sort()源码如下：</span></span><br><span class="line"><span class="comment">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;</span></span><br><span class="line"><span class="comment">        if (c == null) &#123;</span></span><br><span class="line"><span class="comment">            sort(a);</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">            if (LegacyMergeSort.userRequested)</span></span><br><span class="line"><span class="comment">                legacyMergeSort(a, c);</span></span><br><span class="line"><span class="comment">            else</span></span><br><span class="line"><span class="comment">                TimSort.sort(a, 0, a.length, c, null, 0, 0);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">所以，在传入要排序数组时，还可以传入一个Compartor接口（比较器），然后这个接口中要重写一个compare()方法，这个重写的compare()方法就是我们自己规定的比较规则。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现Comparator接口，必须实现下面这个函数：</span></span><br><span class="line"><span class="comment">@Override</span></span><br><span class="line"><span class="comment">public int compare(CommentVo o1, CommentVo o2) &#123;</span></span><br><span class="line"><span class="comment">           return o1.getTime().compareTo(o2.getTime());</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">这里o1表示位于前面的对象，o2表示后面的对象</span></span><br><span class="line"><span class="comment">返回-1（或负数），表示不需要交换01和02的位置，o1排在o2前面，asc</span></span><br><span class="line"><span class="comment">返回1（或正数），表示需要交换01和02的位置，o1排在o2后面，desc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//所以本题的sort，比较尾巴就是interval1[1]，为了递增，左边尾巴减右边尾巴，负数就不需要交换，正数就交换。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//这个是贪心策略写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span> []&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] interval1, <span class="type">int</span>[] interval2)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">1</span>]-interval2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//学废了吗？</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>, prev = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; prev)&#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                prev = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="605-种花问题-easy"><a href="#605-种花问题-easy" class="headerlink" title="605 种花问题 easy"></a>605 种花问题 easy</h2><p>虽说是easy题，但是发现自己想的bug很多，看到了一个很清晰的解题方法：跳格法。注意题目是不能打破原来的种植规则！。情况1：当index遇到1的时候，也就是至少隔一格才能种花，所以i要跳两格。情况2：当index遇到0时候，如果下一格为0，则可以种花（此时n-1），并且顺便跳两格，这里还有个情况就是如果已经是最后一格了，那就也能种花，一开始会想，万一最后一格的前面一格是1呢？注意这个情况不会发生，因为你是跳格法，你跳的index就代表是可能种花的，只需要考虑后面就行。如果下一个格子为1(比如0100)，则这格不能种花，则i要跳3格才可以种花。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//这个写得比较清晰，但是冗余。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; flowerbed.length &amp;&amp; n &gt;<span class="number">0</span>;)&#123;</span><br><span class="line">             <span class="keyword">if</span>(flowerbed[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                 i += <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>((flowerbed[i] ==<span class="number">0</span> &amp;&amp; i == flowerbed.length-<span class="number">1</span>) || (flowerbed[i] ==<span class="number">0</span> &amp;&amp; flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>))&#123;</span><br><span class="line">                 n--;</span><br><span class="line">                 i += <span class="number">2</span>;     </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(flowerbed[i] ==<span class="number">0</span> &amp;&amp; flowerbed[i+<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                 i +=<span class="number">3</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//这个省略了点。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPlaceFlowers</span><span class="params">(<span class="type">int</span>[] flowerbed, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; flowerbed.length &amp;&amp; n &gt;<span class="number">0</span>;)&#123;</span><br><span class="line">             <span class="keyword">if</span>(flowerbed[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                 i += <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> <span class="keyword">if</span>(i == flowerbed.length-<span class="number">1</span> ||  flowerbed[i+<span class="number">1</span>] == <span class="number">0</span>)&#123;<span class="comment">//因为你的flowerbed[i]不是1就是0，上一步已经判断好了是不是1，所以如果不是1的话自然跳到这里。</span></span><br><span class="line">                 n--;</span><br><span class="line">                 i += <span class="number">2</span>;     </span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 i += <span class="number">3</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">return</span> n &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="452-用最少数量的箭引爆气球-medium-和435相似"><a href="#452-用最少数量的箭引爆气球-medium-和435相似" class="headerlink" title="452 用最少数量的箭引爆气球 medium(和435相似)"></a>452 用最少数量的箭引爆气球 medium(和435相似)</h2><p>这个题我的思路是，首先还是对尾巴进行升序排列，然后赋值prev给第一个数的尾巴，开始进行for循环比较第二个数，如果prev大于第二个数的头，也就是这个箭还是可以穿过去，不需要考虑尾巴，因为题目说了头一定比尾巴小。然后如果prev比头小，就说明穿不过去了，这时候就箭的数目加1.以此类推，这个注意count初始值为1，因为本身至少都需要一支箭，可以试试只有一个区间，在循环内counnt是不增加的。这里和435比较：435是不重叠区间，而这里刚好是重叠区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//看了一遍435后自己写的，注意这里的升序有点和435的不一样，因为会有一个用例存在溢出问题，如果按照435的写。[[-2147483646,-2147483645],[2147483646,2147483647]]，sort后是[[2147483646,2147483647],[-2147483646,-2147483645]]，因为他们相减后会溢出，所以用到小于来比较。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(points,<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span> []&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] points1, <span class="type">int</span>[] points2)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(points1[<span class="number">1</span>] &lt; points2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">       </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>,prev = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(points[i][<span class="number">0</span>] &gt; prev)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                prev = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这个for循环就比较详细，但是没必要，增加运行的时间。</span></span><br><span class="line"><span class="comment">    for(int i = 1; i &lt; points.length; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(points[i][0] &lt; prev)&#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else if(points[i][0] &gt; prev)&#123;</span></span><br><span class="line"><span class="comment">                count++;</span></span><br><span class="line"><span class="comment">                System.out.println(count);</span></span><br><span class="line"><span class="comment">                prev = points[i][1];</span></span><br><span class="line"><span class="comment">            &#125;           </span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="763-划分字母区间-medium"><a href="#763-划分字母区间-medium" class="headerlink" title="763 划分字母区间 medium"></a>763 划分字母区间 medium</h2><p>自己想的思路比较复杂，太冗余，而且可能考虑的东西不够全面。官方思路:首先用一个长度为26的数组a把每个字母的最后一个位置进行标记。设置start和end，开始循环字符串，访问每个字母，通过之前a来获取他的最后一个位置endc，令end&#x3D;max（end，endc）。如果循环到i等于end，就说明之前的字母都包括在这个区间内，那就让长度写入partition，并令start&#x3D;end+1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//知识点总结，</span></span><br><span class="line">List&lt;Integer&gt; partition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">List是一个接口</span></span><br><span class="line"><span class="comment">&lt;&gt;表示了List里面放的对象是什么类型的，上面List里面放的必须是Integer类型的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">ArrayList类是一个特殊的数组–动态数组。通过添加和删除元素，就可以动态改变数组的长度。</span></span><br><span class="line"><span class="comment">优点：</span></span><br><span class="line"><span class="comment">1、支持自动改变大小 2、可以灵活的插入元素 3、可以灵活的删除元素</span></span><br><span class="line"><span class="comment">局限：</span></span><br><span class="line"><span class="comment">比一般的数组的速度慢一些；</span></span><br><span class="line"><span class="comment">可以调用 List接口里面的内置函数,add,get等方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String s = &quot;www.runoob.com&quot;;</span></span><br><span class="line"><span class="comment">char result = s.charAt(6);</span></span><br><span class="line"><span class="comment">输出为n</span></span><br><span class="line"><span class="comment">所以本题这样的做法，可以把每个字母的最后一个位置记录下来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">          <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">          <span class="type">int</span>[] last =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">          List&lt;Integer&gt; partition = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">              last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">              end = Math.max(end, last[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">              <span class="keyword">if</span>(i == end)&#123;</span><br><span class="line">                  partition.add(end - start + <span class="number">1</span>);</span><br><span class="line">                  start = end + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> partition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="122-买卖股票的最佳时机2-easy-可动态规划"><a href="#122-买卖股票的最佳时机2-easy-可动态规划" class="headerlink" title="122 买卖股票的最佳时机2 easy(可动态规划)"></a>122 买卖股票的最佳时机2 easy(可动态规划)</h2><p>还是没有独立想出来，想得太复杂，一直纠结怎么用区间来解答。官方解答太多数学公式，总体来说就是只要选择贡献大于0的区间，然后一直累加利润，但是这个做法是不知道第几次买卖的，只能求利润，对于负数，则和0比较就行。秒呀！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            price += Math.max(<span class="number">0</span>, prices[i] - prices[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="406-根据身高重建队列-medium"><a href="#406-根据身高重建队列-medium" class="headerlink" title="406 根据身高重建队列 medium"></a>406 根据身高重建队列 medium</h2><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/xian-pai-xu-zai-cha-dui-dong-hua-yan-shi-suan-fa-g/">网友思路</a>：首先遇到这种数对问题，先排序。根据第一个元素正向排序，根据第二个元素反向排序，或者根据第一个元素反向排序，根据第二个元素正向排序，往往能够简化解题过程。在本题目中，先对数对进行排序，按照数对的元素 1 降序排序，按照数对的元素 2 升序排序。原因是，按照元素 1 进行降序排序，对于每个元素，在其之前的元素的个数，就是大于等于他的元素的数量，而按照第二个元素正向排序，我们希望 k 大的尽量在后面，减少插入操作的次数。小陈补充：如果第一个位置降序，第二个位置也降序排，再按照这样写法去插入的话，有部分用例是不能通过的，比如a[[7,0],[6,1],[5,2]]下一个待插入的数是[5,0]，按照算法应该插入到第一个位置，变成a[[5,0],[7,0],[6,1],[5,2]]这时候我们就发现[5,2]已经错误了，因为前面有三个数大于或者等于了。也就是你插入后，你得保证后面没有等于你的数插入，所以，第二个位置的排序，要升序！！！保证同胞小弟位置(第二个位置)先安排好。我们可以这样缕清楚，a里面已经插入的数都是比后面待插入的数大或者相等，如果后面待插入的数第二个位置比a的长度小，那么就是说他来选位置插，反之，他就插到最后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//知识点</span></span><br><span class="line"><span class="comment">//这个题可以学到compare对两个位置进行排序的写法，具体看下面的答案这里不多说</span></span><br><span class="line"> List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个的话是双向链表，比创建数组a更加方便，创建数组的话，当你的情况是a的长度大小大于people[i][1]时，你是要插入到a的people[i][1]的位置，这时候你需要进行移动a[people[i][1]]以及后面的每个数据1位，然后才能插进去，这样麻烦。</span></span><br><span class="line"><span class="comment">最后转成list.toArray(new int[list.size()][]);返回即可。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以对比763的</span></span><br><span class="line"><span class="comment">List&lt;Integer&gt; partition = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span> []&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] people1, <span class="type">int</span>[] people2)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(people1[<span class="number">0</span>] != people2[<span class="number">0</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> people2[<span class="number">0</span>] - people1[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> people1[<span class="number">1</span>] - people2[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; people.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.size() &gt; people[i][<span class="number">1</span>])&#123;</span><br><span class="line">                list.add(people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                list.add(list.size(),people[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="665-非递减数列-easy"><a href="#665-非递减数列-easy" class="headerlink" title="665 非递减数列 easy"></a>665 非递减数列 easy</h2><p>第一次看题看错了，看成只移动一个数。这个题是改变一个数！虽然是easy，但是并不一定easy。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/non-decreasing-array/solution/yi-ding-yao-rang-ni-nong-dong-wei-shi-ya-u9te/">网友解答很清晰</a>：本题是要维持一个非递减的数列，所以遇到递减的情况时（nums[i] &gt; nums[i + 1]），要么将前面的元素缩小，要么将后面的元素放大。但是本题唯一的易错点就在这，如果将nums[i]缩小，可能会导致其无法融入前面已经遍历过的非递减子数列；如果将nums[i + 1]放大，可能会导致其后续的继续出现递减；所以要采取贪心的策略，在遍历时，每次需要看连续的三个元素，也就是瞻前顾后，遵循以下两个原则：需要尽可能不放大nums[i + 1]，这样会让后续非递减更困难；如果缩小nums[i]，但不破坏前面的子序列的非递减性；算法步骤:遍历数组，如果遇到递减：还能修改：修改方案1：将nums[i]缩小至nums[i + 1]；修改方案2：将nums[i + 1]放大至nums[i]；不能修改了：直接返回false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//只能修改一次，让数组递增。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkPossibility</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> nums[<span class="number">0</span>] &lt;= nums[<span class="number">1</span>] ? <span class="literal">true</span> : <span class="literal">false</span>;<span class="comment">//一开始第一个数小于第二个数，则拥有一次修改的机会。</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length-<span class="number">1</span> ; i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])&#123;<span class="comment">//开始出现递减情况。i大于后面一个数了</span></span><br><span class="line">              <span class="keyword">if</span>(flag)&#123;<span class="comment">//如果拥有修改机会</span></span><br><span class="line">                  <span class="keyword">if</span>(nums[i+<span class="number">1</span>] &gt;= nums[i-<span class="number">1</span>])&#123;<span class="comment">//如果i的后面一个数比i的前面一个数大的话，就说明他们是递增，让i缩小的话，也没有破坏非递减性，并且不影响i+1后面的序列。</span></span><br><span class="line">                      nums[i] = nums[i+<span class="number">1</span>];<span class="comment">//这时候就让i缩小</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">else</span>&#123;</span><br><span class="line">                      nums[i+<span class="number">1</span>] = nums[i];<span class="comment">//这个情况就是i后面的一个数比i前面的一个数小，但是同时i后面的数还小于i，所以只能让i后面的数扩大为i。</span></span><br><span class="line">                  &#125;</span><br><span class="line">                  flag = <span class="literal">false</span>;<span class="comment">//用掉了唯一的一次修改机会了</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//再出现递减情况，但是已经没有修改机会了，直接返回false。</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//若nums(0) &gt; nums(1)的话，flag是false，且后面没有出现递减，所以已经是可以用修改一次来递增，也就是把第一个数变成第二个数就满足，所以直接返回true。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="167-两数之和2-easy"><a href="#167-两数之和2-easy" class="headerlink" title="167 两数之和2 easy"></a>167 两数之和2 easy</h2><p>注意题目给的数组是非递减顺序排列（也就是总体递增，然后可能有两个相邻的数是相等），所以思路上很简单，两个变量去追踪这个数组，一头一尾巴，如果两数之和小于target，左边就需要移动一位，反之则右边需要移动一位。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;<span class="comment">//一开始根据书上思路写的，超时了~~~可能是暴力解法的原因，而且这个代码尚未验证是否正确。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length-<span class="number">1</span> &amp;&amp; i &lt; j;)&#123;</span><br><span class="line">           <span class="keyword">if</span>(numbers[i] + numbers[j] == target)</span><br><span class="line">           &#123;</span><br><span class="line">               ans[<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">               ans[<span class="number">1</span>] = j+<span class="number">1</span>;</span><br><span class="line">              </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] + numbers[j] &lt; target)&#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] + numbers[j] &gt; target)&#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> numbers.length-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//int[] ans = new int[2];</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="type">int</span>  <span class="variable">sum</span> <span class="operator">=</span> numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i + <span class="number">1</span>, j + <span class="number">1</span>&#125;;<span class="comment">//这样就不用先去定义一个数组了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="88-合并两个有序数组-easy"><a href="#88-合并两个有序数组-easy" class="headerlink" title="88 合并两个有序数组 easy"></a>88 合并两个有序数组 easy</h2><p>题目给的是两个非递减数组，思路是用m,n来指向两个数组的尾巴，还有pos来定位。首先要注意是在数组1的基础上去排，不需要额外开辟一个数组。pos定位在数组1的尾巴，开始对比两个数组的尾巴，哪个大就先复制过去。这里最后要注意，如果数组1复制完了，但是数组2还有，务必要记得继续复制。反之如果数组2复制完了，则不需要操作，因为数组1本身就是非递减，而且返回的数组就是他自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> m-- + n-- -<span class="number">1</span>;<span class="comment">//这样写的话就少了一步，别忘了数组大小和数组位置是相差1.</span></span><br><span class="line">         <span class="keyword">while</span>(m &gt;= <span class="number">0</span> &amp;&amp; n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">             nums1[pos--] = nums1[m] &gt; nums2[n] ? nums1[m--] :nums2[n--];<span class="comment">//注意是哪个大才会自减减哦。不是每次都自减减。</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">             nums1[pos--] = nums2[n--];<span class="comment">//务必不要忘记如果数组2还没复制完这个事！！！！！此时的数组1已经复制完啦！！！</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="142-环形链表2-medium"><a href="#142-环形链表2-medium" class="headerlink" title="142 环形链表2 medium"></a>142 环形链表2 medium</h2><p>这个题涉及了一些数学计算，感谢<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">网友</a>讲解，这里复述一下：设置两个指针，一个为fast，一个为slow，fast每次走2步，slow每次走1步，设链表为a+b个节点，a为抵达环状的步数，b为环状的节点数。没有环状的链表很容易考虑，这里直接讲有环状的情况，也就是fast和slow会相遇：首先可以得到第一个关系式f&#x3D;2s，这个是slow和fast的步数关系。第二个关系式是f&#x3D;s+nb，因为fast比slow快，所以最终一定能追上，这时候呢，其实fast比slow多走了n个环。根据这两个关系，可以得到<mark>f&#x3D;2nb</mark>,<mark>s&#x3D;nb</mark>。接下来我们考虑，一个指针从头走到环状开头走过的步数<mark>k&#x3D;a+nb</mark>，当n为0，也就是你走了a步到了环状的门口，然后n&#x3D;1的话，你相当于绕了一圈环，然后又到了门口。现在有了三个表达式，从head结点走到入环点需要走:a + nb， 而slow已经走了nb（之前推了相遇的时候他们两个的关系），那么slow再走a步就是入环点了,如何知道slow刚好走了a步？fast从新从head开始和slow指针一起走，再相遇时刚好就是a步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>)&#123;<span class="comment">//注意别忘了是两个条件</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="76-最小覆盖子串-hard"><a href="#76-最小覆盖子串-hard" class="headerlink" title="76 最小覆盖子串 hard"></a>76 最小覆盖子串 hard</h2><p>依旧是<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/993501">网友</a>的思路，这个题在于需要考虑不少东西，这里简单描述一下：首先是建立一个128的ASCII列表，第一步先记录t中每个字符的数量。定义好l和r初始位置，还有用count去记录还需要的字符数量，这样就不用每次去查看need中哪个字符还大于0。开始while循环，用r去遍历整个S串，经过每个r的位置去提取字符c，首先判断c在need中的情况，如果是大于0，说明这个字符是符合t串的。然后减去一个count，代表已经找到了一个符合的字符，接下来是need中减去字符c的数量，注意，这里也包括不在t中的字符，不在t的中字符减去自然是为负数，代表这个字符是多余的。然后判断count为0的情况，count为0，代表已经找到符合的子串了，但是题目要求的size是最小的，所以可以缩减范围，当l小于r，并且里面有多余的字符，我们首先在need中加回去，然后移动l，然后开始重置size的大小，注意这时候的start变成新的l。接来下是移动l，看看还有没有更小的窗口，注意这里用start去保存这个开始的位置，而不是直接用l，这是有含义的，因为你的r是要遍历整个S串，这样你才知道哪个窗口是最小的，所以只有当size更小时候，我们才去更新更新start值，再加上size大小，就可以找到最小的串位置。这时候你无需当心l和r移动的位置了。务必务必注意，移动l的时候，请记得更新need和count以及l！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; t.length() ; i++)&#123;</span><br><span class="line">        need[t.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, start = <span class="number">0</span>, size = Integer.MAX_VALUE, count = t.length();</span><br><span class="line">    <span class="keyword">while</span> (r &lt; s.length())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">        <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        need[c]--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">while</span>(l &lt; r &amp;&amp; need[s.charAt(l)] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">               need[s.charAt(l)]++;</span><br><span class="line">               l++;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> (r -l + <span class="number">1</span> &lt; size)&#123;</span><br><span class="line">               size = r - l + <span class="number">1</span>;</span><br><span class="line">               start = l;</span><br><span class="line">           &#125; </span><br><span class="line">           need[s.charAt(l)]++;</span><br><span class="line">           count++;</span><br><span class="line">           l++;</span><br><span class="line">       &#125;</span><br><span class="line">       r++;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + size);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="633-平方数之和-medium"><a href="#633-平方数之和-medium" class="headerlink" title="633 平方数之和 medium"></a>633 平方数之和 medium</h2><p>和167的很像，这里<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-square-numbers/solution/shuang-zhi-zhen-de-ben-zhi-er-wei-ju-zhe-ebn3/">网友</a>非常详细说明为什么i++和j–不会错过答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judgeSquareSum</span><span class="params">(<span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j =(<span class="type">long</span>) Math.sqrt(c);<span class="comment">//如果直接写成c，会超时。理论上也是应该对的。</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> i*i + j*j;</span><br><span class="line">       <span class="keyword">if</span>( sum == c )&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>( sum &lt; c )&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           j--;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="680-验证回文字符串2-easy"><a href="#680-验证回文字符串2-easy" class="headerlink" title="680 验证回文字符串2 easy"></a>680 验证回文字符串2 easy</h2><p>这个题虽然是简单题，但是还是看了<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/valid-palindrome-ii/solution/cong-liang-ce-xiang-zhong-jian-zhao-dao-bu-deng-de/403606">网友</a>思路：用双指针去对比，一个在头l，一个在尾巴r，当遇到不相等的情况，我们可以让l加1个位置，或者让r减去一个位置，因为题目说了可以最多删除一个字符，然后再用一个函数去对比子字符串。这里我一开始想到的是用一个计数器去判断删除的次数，后来发现其实不需要，比如abxbgga，要删除两次才行，你只要仔细看代码，发现只要一次之后不行就直接false了，所以不用考虑加一个计数器的问题，那么删除一个字符是体现在r-1或者l+1上</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class="line">            <span class="keyword">return</span> judegesub(s, l+<span class="number">1</span>, r) || judegesub(s, l, r-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judegesub</span><span class="params">(String s, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(l) != s.charAt(r))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="524-通过删除字母匹配到字典里最长单词-medium"><a href="#524-通过删除字母匹配到字典里最长单词-medium" class="headerlink" title="524 通过删除字母匹配到字典里最长单词 medium"></a>524 通过删除字母匹配到字典里最长单词 medium</h2><p>这个题我一开始考虑的是，首先跟上一个题的区别是，这个题的意思是可以删除好几个元素，然后第二个不同的是，这个题有多个词，是不是要用暴力算法一个个去看？看了官方解答后，发现被上一题绕进去了。大概重复下解法：用双指针思路，i和j分别指向t(字典中的词)和s的第一个字母，注意这里是每个字典的词都会遍历，然后如果匹配，则i和j同时移动一位，如果不匹配，i不动，j+1。直到最后i要是等于这个词的长度的话，就代表全部匹配到。注意这里是长度，长度和单词最后一个字符位置是相差1的。题目中说要长度最长和序号最低的。所以自然有一个长度对比以及序号对比，序号对比是用compareTo函数，这个是对比ASCII对比，也就是序号在前的话是小于0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//知识点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String t : dictionary) &#123;</span><br><span class="line">          System.out.print(t);</span><br><span class="line">          System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入是[&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]这里会依次输出ale apple monkey plea </span></span><br><span class="line"></span><br><span class="line">关于compareTo:</span><br><span class="line">返回值是整型，它是先比较对应字符的大小(ASCII码顺序)如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的长度差值，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。</span><br><span class="line"></span><br><span class="line">如果参数字符串等于此字符串，则返回值 <span class="number">0</span>；</span><br><span class="line">如果此字符串小于字符串参数，则返回一个小于 <span class="number">0</span> 的值；</span><br><span class="line">如果此字符串大于字符串参数，则返回一个大于 <span class="number">0</span> 的值。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findLongestWord</span><span class="params">(String s, List&lt;String&gt; dictionary)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String t : dictionary) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; t.length() &amp;&amp; j &lt; s.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    ++i;</span><br><span class="line">                &#125;</span><br><span class="line">                ++j;<span class="comment">//注意这里，如果匹配的话，j是在这里++，而不是在上面的if语句，因为这里还有一个就是如果不匹配的话，j也要++，而这时候i不变，所以这个写法可以同时满足两个条件</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == t.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.length() &gt; res.length() || (t.length() == res.length() &amp;&amp; t.compareTo(res) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                    res = t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="69-Sqrt-x-easy"><a href="#69-Sqrt-x-easy" class="headerlink" title="69 Sqrt(x) easy"></a>69 Sqrt(x) easy</h2><p>这个题是看了官方解法，其实思路就是二分法，每次寻找中间值，如果中间值的平方小于输入值，则把左边的边界设置为mid+1，反之如果大于输入值，则把右边界设置为mid-1，这里注意一个问题就是mid * mid前面要加long，不然超过范围。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>) mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="34-在排序数组中查找元素的第一个和最后一个位置-medium"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-medium" class="headerlink" title="34 在排序数组中查找元素的第一个和最后一个位置 medium"></a>34 在排序数组中查找元素的第一个和最后一个位置 medium</h2><p>这里有一个网友的<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/tu-jie-er-fen-zui-qing-xi-yi-dong-de-jia-ddvc/">二分法模板</a>，关于这个题，分了两步，首先是寻找第一个target，循环内部条件是num[mid]大于等于target，然后用模板1，寻找最后出现的target，用模板2。至于为什么分开模板1和2，有个网友解释很清楚：因为取左边第一个target时，当nums[mid]&#x3D;&#x3D;target时，中间位置的右边元素一定不是target出现的第一个位置，所以下次搜索区间是[left,mid],right&#x3D;mid;取最后一个target时，当nums[mid]&#x3D;&#x3D;target时，中间位置的左边元素一定不是target出现的最后一个位置，所以下次搜索区间是[mid，right],left&#x3D;mid。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板2</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ( l + r + <span class="number">1</span> ) /<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总结归纳：当l=mid时，mid=(l+r+1)/2，当l=mid+1，mid=(l+r)/2，至于为什么请看网友解释，这个题要多次理解。</span></span><br><span class="line"><span class="comment">这里复制了网友的解释：什么时候用模板1，什么时候用模板2？</span></span><br><span class="line"><span class="comment">假设初始时我们的二分区间为[l,r]，每次二分缩小区间时，如果左边界l要更新为 l = mid，此时我们就要使用模板2，让 mid = (l + r + 1)/ 2，否则while会陷入死循环。如果左边界l更新为l = mid + 1,此时我们就使用模板1，让mid = (l + r)/2。因此，模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l = mid，那么在计算mid时需要加上1，否则如果写完之后发现是l = mid + 1，那么在计算mid时不能加1。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;<span class="comment">//上来就要记住这个。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid ;<span class="comment">//比目标值大，则寻找左区间，右边变为mid，左边不动。</span></span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;<span class="comment">//比目标值小，寻找右区间，左边变成mid+1，右边不动。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;<span class="comment">//这个特别容易忘记的。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> r;</span><br><span class="line">        l = <span class="number">0</span>; r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid ;<span class="comment">//比目标值小，寻找右区间，左边变成mid，右边不变。</span></span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;<span class="comment">//比目标值大，寻找左区间，右边变成mid-1，左边不变。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;L,r&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="81-搜索旋转排序数组-II-medium"><a href="#81-搜索旋转排序数组-II-medium" class="headerlink" title="81 搜索旋转排序数组 II medium"></a>81 搜索旋转排序数组 II medium</h2><p>找数组的目标数，这个题就是说本来的数组是增序的，但是现在相当于在中间断开，然后再连起来，就变成一个旋转数组。所以，旋转数组的特性的有一部分是增序的。先依旧找到中点位置，后面解释看代码。这个<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/">coder</a>把一些情况得很清楚。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">本题是需要使用二分查找，怎么分是关键，举个例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一类</span></span><br><span class="line"><span class="comment">1011110111 和 1110111101 这种。此种情况下 nums[start] == nums[mid]，分不清到底是前面有序还是后面有序，此时 start++ 即可。相当于去掉一个重复的干扰项。</span></span><br><span class="line"><span class="comment">第二类</span></span><br><span class="line"><span class="comment">22 33 44 55 66 77 11 这种，也就是 nums[start] &lt; nums[mid]。此例子中就是 2 &lt; 5；</span></span><br><span class="line"><span class="comment">这种情况下，前半部分有序。因此如果 nums[start] &lt;=target&lt;nums[mid]，则在前半部分找，否则去后半部分找。</span></span><br><span class="line"><span class="comment">第三类</span></span><br><span class="line"><span class="comment">66 77 11 22 33 44 55 这种，也就是 nums[start] &gt; nums[mid]。此例子中就是 6 &gt; 2；</span></span><br><span class="line"><span class="comment">这种情况下，后半部分有序。因此如果 nums[mid] &lt;target&lt;=nums[end]。则在后半部分找，否则去前半部分找</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[start] == nums[mid])&#123;<span class="comment">//因为数组会存在重复数字，如果中点和左端相等，我们不能确定在左区间全部相等，还是右边区间全部相等，这种情况，可以把start右移动一个，当然这种操作我们不能说是完全的二分法，这个题只是部分地方用到二分法。</span></span><br><span class="line">                start++;<span class="comment">//无法判断哪个区间是增序的</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt;= nums[end]) &#123;<span class="comment">//右区间是增序的</span></span><br><span class="line">                <span class="keyword">if</span> (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) &#123;<span class="comment">//然后在右区间内判断target，用二分法。target在mid和end中间，这里需要注意，target是要小于等于end。我觉得要这么去想，你想如果都等于mid，那肯定是直接返回true，所以有mid比较这边是开区间</span></span><br><span class="line">                    start = mid + <span class="number">1</span>;<span class="comment">//就让start移动到mid右边</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    end = mid -<span class="number">1</span>;<span class="comment">//反之，让end移动到mid左边</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//这个情况则是左区间增序</span></span><br><span class="line">                <span class="keyword">if</span> (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) &#123;<span class="comment">//这里需要注意，target是要大于等于start</span></span><br><span class="line">                    end = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    start = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="154-寻找旋转排序数组中的最小值-II-hard"><a href="#154-寻找旋转排序数组中的最小值-II-hard" class="headerlink" title="154 寻找旋转排序数组中的最小值 II hard"></a>154 寻找旋转排序数组中的最小值 II hard</h2><p>这个题也是旋转数组，和上个题的区别是，1.上个题是找target，这个题是找最小值。2.这个题旋转多次。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/">这个作者解释得不错</a>，把作者思路拷贝到了下面了，注意一下这个题，旋转后每个数字的序号保持原来不变，也就是原来是0位置，旋转后序号还是0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    -思路-</span></span><br><span class="line"><span class="comment">    旋转数组肯定将nums分为两个有序的数组，分为别nums1和nums2。并且假设nums1中的元素均大于等于nums2中的元素</span></span><br><span class="line"><span class="comment">    那么我们要求的元素就是nums2的首元素</span></span><br><span class="line"><span class="comment">    --步骤--</span></span><br><span class="line"><span class="comment">    如果nums[mid] &gt; nums[right],说明此时的mid严格的在nums1当中。（这时候最小值在[mid,right]上？所以把区间缩到这来，我理解的），那么nums2的首元素设为i的话，就应当是：mid &lt; i &lt;= right。</span></span><br><span class="line"><span class="comment">    取left = mid + 1;附其他解释：当 nums[mid] &gt; nums[right]时，mid一定在第 1 个排序数组中，i 一定满足 mid &lt; i &lt;= right，因此执行 left = mid + 1；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果nums[mid] &lt; nums[right],说明此时的mid严格的在nums2当中。（这时候最小值在[left,mid]上？所以把区间缩到这来，我理解的）也就是：mid &lt;= i &lt; right</span></span><br><span class="line"><span class="comment">    取right = mid(注意这里没有mid-1)；附其他作者解释：当 nums[mid] &lt; nums[right] 时，mid 一定在第 2 个排序数组中，i一定满足 left &lt; i &lt;= mid，因此执行 right = mid；</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果nums[mid] == nums[right],细分为三种情况。</span></span><br><span class="line"><span class="comment">        情况一：[1,1,1,1,1,1,1,1]</span></span><br><span class="line"><span class="comment">        情况二：[4,5,6,7,1,1,1,1,1,1]</span></span><br><span class="line"><span class="comment">        情况二：[4,5,6,7,0,1,1,1,1,1]</span></span><br><span class="line"><span class="comment">    取right--便可，这个很关键！！！！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    另外一个作者解释了为什么这样：</span></span><br><span class="line"><span class="comment">    我们采用 right = right - 1 解决此问题，证明：</span></span><br><span class="line"><span class="comment">    此操作不会使数组越界：因为迭代条件保证了 right &gt; left &gt;= 0；</span></span><br><span class="line"><span class="comment">    此操作不会使最小值丢失：假设 nums[right]是最小值，有两种情况：</span></span><br><span class="line"><span class="comment">    若 nums[right]是唯一最小值：那就不可能满足判断条件 nums[mid] == nums[right]，因为 mid &lt; right（left != right 且 mid = (left + right) // 2 向下取整）；</span></span><br><span class="line"><span class="comment">    若 nums[right]不是唯一最小值，由于 mid &lt; right 而 nums[mid] == nums[right]，即还有最小值存在于 [left, right - 1][left,right−1] 区间，因此不会丢失最小值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">作者：jyd</span></span><br><span class="line"><span class="comment">链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/154-find-minimum-in-rotated-sorted-array-ii-by-jyd/</span></span><br><span class="line"><span class="comment">来源：力扣（LeetCode）</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[right]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right]; <span class="comment">//貌似nums[left]也是可以的。其实看了下，最后left=mid+1也就是等于right，所以这样也就是两种写法都是一样。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="540-有序数组中的单一元素-meidum"><a href="#540-有序数组中的单一元素-meidum" class="headerlink" title="540. 有序数组中的单一元素 meidum"></a>540. 有序数组中的单一元素 meidum</h2><p>这个题是找到唯一的单身狗，注意题目是升序的，不过貌似与升序没关系。这里先整理下官方的清晰解答：因为这个模块是讲二分法，所以不讲解暴力算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先要知道，这个数组一定是奇数个，因为只有一个单身狗！</span></span><br><span class="line"><span class="comment">用 halvesAreEven = (right - mid) % 2 == 0来判断哪一侧元素为奇数，因为单身狗肯定在这一侧。</span></span><br><span class="line"><span class="comment">情况1：mid 和 mid+1是同元素。然后mid元素把两侧都分为偶数个，当我们把mid+1拿掉后，右侧就变成奇数个了，也就是右侧肯定存在单身狗，设置left = mid + 2</span></span><br><span class="line"><span class="comment">情况2；mid 和 mid+1是同元素。然后mid元素把两侧都分为奇数个，当我们把mid+1拿掉后，右侧是偶数个，所以左侧存在单身狗，设置right = mid - 1 </span></span><br><span class="line"><span class="comment">情况3：mid 和 mid-1是同元素。然后mid元素把两侧都分为偶数个，当我们把mid-1拿掉后，左侧就是奇数个了，所以左侧存在单身狗，设置right = mid - 2</span></span><br><span class="line"><span class="comment">情况4：mid 和 mid-1是同元素。然后mid元素把两侧都分为奇数个，当我们把mid-1拿掉后，右侧就存在单身狗，所以left = mid + 1</span></span><br><span class="line"><span class="comment">首先判断mid和左边还是右边的元素相等，然后通过halvesAreEven判断左右两侧是奇还是偶。</span></span><br><span class="line"><span class="comment">这里只举例情况1和2，因为这是放在一起的。现在已经知道了mid和mid+1相等，然后再想，如果mid把两侧分为了偶数个(单纯讲个数，与数组位置无关)，也就是mid的位置是一个偶数(数组从0计算)，然后整个数组肯定是奇数个，也就是最后一个数的位置也是偶数，所以当halvesAreEven为true，就说明符合情况1，反之符合情况2。</span></span><br><span class="line"><span class="comment">注意写代码的时候别忘了mid就是单身狗的情况。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">下面这个方法也是二分，但是仅对偶数索引进行二分搜索，比上面的方法简洁，而且不用单独考虑mid是单身狗的情况，因为else就是包含了mid是单身狗或者左侧存在单身狗。</span></span><br><span class="line"><span class="comment">然后就是简洁点，整理下上面的思路，我们确保mid是偶数的位置，如果是奇数就减去1，然后检查 mid 的元素是否与其后面的索引相同。如果相同，则我们知道 mid 不是单个元素。</span></span><br><span class="line"><span class="comment">且单个元素在 mid 之后。则我们将 left 设置为 mid + 2。</span></span><br><span class="line"><span class="comment">如果不是，则我们知道单个元素位于 mid，或者在 mid 之前。我们将 right 设置为 mid。</span></span><br><span class="line"><span class="comment">一旦 left == right，则当前搜索空间为 1 个元素，那么该元素为单个元素，我们将返回它。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">知识点：int mid = left + (right - left) / 2;</span></span><br><span class="line"><span class="comment">为什么前面还要加left?因为防止超出整型数据溢出。可以看看前面的题有没有这种情况！！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid % <span class="number">2</span> == <span class="number">1</span> ) mid--;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[right];<span class="comment">//left也可以，第一次写的时候写成了mid，先不说结果对不对，这里语法就存在问题，因为mid在while里面，所以系统会检测不到mid，是一个局部变量。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-寻找两个正序数组的中位数-hard"><a href="#4-寻找两个正序数组的中位数-hard" class="headerlink" title="4 寻找两个正序数组的中位数 hard"></a>4 寻找两个正序数组的中位数 hard</h2><p>这个题虽然看上去是可以合并起来去找，但是，由于有时间复杂度的要求，所以用二分法比较好，坦白说，确实hard。详细解释<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-2/">点击这里看解法三</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用的代码是官方的，但是上面说的解释更清楚。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totallength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totallength % <span class="number">2</span> == <span class="number">1</span>)&#123;<span class="comment">//两个数组长度和为奇数情况</span></span><br><span class="line">           <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totallength / <span class="number">2</span>;<span class="comment">//注意totallength是个数，而不是数组中的序号(从0开始)。</span></span><br><span class="line">           <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//两个数组长度合为偶数情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totallength / <span class="number">2</span> -<span class="number">1</span>, midIndex2 =totallength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//下面是官方写的</span></span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;<span class="comment">//当k剩下一个的时候，也就是比较剩下哪个数谁比较小。</span></span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//正常情况 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;<span class="comment">// k/2-1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;<span class="comment">// k/2-1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1] ,pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k = k -(newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = k -(newIndex2 - index2 + <span class="number">1</span>);<span class="comment">//加1是因为要去掉pivot这个元素</span></span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//这个是while语句的结束</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于这个题实在是费脑，这里详细举例子，按照代码思路一步步来</span></span><br><span class="line">nums1:<span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span></span><br><span class="line">nums2:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">开始计算： </span><br><span class="line">length1=<span class="number">4</span>,length2=<span class="number">9</span></span><br><span class="line">totallength=<span class="number">13</span></span><br><span class="line">判断为奇数，midIndex=<span class="number">6</span> 传入到子函数(nums1，nums2,<span class="number">6</span>+<span class="number">1</span>)<span class="comment">//也就是第7个数是中位数</span></span><br><span class="line"></span><br><span class="line">下面是子函数循环情况</span><br><span class="line"></span><br><span class="line">下面说的 排 是指两个数组合并起来，从小到大排第几个的意思</span><br><span class="line">length1=<span class="number">4</span>,length2=<span class="number">9</span></span><br><span class="line">正常情况</span><br><span class="line">第一轮<span class="keyword">while</span></span><br><span class="line">half=<span class="number">7</span>/<span class="number">2</span>=<span class="number">3</span></span><br><span class="line">newIndex1=<span class="number">3</span>-<span class="number">1</span>=<span class="number">2</span>,newIndex2=<span class="number">3</span>-<span class="number">1</span>=<span class="number">2</span><span class="comment">//比较nums1[k/2-1],nums2[k/2-1]的元素，本题也就是nums1[2],nums2[2]</span></span><br><span class="line"></span><br><span class="line">[pivot]元素</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> [<span class="number">4</span>] <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> [<span class="number">3</span>] <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>    可以看出nums2[<span class="number">2</span>]的更小，把nums2[<span class="number">2</span>]及其前面元素全部去掉，然后更新index2和k</span><br><span class="line"></span><br><span class="line">这里需要理解为什么更新k和index2，我们要找的数是排序第七个(不是从<span class="number">0</span>计算)的数，然后分别比较两个数组的nums[k/<span class="number">2</span>-<span class="number">1</span>]</span><br><span class="line">nums1 中小于等于 pivot1 的元素有 nums1[<span class="number">0</span> .. k/<span class="number">2</span>-<span class="number">2</span>] 共计 k/<span class="number">2</span>-<span class="number">1</span> 个，本题也就是<span class="number">2</span>个</span><br><span class="line">nums2 中小于等于 pivot2 的元素有 nums1[<span class="number">0</span> .. k/<span class="number">2</span>-<span class="number">2</span>] 共计 k/<span class="number">2</span>-<span class="number">1</span> 个，本题也就是<span class="number">2</span>个</span><br><span class="line">然后取两个数组中比较小的pivot，本题是num2[<span class="number">2</span>],可以推导，两个数组中小于等于 pivot 的元素共计不会超过 (k/<span class="number">2</span>-<span class="number">1</span>) + (k/<span class="number">2</span>-<span class="number">1</span>) &lt;= k-<span class="number">2</span> 个，也就是全部元素合并后小于等于nums2[<span class="number">2</span>]元素的不超过<span class="number">5</span>个，如果按照等式左边是为<span class="number">4</span>个，因为是整除，如果按照等式右边就直接是<span class="number">5</span>个。</span><br><span class="line">这样的话，即便取pivot本身最大也只能是第 k-<span class="number">1</span> 小的元素，也就是<span class="number">6</span>，但是按照上一行的分析，pivot元素是排第<span class="number">5</span>或者第<span class="number">6</span>，本题的话实际是排第<span class="number">5</span>。</span><br><span class="line">总之还不是第七个我们要找的元素。那么可以完全排除nums[<span class="number">2</span>]和左边的元素，这时候就要更新k和index2</span><br><span class="line">k更新：因为本身要找第<span class="number">7</span>个元素，现在已经排除了<span class="number">3</span>个元素了，所以k=<span class="number">7</span>-<span class="number">3</span>=<span class="number">4</span>，也就是在剩下的数组中找排第四个的元素，具体写法是<span class="number">7</span>-（<span class="number">2</span>-<span class="number">0</span>+<span class="number">1</span>)=<span class="number">4</span></span><br><span class="line">index2更新： index2=<span class="number">2</span>+<span class="number">1</span>=<span class="number">3</span>，也就是从nums2[<span class="number">3</span>]开始</span><br><span class="line">index1依旧为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">第二轮<span class="keyword">while</span>   </span><br><span class="line">half=<span class="number">4</span>/<span class="number">2</span>=<span class="number">2</span></span><br><span class="line">newIndex1=<span class="number">0</span>+<span class="number">2</span>-<span class="number">1</span>=<span class="number">1</span>,newIndex2=<span class="number">3</span>+<span class="number">2</span>-<span class="number">1</span>=<span class="number">4</span></span><br><span class="line">下面标记|，代表左边的元素也就消除。</span><br><span class="line"><span class="number">1</span> [<span class="number">3</span>] <span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | <span class="number">4</span> [<span class="number">5</span>] <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">经过比较后，nums1[<span class="number">1</span>]及其左边消除</span><br><span class="line">k更新：因为本身要找第<span class="number">4</span>个元素，现在已经排除了<span class="number">2</span>个元素了，所以k=<span class="number">4</span>-<span class="number">2</span>=<span class="number">2</span>，也就是在剩下的数组中找排第二个的元素，具体写法是<span class="number">4</span>-（<span class="number">1</span>-<span class="number">0</span>+<span class="number">1</span>)=<span class="number">2</span></span><br><span class="line">index1更新： index1=<span class="number">1</span>+<span class="number">1</span>=<span class="number">2</span>，也就是从nums1[<span class="number">2</span>]开始</span><br><span class="line">index2依旧为<span class="number">3</span></span><br><span class="line"></span><br><span class="line">第三轮<span class="keyword">while</span></span><br><span class="line">half=<span class="number">2</span>/<span class="number">2</span>=<span class="number">1</span></span><br><span class="line">newIndex1=<span class="number">2</span>+<span class="number">1</span>-<span class="number">1</span>=<span class="number">2</span>,newIndex2=<span class="number">3</span>+<span class="number">1</span>-<span class="number">1</span>=<span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> | [<span class="number">4</span>] <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> | [<span class="number">4</span>] <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">这里pivot元素相等，我们就假设上面的<span class="number">4</span>大于下面的<span class="number">4</span>，由于两个数相等，所以我们无论去掉哪个数组中的都行，因为去掉 <span class="number">1</span> 个总会保留 <span class="number">1</span> 个的，所以没有影响。</span><br><span class="line">经过比较后，nums2[<span class="number">3</span>]及其左边消除。</span><br><span class="line">k更新：因为本身要找第<span class="number">2</span>个元素，现在已经排除了<span class="number">1</span>个元素了，所以k=<span class="number">2</span>-<span class="number">1</span>=<span class="number">1</span>，也就是在剩下的数组中找排第二个的元素，具体写法是<span class="number">2</span>-（<span class="number">0</span>-<span class="number">0</span>+<span class="number">1</span>)=<span class="number">1</span></span><br><span class="line">index2更新： index2=<span class="number">3</span>+<span class="number">1</span>=<span class="number">4</span>，也就是从nums2[<span class="number">4</span>]开始</span><br><span class="line">index1依旧为<span class="number">2</span></span><br><span class="line"></span><br><span class="line">第四轮<span class="keyword">while</span></span><br><span class="line">k已经等于<span class="number">1</span>了，直接找剩下比较小的数就行。</span><br><span class="line"><span class="number">1</span> <span class="number">3</span> | [<span class="number">4</span>] <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> | [<span class="number">5</span>] <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">答案就是<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当然还有注意边界的情况，本题没有涉及。</span><br><span class="line">所谓边界的问题,也就是有可能其中一个数组过小，然后进行更新的时候会发现越界，这时候也就是这个小的数组数组全部已经小于第K个数据，然后我们之后关注大的数组找到k就行。</span><br></pre></td></tr></table></figure>
<h1 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h1><p><img src="/images/leetcode-java/4.jpg" alt="排序算法"></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本代码是可执行代码，后面的排序算法可以直接用在本模板调用。</span></span><br><span class="line"><span class="comment">//快速排序就是每次把第一个数选为枢轴元素，然后左右扫描，右边扫描比它小的交换，左边扫描比它大的交换，最后放到正确的位置，最终左边的元素都比它小，右边的元素都比它大，然后左右递归。</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">sort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">99</span>,<span class="number">77</span>,<span class="number">44</span>&#125;;<span class="comment">//初始化数组时用new与不用new是没区别的</span></span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        quick_sort(arr, <span class="number">0</span>, size);<span class="comment">//实现快速排序</span></span><br><span class="line">        <span class="comment">//insertion_sort(arr,size);//实现插入排序</span></span><br><span class="line">        <span class="comment">//merge_sort(arr, 0, size, temp);//实现归并排序</span></span><br><span class="line">        <span class="comment">//bubble_sort(arr, 0, size);//实现冒泡排序</span></span><br><span class="line">        <span class="comment">//select_sort(arr,size);实现选择排序</span></span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;<span class="comment">//左闭右闭区间，也就是right一开始输入的是size</span></span><br><span class="line">        <span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> left, last = right - <span class="number">1</span>, key = arr[first];</span><br><span class="line">        <span class="keyword">while</span> (first &lt;last) &#123;</span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; arr[last] &gt;= key) &#123;<span class="comment">//右边扫描</span></span><br><span class="line">                --last;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[first] = arr[last];</span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; arr[first] &lt;= key) &#123;<span class="comment">//左边扫描</span></span><br><span class="line">                ++first;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[last] = arr[first];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[first] = key;<span class="comment">//把枢轴元素放到正确的位置</span></span><br><span class="line">        quick_sort(arr, left, first);<span class="comment">//左边递归</span></span><br><span class="line">        quick_sort(arr, first + <span class="number">1</span>, right);<span class="comment">//右边递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第二个数开始，只要比前面小就一直交换。这样每轮的前i个数都是从小到大排好序，就好像插队一样，一直插。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertion_sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; j--) &#123;<span class="comment">//别忘了防止越界的问题，j&gt;0。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j-<span class="number">1</span>];</span><br><span class="line">            arr[j-<span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每次把未排序中最小的数选出来，然后和前面未排序第一个数交换。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">select_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> small;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; right - <span class="number">1</span>; i++) &#123;<span class="comment">//这里写成right也是没有问题的，但是right的话理论上来说多做了一步无用功</span></span><br><span class="line">        small = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[small]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[small];</span><br><span class="line">                arr[small] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归并排序采用了分治的思想。将数字分成许多小块，每块排序，然后再把块逐步合并起来。</span></span><br><span class="line"><span class="comment">重点：最终合并的时候需要一个临时数组来存储合并数据。合并的时候左右两边是两个排好序的数组，现在要把它们组合起来。关键点就在于判断每一次放入临时数组的是左侧还是右侧的数据。</span></span><br><span class="line"><span class="comment">first和second代表左右侧</span></span><br><span class="line"><span class="comment">如果左侧比右侧小，而且此时两个数组都没越界，左侧的数输入到temp。</span></span><br><span class="line"><span class="comment">如果左侧越界，那么右侧读入。</span></span><br><span class="line"><span class="comment">如果右侧越界，那么左侧读入。</span></span><br><span class="line"><span class="comment">综合起来，读入左侧数据的条件即为右侧越界或者左侧没越界且左侧比右侧小。</span></span><br><span class="line"><span class="comment">最后再改变nums</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> left, <span class="type">int</span> right, vector&lt;<span class="type">int</span>&gt; &amp;temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//C++版本</span></span><br><span class="line">    <span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;<span class="comment">//寻找中间数的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, left, mid, temp);<span class="comment">//左侧递归</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, mid, right, temp);<span class="comment">//右侧递归</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> first = left, second = mid, i = left;</span><br><span class="line">   <span class="keyword">while</span> (first &lt; mid || second &lt; right) &#123;   <span class="comment">//first是左侧边界开始，second是右侧边界开始</span></span><br><span class="line">    <span class="keyword">if</span> (second &gt;= r || (nums[first] &lt;= nums[second] &amp;&amp; first &lt; mid)) &#123;<span class="comment">//右侧越界或者是 左侧没有越界，并且左侧的first位置比右侧的second位置小</span></span><br><span class="line">        temp[i++] = nums[first++];<span class="comment">//那就左侧写入temp</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        temp[i++] = nums[second++];</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;<span class="comment">//左闭右开区间哦，所以right进来是size</span></span><br><span class="line">    <span class="keyword">if</span> (left + <span class="number">1</span> &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    merge_sort(arr, left, mid, temp);<span class="comment">//别忘了左闭右开区间</span></span><br><span class="line">    merge_sort(arr, mid, right, temp);</span><br><span class="line">    <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> left, second = mid, i = left;</span><br><span class="line">    <span class="keyword">while</span> (first &lt; mid || second &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (second &gt;= right || (arr[first] &lt;= arr[second] &amp;&amp; first &lt; mid)) &#123;</span><br><span class="line">            temp[i++] = arr[first++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = arr[second++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt; right; i++) &#123;</span><br><span class="line">        arr[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面画图理解递归是怎么操作的。<br><img src="/images/leetcode-java/4-4.jpg" alt="归并排序"></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> right)</span> &#123;<span class="comment">//每一轮把最大的一个数沉下去，下一轮就可以不用比较前一轮最后一个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; right; i++) &#123;<span class="comment">//这个是从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; right - i + <span class="number">1</span>; j++) &#123;<span class="comment">//不用再比较前一轮的最后一个数，size-i+1</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;<span class="comment">//因为和前一个比较，所以一开始的i起始位置是1</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="215-数组中的第K个最大元素-medium"><a href="#215-数组中的第K个最大元素-medium" class="headerlink" title="215 数组中的第K个最大元素 medium"></a>215 数组中的第K个最大元素 medium</h2><p>这个题结合1738来看。思路：寻找第K个大的元素，可以用快速排序法，快速排序就是每次选择一个枢轴元素，然后比他小的在左边，比他大的在右边，最终可以确定枢轴元素的最终位置。对比这个位置和第K大的位置，如果比这个位置小，就在左边递归，反之右边递归。需要注意一个点，就是选择枢轴元素要随机选，不然会遇到极端案例，导致时间复杂度高。当然本题实际执行只考虑了比枢轴元素大的数以及把大的元素放在左边，是为了符合题目第k大的元素，注意本题解法也是一开始把枢轴元素放在最右边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Math.random()*(n-m)+m，生成大于等于m小于n的随机数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, k - <span class="number">1</span>, nums.length - <span class="number">1</span>);<span class="comment">//第k大的位置也就是数组中k-1的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> kth, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curPartition</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> (curPartition == kth) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[curPartition];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curPartition &lt; kth) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(arr, curPartition + <span class="number">1</span>, kth, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(arr, left, kth, curPartition - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> left + (<span class="type">int</span>)(Math.random() * (right - left + <span class="number">1</span>));<span class="comment">//生成大于等于left小于等于right的随机数</span></span><br><span class="line">        swap(arr, pivotIndex, right);<span class="comment">//先把随机抽中的数与最右边的数交换。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left - <span class="number">1</span>;<span class="comment">//把index初始化，一开始应该是-1。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;<span class="comment">//在区间范围内寻找</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= arr[right]) &#123;<span class="comment">//因为这个题说找最大的第k个数，所以只需要关注比这个枢轴元素大的数</span></span><br><span class="line">                index += <span class="number">1</span>;<span class="comment">//因为index一开始是-1</span></span><br><span class="line">                swap(arr, index, i);<span class="comment">//出现大于枢轴元素的数，就从左到右开始放。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        index += <span class="number">1</span>;<span class="comment">//index加1，是为了下一步操作，把枢轴元素放到正确的位置</span></span><br><span class="line">        swap(arr, index, right);<span class="comment">//结束这个步骤，枢轴元素左边都是大于它的数，右边都是小于它的数</span></span><br><span class="line">        <span class="keyword">return</span> index;<span class="comment">//返回随机抽中枢轴元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写法2，自我感觉这种写法更好看</span></span><br><span class="line"><span class="comment">    private int partition(int[] arr, int left, int right) &#123;</span></span><br><span class="line"><span class="comment">        int pivotIndex = left + (int)(Math.random() * (right - left + 1));</span></span><br><span class="line"><span class="comment">        swap(arr, pivotIndex, right);</span></span><br><span class="line"><span class="comment">        int index = left;//这里改变了</span></span><br><span class="line"><span class="comment">        for (int i = left; i &lt; right; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (arr[i] &gt;= arr[right]) &#123;</span></span><br><span class="line"><span class="comment">                swap(arr, index, i);</span></span><br><span class="line"><span class="comment">                index += 1;//这里改变了</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        //这里删除了</span></span><br><span class="line"><span class="comment">        swap(arr, index, right);</span></span><br><span class="line"><span class="comment">        return index;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个版本就是我们平时理解的快速排序。但是这个版本每次跑起来的速度和占用内存都不如上面那个好。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, k - <span class="number">1</span>, nums.length - <span class="number">1</span>);<span class="comment">//第k大的位置也就是数组中k-1的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> kth, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curPartition</span> <span class="operator">=</span> partition(arr, left, right);</span><br><span class="line">        <span class="keyword">if</span> (curPartition == kth) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr[curPartition];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curPartition &lt; kth) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(arr, curPartition + <span class="number">1</span>, kth, right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(arr, left, kth, curPartition - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> left + (<span class="type">int</span>)(Math.random() * (right - left + <span class="number">1</span>));<span class="comment">//生成大于等于left小于等于right的随机数</span></span><br><span class="line">        swap(nums, pivotIndex, left);<span class="comment">//先把随机抽中的数与最右边的数交换。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> left, last = right, key = nums[first];<span class="comment">//注意这里是last = right ，而不是right-1，因为上面已经处理好边界是lenght-1</span></span><br><span class="line">        <span class="keyword">while</span> (first &lt; last) &#123;</span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[last] &lt;= key) &#123;<span class="comment">//这里是从右边扫描，小于的不管</span></span><br><span class="line">                --last;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[first] = nums[last];<span class="comment">//大于的就把这个数放到前面，这样可以符合题目第K大的条件</span></span><br><span class="line">            <span class="keyword">while</span> (first &lt; last &amp;&amp; nums[first] &gt;= key) &#123;</span><br><span class="line">                ++first;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[last] = nums[first];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[first] = key;</span><br><span class="line">        <span class="keyword">return</span> first;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="347-前K个高频元素-桶排序-medium"><a href="#347-前K个高频元素-桶排序-medium" class="headerlink" title="347 前K个高频元素(桶排序) medium"></a>347 前K个高频元素(桶排序) medium</h2><p>首先用hash来创建一个key，value(频率)对应。然后再创建一个list，把相同频率的放在一个位置。最后从后往前面取出前k个来。也就是桶的思想。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">知识点</span></span><br><span class="line"><span class="comment">1.LinkedHashMap继承于HashMap,是基于HashMap和双向链表实现的</span></span><br><span class="line"><span class="comment">2.HashMap无序，LinkedHashMap有序，分为插入顺序和访问顺序</span></span><br><span class="line"><span class="comment">3.访问顺序操作的时候，put和get操作已存在的Entry时，都会把Entry移动到双向链表的表尾(也就是先删除再插入)</span></span><br><span class="line"><span class="comment">4.LinkedHashMap存取数据，还是跟HashMap一样使用Entry的方式，双向链表只是为了保证顺序</span></span><br><span class="line"><span class="comment">5.LinkenHashMap线程是不安全的</span></span><br><span class="line"><span class="comment">部分操作：</span></span><br><span class="line"><span class="comment">LinkedHashMap&lt;Integer,Integer&gt; map = new LinkedHashMap&lt;&gt;();//创建map</span></span><br><span class="line"><span class="comment">map.put(key,value)//存入key和value</span></span><br><span class="line"><span class="comment">map.get(key)//取出value</span></span><br><span class="line"><span class="comment">map.keySet()//打印的话是输出key的顺序</span></span><br><span class="line"><span class="comment">map.getOrDefault(Object key, V defaultValue)方法的作用是：当Map集合中有这个key时，就使用这个key值；如果没有就使用默认值defaultValue。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.数组也就是Array（[]）：最高效；但是其容量固定且无法动态改变；使用时候 new和不new没有区别</span></span><br><span class="line"><span class="comment">2.ArrayList：容量可动态增长；但牺牲效率；详细见https://www.runoob.com/java/java-arraylist.html</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();<span class="comment">//以key,value来保存，本题key就是数字本身，value就是频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//创建一个map来对应数字和频率</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;<span class="comment">//如果map中的key存在value</span></span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);<span class="comment">//注意不是map.get(nums[i] + 1)。从第二次开始就在基础频率上增加1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);<span class="comment">//第一次大家都是空的，直接走这一步创建频率为1。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] ans=<span class="keyword">new</span> <span class="title class_">List</span>[nums.length + <span class="number">1</span>];<span class="comment">//这个处理方式比较随意，会出现很多的null，至于多加1，举个例子把。[2,2]。这个2的频率是2。然后代码下面取的时候是ans[2(频率)]，但是我们知道下标如果是用length的话只有0,1。所以这个基础上加1。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: map.keySet())&#123;<span class="comment">//把map中的key依次按顺序处理</span></span><br><span class="line">            <span class="type">int</span> i=map.get(num);<span class="comment">//取出这个Key对应的value(频率)</span></span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                ans[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//初始化，ans一开始本来就是空的嘛</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans[i].add(num);<span class="comment">//同频率的key添加到同一个位置的ans中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[k];<span class="comment">//设置一个数组，长度为k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ans.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; count &lt;k; i--) &#123;<span class="comment">//注意这里是ans.length，而不是nums.length。从后往前面操作，因为题目说是频率的前k个</span></span><br><span class="line">            <span class="keyword">if</span> (ans[i] != <span class="literal">null</span>) &#123;<span class="comment">//对ans中有数字的操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans[i].size(); j++) &#123;<span class="comment">//然后取出这个位置中的ans</span></span><br><span class="line">                    <span class="keyword">if</span> (count &lt; k) &#123;</span><br><span class="line">                        res[count++] = ans[i].get(j);<span class="comment">//题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的.也就是如果题目要求k是2。但是频率最高的同时有3个数，这个是不成立的，也就不存在这个样例。所以每放进一个数，count就要增加1.</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个解法稍微改了一点点，可以避免在生成bucket是时候浪费空间，能省一点是一点，但是实际测试的时候大家好像差不多，可能没有出现极端情况。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        LinkedHashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//频率计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                map.put(nums[i], map.get(nums[i]) + <span class="number">1</span>);</span><br><span class="line">                frequency = Math.max(map.get(nums[i]),frequency);<span class="comment">//找到最高频率</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i],<span class="number">1</span>);</span><br><span class="line">                frequency = Math.max(map.get(nums[i]),frequency);<span class="comment">//找到最高频率</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] ans=<span class="keyword">new</span> <span class="title class_">List</span>[frequency + <span class="number">1</span>];<span class="comment">//长度只需要频率+1.这样可以避免上面的解法，省空间！！！</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num: map.keySet())&#123;</span><br><span class="line">            <span class="type">int</span> i=map.get(num);</span><br><span class="line">            <span class="keyword">if</span>(ans[i]==<span class="literal">null</span>)&#123;</span><br><span class="line">                ans[i]=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            ans[i].add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res[] = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ans.length - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; count &lt;k; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[i] != <span class="literal">null</span>) &#123;<span class="comment">//对ans中有数字的操作</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; ans[i].size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (count &lt; k) &#123;</span><br><span class="line">                        res[count++] = ans[i].get(j);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="451-根据字符出现频率排序-桶排序-medium"><a href="#451-根据字符出现频率排序-桶排序-medium" class="headerlink" title="451 根据字符出现频率排序(桶排序) medium"></a>451 根据字符出现频率排序(桶排序) medium</h2><p>这个题主要和上一题对比的话，我觉得主要是一些语法上，比如对字符处理和上一题对数字的处理是不太一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">frequencySort</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxfreq</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//找出最高的频率</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> map.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>;<span class="comment">//有就在频率的基础上加1，没有就默认0。</span></span><br><span class="line">            map.put(c, frequency);<span class="comment">//放入hash中</span></span><br><span class="line">            maxfreq = Math.max(maxfreq, frequency);<span class="comment">//找到频率最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer[] buckets = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>[maxfreq + <span class="number">1</span>];</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= maxfreq; i++) &#123;</span><br><span class="line">            buckets[i] = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Map.entrySet() 这个方法返回的是一个Set&lt;Map.Entry&lt;K,V&gt;&gt;,Map.Entry里有相应的getKey和getValue方法</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : map.entrySet()) &#123;<span class="comment">//这个写法和上一题的不同之处。上一题都是整数，比较好处理。这个是字符，这样处理比较方便。</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> entry.getKey();<span class="comment">//注意是getkey</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> entry.getValue();<span class="comment">//注意是getvalue</span></span><br><span class="line">            buckets[frequency].append(c); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> maxfreq; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">bucket</span> <span class="operator">=</span> buckets[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucket.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    sb.append(bucket.charAt(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="75-颜色分类-medium"><a href="#75-颜色分类-medium" class="headerlink" title="75 颜色分类 medium"></a>75 颜色分类 medium</h2><p>直接插入排序，但是貌似速度和内存都不占优势？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-<span class="number">1</span>]; j--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="一切皆可搜索"><a href="#一切皆可搜索" class="headerlink" title="一切皆可搜索"></a>一切皆可搜索</h1><h2 id="695-岛屿的最大面积-DFS-medium"><a href="#695-岛屿的最大面积-DFS-medium" class="headerlink" title="695 岛屿的最大面积(DFS) medium"></a>695 岛屿的最大面积(DFS) medium</h2><p>思路是深度优先遍历，分为主函数和辅助函数，主函数就是遍历每个点的位置，辅助函数就是dfs，设置好不满足的条件，满足条件的继续搜索。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//最大数量初始化为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;<span class="comment">//表示一共有多少行（也就是每列的长度，可以理解为Y，注意就是YYYYY）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123; <span class="comment">//表示一共有多少列（也就是每行的长度，可以理解为X，注意就是XXXXX）</span></span><br><span class="line">                ans = Math.max(ans, dfs(grid, i, j));<span class="comment">//比较目前的岛屿是否最大，若不是，就替换为最大岛屿</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> cur_i, <span class="type">int</span> cur_j)</span> &#123;</span><br><span class="line">        <span class="comment">//这个非常重要，是深度优先搜索的不满足条件。有超过边界的(i和j小于0；i等于列长度，j等于行长度，注意数组的开始位置是0哦；还有当前是海洋，也就是不是陆地的地方就不搜索)</span></span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt; <span class="number">0</span> || cur_i == grid.length || cur_j == grid[<span class="number">0</span>].length || grid[cur_i][cur_j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="number">0</span>;<span class="comment">//当上面的条件都跳过了，也就是我们找到了一个陆地，这时候把他置为0，表示我们已经搜索过这个陆地了，然后开始上下左右搜索，不然应该会死循环。</span></span><br><span class="line">        <span class="comment">//这样可以组成 （0,1）（1,0）（-1,0）（0,-1）四种情况。</span></span><br><span class="line">        <span class="type">int</span>[] index_i = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] index_j = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//陆地的数量初始为1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">4</span>; index++) &#123;<span class="comment">//遍历4次，走4个方向</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_inedx_i</span> <span class="operator">=</span> cur_i + index_i[index];</span><br><span class="line">            <span class="type">int</span> <span class="variable">next_inedx_j</span> <span class="operator">=</span> cur_j + index_j[index];</span><br><span class="line">            ans += dfs(grid, next_inedx_i, next_inedx_j);<span class="comment">//把连起来的陆地加起来 </span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*对于二维数组解释下长度问题</span></span><br><span class="line"><span class="comment">grid.length = 8 (8个一维数组，表示有多少行，也可以表示为每列的长度)</span></span><br><span class="line"><span class="comment">grid[0].length = 13（1个数组中有13个数，表示有多少列，也可以表示为每行的长度）</span></span><br><span class="line"><span class="comment">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span></span><br><span class="line"><span class="comment">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span></span><br><span class="line"><span class="comment">[0,1,1,0,1,0,0,0,0,0,0,0,0],</span></span><br><span class="line"><span class="comment">[0,1,0,0,1,1,0,0,1,0,1,0,0],</span></span><br><span class="line"><span class="comment">[0,1,0,0,1,1,0,0,1,1,1,0,0],</span></span><br><span class="line"><span class="comment">[0,0,0,0,0,0,0,0,0,0,1,0,0],</span></span><br><span class="line"><span class="comment">[0,0,0,0,0,0,0,1,1,1,0,0,0],</span></span><br><span class="line"><span class="comment">[0,0,0,0,0,0,0,1,1,0,0,0,0]]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="547-省份数量-DFS-medium"><a href="#547-省份数量-DFS-medium" class="headerlink" title="547 省份数量(DFS) medium"></a>547 省份数量(DFS) medium</h2><p>做这个题的时候陷入到上一题的思维了，做题还是太少了！本题中有多少个二维数组中有多少个一维数组就代表多少个城市，每个一维数组里面的位置代表本城市(也就是i和j相同)或者其他城市(i和j不一样)，位置上为1代表有连接，也就是大家最后是属于一个省份的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：设置一个visit数组来表示访问过的城市。</span></span><br><span class="line"><span class="comment">访问第一个点，因为自己本身都是有1的，把visit[0]置为1(表示这个城市已经被访问过了)，这时候就开始深度优先搜索与这个城市相连的城市，然后依次类推，一直没有找到为止，这样就算完成了一个省份的搜索。开始执行下一个visit为0的城市访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">citys</span> <span class="operator">=</span> isConnected.length;<span class="comment">//表示一共有多少个</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[citys];<span class="comment">//全部城市访问都置为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//省份数量初始为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; citys; i++) &#123;<span class="comment">//开始搜索啦</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;<span class="comment">//只针对没有被访问的城市进行搜索</span></span><br><span class="line">                dfs(isConnected, visited, citys, i);</span><br><span class="line">                sum++;<span class="comment">//上面全部搜索完，就相当于找到一个省份</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] isConnected,<span class="type">boolean</span>[] visited, <span class="type">int</span> citys, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; citys; j++) &#123;<span class="comment">//i是固定的，然后逐个位置搜索看是否有1</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[j] &amp;&amp; isConnected[i][j] == <span class="number">1</span>) &#123;<span class="comment">//满足条件是位置上为1，已经这个城市没有被搜索过</span></span><br><span class="line">                visited[j] = <span class="literal">true</span>;<span class="comment">//满足了上面条件，记得把这个城市置为1，表示已经搜索过了</span></span><br><span class="line">                dfs(isConnected, visited, citys, j);<span class="comment">//开始搜索与i相连的城市，注意这里最后是jjjj。</span></span><br><span class="line">                <span class="comment">//所以，只要说一个城市被搜索过了，这个城市所有的连接情况我们都找到了，也就是他们是属于一个省份的。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="417-太平洋大西洋水流问题-DFS-medium"><a href="#417-太平洋大西洋水流问题-DFS-medium" class="headerlink" title="!417 太平洋大西洋水流问题(DFS) medium"></a>!417 太平洋大西洋水流问题(DFS) medium</h2><p>一开始看了半天例子，以为那几点是形成河流的样子。ok，现在说下题目意思，是找出所有的点，这个点可以流向太平洋，也能流向大西洋 ，所以看例子的时候，单独看每一个点，然后需要自己画出流动方向。<br>!代表我在<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/shen-du-sou-suo-dfsxi-wang-ke-yi-yong-zu-65si/">Leetcode</a>上写题解了，哈哈。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;<span class="comment">//二维数组的行数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights[<span class="number">0</span>].length;<span class="comment">//二维数据的列数</span></span><br><span class="line">        <span class="type">boolean</span>[][] can_reach_p = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];<span class="comment">//初始化可以到达太平洋的数组</span></span><br><span class="line">        <span class="type">boolean</span>[][] can_reach_a = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];<span class="comment">//初试化可以到达大西洋的数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(heights, i, <span class="number">0</span>, can_reach_p);<span class="comment">//搜索左列，也就是靠近太平洋</span></span><br><span class="line">            dfs(heights, i, m - <span class="number">1</span>, can_reach_a);<span class="comment">//搜索右列，也就是靠近大西洋</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dfs(heights, <span class="number">0</span>, j, can_reach_p);<span class="comment">//搜索上列，也就是靠近太平洋</span></span><br><span class="line">            dfs(heights, n - <span class="number">1</span>, j, can_reach_a);<span class="comment">//搜索下列，也就是靠近大西洋</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//初始化一个list来保存符合条件的坐标</span></span><br><span class="line">        <span class="comment">//全部坐标进行判断</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_reach_a[i][j] &amp;&amp; can_reach_p[i][j]) &#123;<span class="comment">//判断这个坐标是否同时流向太平洋和大西洋</span></span><br><span class="line">                    res.add(List.of(i, j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] heights, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">boolean</span>[][] can_reach)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (can_reach[i][j] == <span class="literal">true</span>) &#123;<span class="comment">//如果这个坐标是1，就说明人家早就满足条件了，不需要再进行深度搜索了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        can_reach[i][j] = <span class="literal">true</span>;<span class="comment">//首先把这个坐标给置为1，代表可以达到海洋</span></span><br><span class="line">        <span class="comment">//因为坐标只能进行上下左右移动，也就是(0,1),(0,-1),(1,0),(-1,0)。所以设置成下面这种格式</span></span><br><span class="line">        <span class="type">int</span>[] index_i = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] index_j = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">4</span>; index++) &#123;<span class="comment">//上下左右4次坐标都要判断</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index_i</span> <span class="operator">=</span> i + index_i[index];<span class="comment">//设置下一个坐标的i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index_j</span> <span class="operator">=</span> j + index_j[index];<span class="comment">//设置下一个坐标的j</span></span><br><span class="line">            <span class="comment">//需要满足下面的条件才能进行深度搜索，不能超过边界，还有下一个坐标要比原来坐标大或者相等。</span></span><br><span class="line">            <span class="keyword">if</span> (next_index_i &gt;= <span class="number">0</span> &amp;&amp; next_index_i &lt; heights.length &amp;&amp; next_index_j &gt;= <span class="number">0</span> &amp;&amp; next_index_j &lt; heights[<span class="number">0</span>].length &amp;&amp; heights[i][j] &lt;= heights[next_index_i][next_index_j]) &#123;</span><br><span class="line">                            dfs(heights, next_index_i, next_index_j, can_reach);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="46-全排列-回溯法-medium"><a href="#46-全排列-回溯法-medium" class="headerlink" title="46 全排列(回溯法) medium"></a>46 全排列(回溯法) medium</h2><p>DFS基本操作：[修改当前节点状态]-&gt;[递归子节点状态]。回溯法：[修改当前节点状态]-&gt;[递归子节点状态]-&gt;[回改当前节点状态]。回溯法是优先搜索的一种特殊状态。一般在排列，组合，选择类问题使用回溯法，这次官方那个视频讲解不错，本题就是按照这个思路来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">知识点</span><br><span class="line">注意后面的<span class="keyword">new</span>的写法</span><br><span class="line">栈：Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">list里面还有一个list： List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//状态变量：depth，path，used</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;  res:&quot;+res);</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//栈的应用</span></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> len, <span class="type">int</span> depth, Deque&lt;Integer&gt; path, <span class="type">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            <span class="comment">/*下面这一句超级超级重要，如果改成res.add(path)。最后输出是[[],[],[],[],[],[]]。</span></span><br><span class="line"><span class="comment">            为什么会这样呢？</span></span><br><span class="line"><span class="comment">            变量 path 所指向的列表 在深度优先遍历的过程中只有一份 ，深度优先遍历完成以后，回到了根结点，成为空列表。</span></span><br><span class="line"><span class="comment">            在 Java 中，参数传递是 值传递，对象类型变量在传参的过程中，复制的是变量的地址。这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123; <span class="comment">//如果发现某个位置已经用了，就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(nums[i]);<span class="comment">//栈的添加操作</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;<span class="comment">//然后把这个位置设置为已经用了</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;  递归之前 =&gt; &quot; + path+ &quot;  i: &quot; + i + &quot;  used：  &quot; + Arrays.toString(used));</span></span><br><span class="line">            dfs(nums, len, depth + <span class="number">1</span>, path, used, res);<span class="comment">//进行递归操作</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;<span class="comment">//回改节点状态</span></span><br><span class="line">            path.removeLast();<span class="comment">//回改节点状态，也就是栈的移除操作。</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;递归之后 =&gt; &quot; + path+ &quot;  i: &quot; + i+ &quot;  used：  &quot; + Arrays.toString(used));</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面引用一张<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">别人图片</a>来描述这个算法流程。<br><img src="/images/leetcode-java/5-4-1.png" alt="46题全排列1"><br>然后下面这种图片是一些代码流程细节上的理解，注意当代码运行到dfs里面的时候，会回到for，然后for是重新为0的。<br><img src="/images/leetcode-java/5-4-2.png" alt="46题全排列2"></p>
<h2 id="77-组合-回溯法-medium"><a href="#77-组合-回溯法-medium" class="headerlink" title="77 组合(回溯法) medium"></a>77 组合(回溯法) medium</h2><p>注意排列是不重复的，组合是的话[1,2]和[2,1]是一个情况，还有不能对自己组合哦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//这个写法受到了上一个的影响，不够简洁，实际上完全没有必要用到used，注意有个地方不一样！！！！在唯一一个注释里面！！！</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used =<span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            nums[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(nums, n, k, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> begin, Deque&lt;Integer&gt; path, <span class="type">boolean</span>[] used, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; n; i++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            dfs(nums, n, k, i + <span class="number">1</span>, path, used, res);<span class="comment">//这里不是begin + 1而是i + 1，不然会有重复的组合，因为我们这个题是组合，组合，组合，不是排列！！！！ 比较一下上一题是depth的含义。</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大佬的简洁解法，还有一个解法会更加省时间，但是不好想，也就是剪枝。具体还是看下面的链接。</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 1 开始是题目的设定</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件是：path 的长度等于 k</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历可能的搜索起点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 向路径变量里添加一个数</span></span><br><span class="line">            path.addLast(i);</span><br><span class="line">            <span class="comment">// 下一轮搜索，设置的搜索起点要加 1，因为组合数理不允许出现重复的元素</span></span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            <span class="comment">// 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：liweiwei1419</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>用下大佬的图理解这个题<br><img src="/images/leetcode-java/5-5.png" alt="77组合"><br>总结：77题和46题回溯法，一定要先画图！！！看看他们不一样的点，dfs判断加入path的条件，以及在for循环中dfs的写法，这些都是值得注意的。</p>
<h2 id="79-单词搜索-回溯法-medium"><a href="#79-单词搜索-回溯法-medium" class="headerlink" title="79 单词搜索(回溯法) medium"></a>79 单词搜索(回溯法) medium</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> backtracking(i, j, board, word, visited, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, String word, <span class="type">boolean</span>[][] visited, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word.charAt(pos) || visited[i][j] ==<span class="literal">true</span>) &#123;<span class="comment">//这两个if判断不能对调,因为首先你得判断配对是不是一样的字符，然后才判断他是不是最后一个字符的位置</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span>[] index_i = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] index_j = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">4</span>; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index_i</span> <span class="operator">=</span> i + index_i[index];<span class="comment">//设置下一个坐标的i</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next_index_j</span> <span class="operator">=</span> j + index_j[index];<span class="comment">//设置下一个坐标的j</span></span><br><span class="line">            <span class="keyword">if</span> (next_index_i &gt;= <span class="number">0</span> &amp;&amp; next_index_i &lt; board.length &amp;&amp; next_index_j &gt;= <span class="number">0</span> &amp;&amp;  next_index_j &lt; board[<span class="number">0</span>].length) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> backtracking(next_index_i, next_index_j, board, word, visited, pos + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    result = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*还可以改成这样，不太喜欢这种写法。</span></span><br><span class="line"><span class="comment">    public boolean backtracking(int i, int j, char[][] board, String word, boolean[][] visited, int pos) &#123;</span></span><br><span class="line"><span class="comment">        //这里改了。</span></span><br><span class="line"><span class="comment">        if (board[i][j] != word.charAt(pos)) &#123;</span></span><br><span class="line"><span class="comment">            return false;</span></span><br><span class="line"><span class="comment">        &#125; else if (pos == word.length() - 1) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125; </span></span><br><span class="line"><span class="comment">        visited[i][j] = true;</span></span><br><span class="line"><span class="comment">        int[] index_i = &#123;0, 0, 1, -1&#125;;</span></span><br><span class="line"><span class="comment">        int[] index_j = &#123;1, -1, 0, 0&#125;;</span></span><br><span class="line"><span class="comment">        boolean result = false;</span></span><br><span class="line"><span class="comment">        for (int index = 0; index &lt; 4; index++) &#123;</span></span><br><span class="line"><span class="comment">            int next_index_i = i + index_i[index];//设置下一个坐标的i</span></span><br><span class="line"><span class="comment">            int next_index_j = j + index_j[index];//设置下一个坐标的j</span></span><br><span class="line"><span class="comment">            if (next_index_i &gt;= 0 &amp;&amp; next_index_i &lt; board.length &amp;&amp; next_index_j &gt;= 0 &amp;&amp;  next_index_j &lt; board[0].length) &#123;</span></span><br><span class="line"><span class="comment">                if (visited[next_index_i][next_index_j] == false) &#123;//这里改了，注意这里是next的判断</span></span><br><span class="line"><span class="comment">                    boolean flag = backtracking(next_index_i, next_index_j, board, word, visited, pos + 1);</span></span><br><span class="line"><span class="comment">                    if (flag) &#123;</span></span><br><span class="line"><span class="comment">                        result = true;</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        visited[i][j] = false;</span></span><br><span class="line"><span class="comment">        return result;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下面这个是按照书上思路改写的，但是错误，先放着，未来会修改(已修改，看下面)，初步判断是因为find不是全局变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//！！！！这是错误的，错误的！！！正确写法在下一个代码中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                backtracking(i, j, board, word, find, visited, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, String word, <span class="type">boolean</span> find, <span class="type">boolean</span>[][] visited, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> ||  j &gt;= board[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] != word.charAt(pos) || visited[i][j] || find) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        backtracking(i + <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backtracking(i - <span class="number">1</span>, j, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backtracking(i, j + <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backtracking(i, j - <span class="number">1</span>, board, word, find, visited, pos + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//设为全局变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                backTracking(i, j, board, word, visited, <span class="number">0</span>);<span class="comment">//不用传find</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, String word, <span class="type">boolean</span>[][] visited, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || visited[i][j] || board[i][j] != word.charAt(pos) || find) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(pos == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        backTracking(i - <span class="number">1</span>, j, board, word, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backTracking(i + <span class="number">1</span>, j, board, word, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backTracking(i, j - <span class="number">1</span>, board, word, visited, pos + <span class="number">1</span>);</span><br><span class="line">        backTracking(i, j + <span class="number">1</span>, board, word, visited, pos + <span class="number">1</span>);</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="51-N皇后-回溯法-hard"><a href="#51-N皇后-回溯法-hard" class="headerlink" title="51 N皇后(回溯法) hard"></a>51 N皇后(回溯法) hard</h2><p>久闻的经典题！题目要求就是任何两个皇后都不能在同一行、同一列以及同一条斜线上。思考：斜线怎么判断？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是别人用java改写labuladong的C++版本，感觉非常好理解。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//这里是全局哦</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : board) &#123;</span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="comment">//每一行都成功放置好了皇后，注意这里不是board.length - 1，我的理解是，首先你row进来是检查能不能放，所以最后全部放好后，row会+1,，这时候才判断已经全部能放。</span></span><br><span class="line">        <span class="keyword">if</span> (row == board.length) &#123;</span><br><span class="line">            res.add(charToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board[row].length;<span class="comment">//其实有没有row都一样，都是N*N棋盘。</span></span><br><span class="line">        <span class="comment">//对列进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValid(board, row, col)) &#123;<span class="comment">//判断能不能放皇后，不能放就跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//能放就置为Q</span></span><br><span class="line">            backtracking(board, row + <span class="number">1</span>);<span class="comment">//对下一行进行操作</span></span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;<span class="comment">//回溯法关键，也就是恢复原来标记</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="comment">//判断列是否能放皇后</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断右上方有没有皇后冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<span class="comment">//先跳到上一行，列也要加一行，依次类推，注意边界！</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断左上方有没有皇后冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;=<span class="number">0</span>; i--, j--) &#123;<span class="comment">//先跳到上一行，列也要减一行，依次类推，注意边界！</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//这里为什么不进行左下方和右下方进行判断？因为是一行行进行放，这时候左下和右下必定没有呀</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">charToList</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : board) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">本题有很多需要学习的写法</span><br><span class="line"><span class="number">1.</span><span class="keyword">for</span> (<span class="type">char</span>[] c : board) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">本句输出是<span class="number">1111</span>，也就是说，对于Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>)每次操作，都是[., ., ., .]，一次性把每行的<span class="number">4</span>个位置都填充上，然后一共操作<span class="number">4</span>次而不是<span class="number">16</span>次。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);<span class="comment">//初始化棋盘这里</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    System.out.print(Arrays.toString(board[i]));</span><br><span class="line">&#125;</span><br><span class="line">输出结果是：</span><br><span class="line">[., ., ., .][., ., ., .][., ., ., .][., ., ., .]</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span><span class="keyword">for</span> (<span class="type">char</span>[] c : board) &#123;</span><br><span class="line">            list.add(String.copyValueOf(c));</span><br><span class="line">&#125;</span><br><span class="line">首先为什么要这么操作，因为输入是一个二维数组来的，最后的输出要符合题目输出，把每一个一维数组加到list中！</span><br><span class="line">这一段的操作是这样看，首先是输入一个已经摆放好皇后的棋盘</span><br><span class="line">String.copyValueOf是返回字符串</span><br><span class="line">然后<span class="type">char</span> c是提取每一行出来，比如第一行.Q..然后add到list中，最后扫描完所有行list是这样[.Q.., ...Q, Q..., ..Q.]，然后再res.add进去。</span><br></pre></td></tr></table></figure>
<h2 id="934-最短的桥-DFS-BFS-medium"><a href="#934-最短的桥-DFS-BFS-medium" class="headerlink" title="934 最短的桥(DFS+BFS) medium"></a>934 最短的桥(DFS+BFS) medium</h2><p>一般广度优先遍历用于求最短路径或者可达性问题。本题实际上就是求两个岛屿之间的最短距离，先任意找到一个岛，然后用广度优先搜索寻找和另外一个岛屿的最短距离。结合了书和<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-bridge/solution/java-bfsyu-dfsshi-yong-by-ppppjqute-jvwv/">该作者</a>的想法。做完这个题其实还是有点不理解，因为首先是找到了第一个岛后就break掉了，那怎么知道其他岛与其他岛会不会有更小的距离呢？经过我的探索，终于知道了，因为题目样例中有且仅有两个岛！！！！！！不会出现第三个岛！！！！务必知道挨着的1是属于一个岛！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">有个地方需要注意，两个陆地挨着的属于一个岛。比如[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]这种情况是一个岛，当然了，这个用例是不能被输入的，因为必须要有两个岛。还有这个题返回的是必须翻转<span class="number">0</span>的数目。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] direction = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;<span class="comment">//四个方向坐标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//初始化距离，这里为什么要设置-1而不是0，因为一进入下面的while后首先是搜索以自己为目标的四周，所以第一次进入while，先ans++，这样就初始化了为0，然后再从我自己扩散出去，而且循环里面是找到了下一个陆地直接返回ans，没有进行加加，一开始提前了ans++。</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        Deque&lt;<span class="type">int</span> []&gt; point = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//队列记录坐标</span></span><br><span class="line">        <span class="comment">//dfs寻找第一个岛，并把这个岛全部标记为2，注意想象一下周围一圈都是1，表达是一个岛，会把这一圈的1都标记为2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="literal">true</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    dfs(grid, point, i, j); </span><br><span class="line">                    flag = <span class="literal">true</span>;<span class="comment">//代表找到了岛</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行广度搜索，看多少层能到下一个陆地</span></span><br><span class="line">        <span class="keyword">while</span> (!point.isEmpty()) &#123;<span class="comment">//point不为空</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> point.size();</span><br><span class="line">            ans++;<span class="comment">//每扩散一次，距离加1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">//依次对标记过为2的岛进行操作</span></span><br><span class="line">                <span class="comment">//System.out.print(&quot;hello  &quot;+ ans+&quot;   &quot;+&quot;  &quot;);</span></span><br><span class="line">                <span class="type">int</span>[] node = point.poll();<span class="comment">//取出队列中第一个岛的坐标，并删除队列中该坐标</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;<span class="comment">//上下左右寻找</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">next_x</span> <span class="operator">=</span> node[<span class="number">0</span>] + direction[j][<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">next_y</span> <span class="operator">=</span> node[<span class="number">1</span>] + direction[j][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(next_x &lt; <span class="number">0</span> || next_x &gt;= grid.length || next_y &lt; <span class="number">0</span> || next_y &gt;= grid[<span class="number">0</span>].length || grid[next_x][next_y] == <span class="number">2</span>) &#123;<span class="comment">//判断：不能超边界以及不能是访问过的陆地</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[next_x][next_y] == <span class="number">1</span>) &#123;<span class="comment">//找到下一个岛</span></span><br><span class="line">                        <span class="keyword">return</span> ans;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[next_x][next_y] = <span class="number">2</span>;<span class="comment">//走过的地方要标记为2(这些地方可能是水哦)</span></span><br><span class="line">                    point.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next_x, next_y&#125;);<span class="comment">//把这些坐标都记录起来</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, Deque&lt;<span class="type">int</span> []&gt; point, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= grid.length || j &lt; <span class="number">0</span> || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">2</span> || grid[i][j] != <span class="number">1</span>) &#123;<span class="comment">//边界判断以及走过的地方不搜索还有不是陆地的不搜索</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        point.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        dfs(grid, point, i - <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, point, i + <span class="number">1</span>, j);</span><br><span class="line">        dfs(grid, point, i, j - <span class="number">1</span>);</span><br><span class="line">        dfs(grid, point, i, j + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;举个例子：</span><br><span class="line">现在两个岛是这样的，就是一个L型和中间一块小岛</span><br><span class="line">[[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">下面最左边的<span class="number">9</span>和<span class="number">7</span>代表队列中的元素个数，hello具体位置在上面代码看，表达进入<span class="keyword">for</span>循环，hello右边是ans的大小，最右边是取出来的坐标。可以看到，先把L型岛坐标全部放进队列，然后一个个坐标取出来再再看四周(并且也把四周的点加入到队列)，第一轮发现是没有碰到陆地的，所以到了第二轮，第二轮是<span class="number">7</span>因为L型右边的坐标围起来是<span class="number">7</span>个，然后开始继续找，到了<span class="number">2</span>,<span class="number">1</span>坐标，可以知道右边一个位置是<span class="number">1</span>，这时候已经找到了，返回ans。</span><br><span class="line"><span class="number">9</span>  hello  <span class="number">0</span>     <span class="number">0</span> <span class="number">0</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">1</span> <span class="number">0</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">2</span> <span class="number">0</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">3</span> <span class="number">0</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">4</span> <span class="number">0</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">4</span> <span class="number">1</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">4</span> <span class="number">2</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">4</span> <span class="number">3</span></span><br><span class="line">hello  <span class="number">0</span>     <span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">7</span>  hello  <span class="number">1</span>     <span class="number">0</span> <span class="number">1</span></span><br><span class="line">hello  <span class="number">1</span>     <span class="number">1</span> <span class="number">1</span></span><br><span class="line">hello  <span class="number">1</span>     <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="126-单词接龙2-回溯-BFS-hard"><a href="#126-单词接龙2-回溯-BFS-hard" class="headerlink" title="126 单词接龙2(回溯+BFS) hard"></a>126 单词接龙2(回溯+BFS) hard</h2><p>单词只差一个字母的可以连接成节点，思考如何去判断只相差一个字母？回溯也就是深度优先搜索的一个应用，用于找出所有情况，BFS也就是找到最短路径，合起来就是找出所有的最短路径。这个题和上一个题差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//官方的解答，学到就是我的🤓</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);<span class="comment">// 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」</span></span><br><span class="line">        <span class="keyword">if</span> (!dict.contains(endWord)) &#123;<span class="comment">// 特殊用例判断</span></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dict.remove(beginWord);<span class="comment">//把beginword在字典里删除掉</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第 1 步：广度优先遍历建图</span></span><br><span class="line">        <span class="comment">// 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先遍历的第几层</span></span><br><span class="line">        Map&lt;String, Integer&gt; steps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        steps.put(beginWord, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; from = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">found</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wordlen</span> <span class="operator">=</span> beginWord.length();<span class="comment">//记录单词的长度，以便于对每个字符进行更换</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);<span class="comment">//把开始的单词加进去</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;<span class="comment">//不为空就运行</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;<span class="comment">//对queue里面的单词依次操作</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currword</span> <span class="operator">=</span> queue.poll();<span class="comment">//先取出queue第一个单词</span></span><br><span class="line">                <span class="type">char</span>[] chararray = currword.toCharArray();<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; wordlen; j++) &#123;<span class="comment">//对每一个位置的字符进行操作</span></span><br><span class="line">                    <span class="type">char</span> <span class="variable">origin</span> <span class="operator">=</span> chararray[j];<span class="comment">//先保存原来的字符，以便后面进行恢复</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;<span class="comment">//每个位置都可以替换26次（包括原来的自己啦）</span></span><br><span class="line">                        chararray[j] = c;<span class="comment">//替换成果</span></span><br><span class="line">                        <span class="type">String</span> <span class="variable">nextword</span> <span class="operator">=</span> String.valueOf(chararray);<span class="comment">//char数组转成字符串</span></span><br><span class="line">                        <span class="keyword">if</span> (steps.containsKey(nextword) &amp;&amp; step == steps.get(nextword)) &#123;<span class="comment">//初步理解就是，如果大家都在同一个level的词变换，就进行操作添加这个词</span></span><br><span class="line">                            <span class="comment">//System.out.print(&quot;nextword is &quot;+nextword);</span></span><br><span class="line">                            <span class="comment">//System.out.print(&quot;currword is &quot;+currword);</span></span><br><span class="line">                            from.get(nextword).add(currword);<span class="comment">//如果有这个key的记录, 添加新值</span></span><br><span class="line">                            <span class="comment">//System.out.println(&quot;from is a  &quot;+from);</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!dict.contains(nextword)) &#123;<span class="comment">//dict中不存在这个单词就跳过</span></span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//下面这两句思考一下！！！！！</span></span><br><span class="line">                        dict.remove(nextword);<span class="comment">//如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除</span></span><br><span class="line">                        queue.add(nextword); <span class="comment">// 那么这一层扩展出的单词进入队列</span></span><br><span class="line">                        <span class="comment">// 记录 nextword 从 currWord 而来</span></span><br><span class="line">                        from.putIfAbsent(nextword, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                        from.get(nextword).add(currword);</span><br><span class="line">                        <span class="comment">// 记录 nextword 的 step</span></span><br><span class="line">                        steps.put(nextword, step);</span><br><span class="line">                        <span class="keyword">if</span> (nextword.equals(endWord)) &#123;<span class="comment">//等于最后一个单词就把found设置为true</span></span><br><span class="line">                            found = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//System.out.println(&quot;dict is &quot;+dict);</span></span><br><span class="line">                        <span class="comment">//System.out.println(&quot;queue is &quot;+queue);</span></span><br><span class="line">                        <span class="comment">//System.out.println(&quot;from is &quot;+from);</span></span><br><span class="line">                        <span class="comment">//System.out.println(&quot;steps is &quot;+steps);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    chararray[j] = origin;<span class="comment">//还原单词</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;<span class="comment">//level加1</span></span><br><span class="line">            <span class="keyword">if</span> (found) &#123;<span class="comment">//找到就打断程序</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 2 步：深度优先遍历找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部</span></span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            path.add(endWord);</span><br><span class="line">            backtracking(from, path ,beginWord ,endWord ,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意这个回溯反着来找，从尾巴一直寻找到最开始，就是根据from记录的信息来寻找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(Map&lt;String, List&lt;String&gt;&gt; from, Deque&lt;String&gt; path, String beginWord, String cur, List&lt;List&lt;String&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(beginWord)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String preucrsor : from.get(cur)) &#123;</span><br><span class="line">            path.addFirst(preucrsor);</span><br><span class="line">            backtracking(from, path, beginWord, preucrsor, res);</span><br><span class="line">            path.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">老规矩，看不懂怎么运行就一步步打印出来</span></span><br><span class="line"><span class="comment">dict is [lot, log, dot, cog, dog]</span></span><br><span class="line"><span class="comment">queue is [hot]</span></span><br><span class="line"><span class="comment">from is &#123;hot=[hit]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;hit=0, hot=1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dict is [lot, log, cog, dog]</span></span><br><span class="line"><span class="comment">queue is [dot]</span></span><br><span class="line"><span class="comment">from is &#123;dot=[hot], hot=[hit]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;hit=0, dot=2, hot=1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dict is [log, cog, dog]</span></span><br><span class="line"><span class="comment">queue is [dot, lot]</span></span><br><span class="line"><span class="comment">from is &#123;lot=[hot], dot=[hot], hot=[hit]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;lot=2, hit=0, dot=2, hot=1&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dict is [log, cog]</span></span><br><span class="line"><span class="comment">queue is [lot, dog]</span></span><br><span class="line"><span class="comment">from is &#123;lot=[hot], dot=[hot], hot=[hit], dog=[dot]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;lot=2, hit=0, dot=2, hot=1, dog=3&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dict is [cog]</span></span><br><span class="line"><span class="comment">queue is [dog, log]</span></span><br><span class="line"><span class="comment">from is &#123;lot=[hot], log=[lot], dot=[hot], hot=[hit], dog=[dot]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;lot=2, hit=0, log=3, dot=2, hot=1, dog=3&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dict is []</span></span><br><span class="line"><span class="comment">queue is [log, cog]</span></span><br><span class="line"><span class="comment">from is &#123;lot=[hot], log=[lot], dot=[hot], cog=[dog], hot=[hit], dog=[dot]&#125;</span></span><br><span class="line"><span class="comment">steps is &#123;lot=2, hit=0, log=3, dot=2, cog=4, hot=1, dog=3&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//这个是第一个if语句中的输出，对于这个例子，一共才运行了一次，仔细观察cog这个值多了一个log</span></span><br><span class="line"><span class="comment">nextword is cog</span></span><br><span class="line"><span class="comment">curword is log</span></span><br><span class="line"><span class="comment">from is a  &#123;lot=[hot], log=[lot], dot=[hot], cog=[dog, log], hot=[hit], dog=[dot]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">map和hashmap区别?</span><br><span class="line">queue和Deque区别?</span><br><span class="line">add offer等操作区别?</span><br><span class="line">contains和containskey区别?</span><br><span class="line">put和putIfAbsent区别：put在放入数据时，如果放入数据的key已经存在与Map中，最后放入的数据会覆盖之前存在的数据，而putIfAbsent在放入数据时，如果存在重复的key，那么putIfAbsent不会放入值。</span><br><span class="line">测试的时候发现下面两种写法都是可以的，可以百度下他们的不同。</span><br><span class="line">Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">Deque&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h2 id="130-被围绕的区域-medium"><a href="#130-被围绕的区域-medium" class="headerlink" title="130 被围绕的区域 medium"></a>130 被围绕的区域 medium</h2><p>采用深度优先遍历递归，首先要理解就是只有被X包围的区域O才被替换，所以在边界的O是不能被替换的，延伸下去的话，和边界O相连的O也是不能够被替换的，所以这个题目的思想就是，从边界O下手，然后找到和这个边界O相连的O，然后把他们都替换成一个字符#，最后再做一次全局的遍历，把没被替换成O的换成X，把#恢复成O。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public void solve(char[][] board) &#123;</span><br><span class="line">        if (board == null || board.length == 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int n = board.length, m = board[0].length;</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            for(int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                boolean isEdge = i == 0 || i == n - 1 || j == 0 || j == m - 1;</span><br><span class="line">                if (isEdge &amp;&amp; board[i][j] == &#x27;O&#x27;) &#123; //只需要从边界下手，其他地方不需要</span><br><span class="line">                    dfs(board, i ,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         for (int i = 0; i &lt; n; i++) &#123;  //都遍历完了，再全局遍历进行更换字符</span><br><span class="line">             for (int j = 0; j &lt; m; j++) &#123;</span><br><span class="line">                 if  (board[i][j] == &#x27;O&#x27;) &#123;</span><br><span class="line">                     board[i][j] = &#x27;X&#x27;;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (board[i][j] == &#x27;#&#x27;) &#123;</span><br><span class="line">                     board[i][j] = &#x27;O&#x27;;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(char [][]board, int i ,int j) &#123; //深度优先遍历</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] == &#x27;X&#x27; || board[i][j] == &#x27;#&#x27;) &#123; //边界条件以及本来是X和#的不需要操作</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = &#x27;#&#x27;;</span><br><span class="line">        dfs(board, i + 1, j);</span><br><span class="line">        dfs(board, i - 1, j);</span><br><span class="line">        dfs(board, i , j + 1);</span><br><span class="line">        dfs(board, i , j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="257-二叉树的所有路径-easy"><a href="#257-二叉树的所有路径-easy" class="headerlink" title="257 二叉树的所有路径 easy"></a>257 二叉树的所有路径 easy</h2><p>深度优先遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();</span><br><span class="line">        constructpath(root, &quot;&quot;, paths);</span><br><span class="line">        return paths;</span><br><span class="line">    &#125;</span><br><span class="line">    public void constructpath(TreeNode root, String path, List&lt;String&gt; paths) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            StringBuffer temppath = new StringBuffer(path); //注意这里，每次递归都对变量path进行拷贝构造</span><br><span class="line">            temppath.append(root.val);</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;  //到了叶子节点就代表结束了</span><br><span class="line">                paths.add(temppath.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                temppath.append(&quot;-&gt;&quot;);</span><br><span class="line">                constructpath(root.left, temppath.toString(), paths);</span><br><span class="line">                constructpath(root.right, temppath.toString(), paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于append和add的用法总结：</span><br><span class="line">1.append</span><br><span class="line">Java里只有StringBuffer和StringBuild才有append方法，Sting里是没有append方法的</span><br><span class="line"></span><br><span class="line">2.add</span><br><span class="line">List集合列表中添加元素</span><br></pre></td></tr></table></figure>
<h2 id="47-全排列2-medium"><a href="#47-全排列2-medium" class="headerlink" title="47 全排列2 medium"></a>47 全排列2 medium</h2><p>和<a href="https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/#46-%E5%85%A8%E6%8E%92%E5%88%97-%E5%9B%9E%E6%BA%AF%E6%B3%95-medium">46</a>的区别是，这个题是有重复数字的，而且重复数字不是有序的，而是打乱的。<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/">官网的题解更简洁</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        int len = nums.length;</span><br><span class="line">        boolean[] used = new boolean[len];</span><br><span class="line">        if (len == 0) &#123;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums); //区别1，首先要对数列进行排序</span><br><span class="line">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(nums, len, 0, path, used, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void dfs(int[] nums, int len, int depth, Deque&lt;Integer&gt; path, boolean[] used, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">        if (depth == len) &#123;</span><br><span class="line">            res.add(new ArrayList(path));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            if (used[i] == true || (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false)) &#123; //区别2，还要判断和前一个数是不是一样的，这里used[i - 1] == false不好理解，下面单独解释</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(nums[i]);</span><br><span class="line">            used[i] = true;</span><br><span class="line">            dfs(nums, len, depth + 1, path, used, res);</span><br><span class="line">            used[i] =  false;</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个题首先要排序哦</span><br><span class="line">i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]这个很好理解，就是重复的数字不要再进行了，但是used[i - 1] == false这个其实是不好理解的，我在做的时候就在想为什么还要多加这个条件呢？。</span><br><span class="line"></span><br><span class="line">来自网友1的解释（vis和上面used作用一样）：</span><br><span class="line">加上 !vis[i - 1]来去重主要是通过限制一下两个相邻的重复数字的访问顺序</span><br><span class="line">举个栗子，对于两个相同的数11，我们将其命名为1a1b, 1a表示第一个1，1b表示第二个1； 那么，不做去重的话，会有两种重复排列 1a1b, 1b1a， 我们只需要取其中任意一种排列； 为了达到这个目的，限制一下1a, 1b访问顺序即可。 比如我们只取1a1b那个排列的话，只有当visit nums[i-1]之后我们才去visit nums[i]， 也就是如果!visited[i-1]的话则continue</span><br><span class="line"></span><br><span class="line">来自网友2的解释：</span><br><span class="line">for循环保证了从数组中从前往后一个一个取值，再用if判断条件。所以nums[i - 1]一定比nums[i]先被取值和判断。如果nums[i - 1]被取值了，那vis[i - 1]会被置1，只有当递归再回退到这一层时再将它置0。每递归一层都是在寻找数组对应于递归深度位置的值，每一层里用for循环来寻找。所以当vis[i - 1] == 1时，说明nums[i - 1]和nums[i]分别属于两层递归中，也就是我们要用这两个数分别放在数组的两个位置，这时不需要去重。但是当vis[i - 1] == 0时，说明nums[i - 1]和nums[i]属于同一层递归中（只是for循环进入下一层循环），也就是我们要用这两个数放在数组中的同一个位置上，这就是我们要去重的情况。</span><br></pre></td></tr></table></figure>
<h2 id="40-组合总和-II-medium"><a href="#40-组合总和-II-medium" class="headerlink" title="40 组合总和 II medium"></a>40 组合总和 II medium</h2><p>深度优先遍历，务必注意解集不能包含重复组合，每个数字在每个组合中只能使用一次，<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-3/">这个博主解释不错</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(candidates);<span class="comment">//务必要排序</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);<span class="comment">//用双端队列会更好操作，不加len也可以</span></span><br><span class="line">        dfs(candidates, len, <span class="number">0</span>, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> len, <span class="type">int</span> begin, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>) &#123;<span class="comment">//如果减了小于0，就没必要进行了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;<span class="comment">//同一层相同元素只考虑第一个，没有这个操作可能会导致结果集合一样，i&gt;begin是精髓，可以看上面链接中的评论，有详细回答。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, len, i + <span class="number">1</span>, target - candidates[i], path, res);</span><br><span class="line">            path.removeLast();<span class="comment">//深度遍历思想是继续往下探索如果没有就返回</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Linklist写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();<span class="comment">//这里不同</span></span><br><span class="line">        dfs(candidates, len, target, <span class="number">0</span>, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> len,<span class="type">int</span> target, <span class="type">int</span> begin, List&lt;List&lt;Integer&gt;&gt; res, LinkedList&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(candidates[i]);<span class="comment">//这里不同</span></span><br><span class="line">            dfs(candidates, len, target - candidates[i], i + <span class="number">1</span>, res, path);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="37-解数独-hard-未完成"><a href="#37-解数独-hard-未完成" class="headerlink" title="37 解数独 hard 未完成"></a>37 解数独 hard 未完成</h2><h2 id="310-最小高度树-medium-未完成"><a href="#310-最小高度树-medium-未完成" class="headerlink" title="310 最小高度树 medium 未完成"></a>310 最小高度树 medium 未完成</h2><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>dp三要素，定义状态，初始状态，状态转移</p>
<h2 id="70-爬楼梯-easy"><a href="#70-爬楼梯-easy" class="headerlink" title="70 爬楼梯 easy"></a>70 爬楼梯 easy</h2><p>题目说可以跨一步或者两步，动态规划最重要就是有一个状态转移方程，f(x)&#x3D;f(x−1)+f(x−2)，你可以理解为，我走到x级的时候，我的方案数量就是走到x-1级的所有数量加上我走到x-2级的所有数量。怎么理解呢？比如我知道x-1级的所有方案数量，我再走一步就可以到达x级，同理，x-2级也是这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;    <span class="comment">//注意力扣是计算1到45级阶梯,0是不算的，然后的话我们的状态转移方程是需要前一级和前前一级的，所以1和2是要已知的。</span></span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre2</span> <span class="operator">=</span> <span class="number">1</span>, pre1 = <span class="number">2</span>, cur = <span class="number">0</span>; <span class="comment">//pre2代表前两级，这里初始的1代表只有一个方案，也就是上第一级楼梯只有一个方案，pre1代表前一级楼梯，可以理解为上第二级楼梯的方案有两种，要么跨两步，要么就是连续走一步。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n ; i++) &#123;  <span class="comment">//注意别忘了从第三级楼梯开始，这里和n（就是直接为多少级）含义不一样，不要混淆，因为这个for循环是计数用的，i=2代表从第三级开始。</span></span><br><span class="line">            cur = pre1 + pre2; </span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="198-打家劫舍-medium"><a href="#198-打家劫舍-medium" class="headerlink" title="198 打家劫舍 medium"></a>198 打家劫舍 medium</h2><p>直接说大于两间房的情况，那么有两种情况1.偷窃第k间房屋，那么就不能偷窃第k-1间房屋，偷窃总金额为前k-2间房屋的最高总金额与第k间房屋的金额之和。2.不偷窃第k间房屋，偷窃总金额为前k−1间房屋的最高总金额。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> nums[<span class="number">0</span>], second = Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;<span class="comment">//从第三间房开始,每间房之和该房屋的前两间房的最高总金额有关，因此用一个滚动数组，每个时刻只存储前两间房的最高金额。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> second;<span class="comment">//一个temp来保存先</span></span><br><span class="line">            second = Math.max(first + nums[i], second);<span class="comment">//这时候开始找最大值</span></span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="413-等差数列划分-medium"><a href="#413-等差数列划分-medium" class="headerlink" title="413 等差数列划分 medium"></a>413 等差数列划分 medium</h2><p>首先要注意至少是三个元素才可以，其次注意子数组也算，比如[1,2,3,4]这个就可以有[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 三个等差数组。下面t++是不太好理解的，可以看官方解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span> || len == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> nums[<span class="number">1</span>] - nums[<span class="number">0</span>], t = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] - nums[i - <span class="number">1</span>] == d) &#123;</span><br><span class="line">                ++t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d = nums[i] - nums[i - <span class="number">1</span>];<span class="comment">//否则重新计算d，比如可以试试[1,2,3,8,9,10]，答案是2个</span></span><br><span class="line">                t = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="64-最小路径和-medium"><a href="#64-最小路径和-medium" class="headerlink" title="64 最小路径和 medium"></a>64 最小路径和 medium</h2><p>首先要注意，路径只能向下或者向右，其次，返回的是最后路径的大小，而不是路径本身。本方法是创建一个最小路径的矩阵，也就是每个位置记录从左上角到这里最小值，最后返回右下角位置的值即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;<span class="comment">//这道题是二维矩阵的题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length, columns = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[rows][columns];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;     <span class="comment">//考虑第一行的情况，只能往右边走，所以新构建的dp矩阵是dp左边元素加grip[i][0]的距离，再次说明dp矩阵表示距离</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;   <span class="comment">//考虑第一列的情况</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rows; i++) &#123;    <span class="comment">//考虑里面的元素，请注意，务必先考虑完第一行和第一列的元素才能写这里，否则我们不知道怎么找上一个元素的距离，因为里面的元素也是和左边和上面元素相关</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; columns; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[rows - <span class="number">1</span>][columns - <span class="number">1</span>];<span class="comment">//构建完后返回最后一个元素的值即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="542-01矩阵-medium"><a href="#542-01矩阵-medium" class="headerlink" title="542 01矩阵 medium"></a>542 01矩阵 medium</h2><p>和上一题一样，构建一个距离矩阵，但是本题又和上一题不太一样哦，是寻找每个元素距离0最近的距离。只有 水平向左移动 和 竖直向上移动，只有 水平向右移动 和 竖直向下移动。本题的思路是这个点周围的邻居到0的最小距离+1就是这个点到0的最短距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] mat) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat.length, n = mat[<span class="number">0</span>].length; </span><br><span class="line">        <span class="type">int</span>[][] dist = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;  <span class="comment">//初始化二维数组全部最最大值</span></span><br><span class="line">            Arrays.fill(dist[i], Integer.MAX_VALUE / <span class="number">2</span>);<span class="comment">//填充一维数组只需要Arrays.fill(Object[] ary, Object val)赋值，那么二维数组就需要一个循环。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m; i++) &#123;  <span class="comment">//初始化位置为0的元素距离就是0</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dist[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划务必注意要找前一个的状态。至于为什么本题只需要左上和右下，可以看题解的评论，当然了，你也可以选择右上(右上角到左下角遍历)和左下(左下角到右上角遍历)。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只有 水平向左移动 和 竖直向上移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="comment">//从左上角到右下角遍历,为什么左上是从左上角开始遍历，因为这是DP，需要知道前一步的状态。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查上邻居,if条件是为了有上邻居，而不至于越界。</span></span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i - <span class="number">1</span>][j] + <span class="number">1</span>); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;<span class="comment">//检查左邻居,if条件是为了有左邻居，而不至于越界。</span></span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j - <span class="number">1</span>] + <span class="number">1</span>); </span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有 水平向右移动 和 竖直向下移动，注意动态规划的计算顺序</span></span><br><span class="line">        <span class="comment">//从右下角到左上角遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;<span class="comment">//检查下邻居</span></span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i + <span class="number">1</span>][j] + <span class="number">1</span>); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;<span class="comment">//检查右邻居</span></span><br><span class="line">                    dist[i][j] = Math.min(dist[i][j], dist[i][j + <span class="number">1</span>] + <span class="number">1</span>); </span><br><span class="line">                &#125;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">为啥只用左上和右下就行？ 用最简单的只有一个<span class="number">0</span>的来示例（来自网友的图）</span><br><span class="line"></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"><span class="number">1011</span></span><br><span class="line"><span class="number">1111</span></span><br><span class="line"></span><br><span class="line">左上（左邻居和上邻居）之后变成(其中-表示<span class="type">int</span>最大值)</span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line">-<span class="number">012</span></span><br><span class="line">-<span class="number">123</span></span><br><span class="line"></span><br><span class="line">接下来的右下就是取某个点的右上和左下其中比较小的值 加一 就行 现在根据已知的右下角这一坨 已经可以推出其余的全部了 比如左下角那一坨</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">----</span><br><span class="line"><span class="number">1012</span></span><br><span class="line"><span class="number">2123</span></span><br><span class="line"></span><br><span class="line">右上角那一坨</span><br><span class="line"></span><br><span class="line">-<span class="number">234</span></span><br><span class="line">-<span class="number">123</span></span><br><span class="line"><span class="number">1012</span></span><br><span class="line"><span class="number">2123</span></span><br><span class="line"></span><br><span class="line">还有最终左上角的那一坨</span><br><span class="line"></span><br><span class="line"><span class="number">3234</span></span><br><span class="line"><span class="number">2123</span></span><br><span class="line"><span class="number">1012</span></span><br><span class="line"><span class="number">2123</span></span><br><span class="line"></span><br><span class="line">我自己的一个小例子</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">01</span></span><br><span class="line"></span><br><span class="line">左上后</span><br><span class="line">m0</span><br><span class="line">m1</span><br><span class="line"></span><br><span class="line">右下后</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">21</span></span><br></pre></td></tr></table></figure>
<h2 id="221-最大正方形-medium"><a href="#221-最大正方形-medium" class="headerlink" title="221 最大正方形 medium"></a>221 最大正方形 medium</h2><p>首先需要注意,dp[i][j]是以i，j坐标为右下角的正方形边长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxsize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> [][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;<span class="comment">//在边界的情况</span></span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;<span class="comment">//不在边界，等于这个坐标的左边，上边，左斜上边的最小值加上1，同时也是本题的动态规划转移方程。</span></span><br><span class="line">                        dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), dp[i][j - <span class="number">1</span>]) +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                maxsize = Math.max(maxsize, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsize * maxsize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面一个图来自网友，解释了为什么用左边，上边，左斜上边的最小值。<br><img src="/images/leetcode-java/221.png"></p>
<h2 id="279-完全平方数-medium"><a href="#279-完全平方数-medium" class="headerlink" title="279 完全平方数 medium"></a>279 完全平方数 medium</h2><p>推荐看这个<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/perfect-squares/solution/279-wan-quan-ping-fang-shu-by-chen-wei-f-gwzs/">作者</a>的讲解，非常好</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化0的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i] = i;<span class="comment">//每个位置最差的情况就是i个数，比如dp[12]最大就是12个1来组成</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; i - j * j &gt;=<span class="number">0</span> ; j++) &#123;<span class="comment">//你不能f[12]来一个16的平方数，所以i-j*j要大于等于0</span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里解释下状态转移方程</span></span><br><span class="line"><span class="comment">比如递推到找f[11]</span></span><br><span class="line"><span class="comment">那么可以拆成f[2] + 1（这个1表示9这个完全平方数，也可以理解为f[11 - 9]再加上一个9就能组成f[11]的数量，这里不要混了，f[n]表示的是一个数量，加9这个平方数就是加一个1，这也是为什么状态转移方程是+1）</span></span><br><span class="line"><span class="comment">还能拆成f[7] + 4这个平方数, f[7]也就是f[11 - 4]，所以f[7]的数量，再加一个1，可以表示成f[11]的数量。</span></span><br><span class="line"><span class="comment">还能拆成f[10] + 1这个平方数，同理不再叙述</span></span><br><span class="line"><span class="comment">然后找他们最小值即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据书上例子写的，上面那个更好理解</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;  j * j &lt;= i ; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="91-解码方法-medium"><a href="#91-解码方法-medium" class="headerlink" title="91 解码方法 medium"></a>91 解码方法 medium</h2><p>这个题思考了比较久，题解是根据书上改成java的，虽然比较长，但是好理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> s.charAt(<span class="number">0</span>) -<span class="number">48</span>;<span class="comment">//因为s是字符串，我们提取出来的数字是ASCII码，48是0的ASCII码，这样写转成数字，比如&#x27;1&#x27;就转成1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);<span class="comment">//全部位置首先置为1，如果单独dp[0]为1，会发现s=12有错误，我一开始以为只置第0个数就行。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> s.charAt(i - <span class="number">1</span>) - <span class="number">48</span>;</span><br><span class="line">            <span class="keyword">if</span> ((prev == <span class="number">0</span> || prev &gt; <span class="number">2</span>) &amp;&amp; cur == <span class="number">0</span>) &#123;<span class="comment">//如果当前为0，并且前一个数是0或者大于2，无法解码,注意if中第一个括号很关键，比如是组合在一起(prev == 0 || prev &gt; 2)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="number">1</span> || prev == <span class="number">2</span> &amp;&amp; cur &lt; <span class="number">7</span>) &#123;<span class="comment">//如果前一个数是1或者2，并且当前数小于7，考虑组合问题</span></span><br><span class="line">                <span class="keyword">if</span> (cur!=<span class="number">0</span>) &#123;<span class="comment">//首先当前数不为0，也就是当前数和之前那个数可以组合在一起</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];<span class="comment">//</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前数虽然等于0，但是前一个数为1或者2，也可以组合成10,20，也就是我们当前数是不能单独解码</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//无法进行组合了，只能单独解第二个数</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            prev = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">理解过程</span><br><span class="line">这个题是返回解码方法的总数，</span><br><span class="line">首先定义一个长为n+1的数组，dp[2]就表示前2个数的解码方法总数，所以最后返回dp[n]就代表题目要求的答案了。</span><br><span class="line"></span><br><span class="line">如果第一个数字就是0，那不用问，永远解不出来，规则上01和1是不一样的，没有01这个解码。</span><br><span class="line">其次声明好dp数组，长度为n+1，并且全部位置初始化为1，后面会讲到为什么f[0]也要设置为1。</span><br><span class="line">我们要清楚，声明了prev和cur，就是为了看看当前数和前一个数能不能组合起来解码.</span><br><span class="line">进入判断循环,i从2开始，这是为了配合dp数组，因为我们说了dp[i]表示前i个数的解：</span><br><span class="line">       那么cur就是s[i - 1]了，这是s数组的第二个数，prev我们在前面已经声明了。</span><br><span class="line">       首先就是判断无法解码的情况，也就是cur为0，prev也为0或者prev大于2，既不能自己单独解码，也不能和前面组合解码。</span><br><span class="line">       然后判断可以解码的情况，有组合解码和单独解码</span><br><span class="line">          组合解码又分为11~19,21~26，因为10和20比较特殊，前者既能单独解码，又能组合解码，后者只能单独解码的两位数</span><br><span class="line">          然后单独解码就是只能单独一个解码</span><br><span class="line">       下一轮判断，把cur变成prev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为什么f[0]也为1？ 这里摘抄了网友的一个不错的理解：</span><br><span class="line">f[0]代表前0个数字的方案数，这样的状态定义其实是没有实际意义的，但是f[0]的值需要保证边界是对的，即f[1]和f[2]是对的。</span><br><span class="line">比如说，第一个数不为0，那么解码前1个数只有一种方法，将其单独解码，即f[1] = f[1 - 1] = 1。</span><br><span class="line">解码前两个数，如果第1个数和第2个数可以组合起来解码，那么f[2] = f[1] + f[0] = 2 ，否则只能单独解码第2个数，即f[2] = f[1] = 1。</span><br><span class="line">因此，在任何情况下f[0]取1都可以保证f[1]和f[2]是正确的，所以f[0]应该取1。</span><br><span class="line"></span><br><span class="line">然后的话，我们在代码中有一个10和20的特殊解码，dp[i] = dp[i - 2]。因为这里说了如果只能单独解码的话，就f[1] = f[1 - 1] = 1。</span><br><span class="line"></span><br><span class="line">实在不能理解。试试s=20,s=23，尝试自己去理解一下。</span><br></pre></td></tr></table></figure>
<h2 id="139-单词拆分-medium"><a href="#139-单词拆分-medium" class="headerlink" title="139 单词拆分 medium"></a>139 单词拆分 medium</h2><p>这道题类似于完全平方数分割。然后看到评论题解说用背包问题：单词就是物品，字符串s就是背包，完全背包问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j] == <span class="literal">true</span>) &#123; <span class="comment">//contains比较少用，mark</span></span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">卡哥将得很详细，复制一下记录</span><br><span class="line">单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。</span><br><span class="line"></span><br><span class="line">拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span><br><span class="line"></span><br><span class="line">动规五部曲分析如下：</span><br><span class="line"></span><br><span class="line">1.确定dp数组以及下标的含义</span><br><span class="line">dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">2.确定递推公式</span><br><span class="line">如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i ）。</span><br><span class="line"></span><br><span class="line">所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</span><br><span class="line"></span><br><span class="line">3.dp数组如何初始化</span><br><span class="line">从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</span><br><span class="line"></span><br><span class="line">那么dp[0]有没有意义呢？</span><br><span class="line"></span><br><span class="line">dp[0]表示如果字符串为空的话，说明出现在字典里。</span><br><span class="line"></span><br><span class="line">但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</span><br><span class="line"></span><br><span class="line">下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">4.确定遍历顺序</span><br><span class="line">题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</span><br><span class="line"></span><br><span class="line">还要讨论两层for循环的前后循序。</span><br><span class="line"></span><br><span class="line">如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span><br><span class="line"></span><br><span class="line">如果求排列数就是外层for遍历背包，内层for循环遍历物品。</span><br><span class="line"></span><br><span class="line">本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</span><br><span class="line"></span><br><span class="line">那么本题使用求排列的方式，还是求组合的方式都可以。</span><br><span class="line"></span><br><span class="line">即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</span><br><span class="line"></span><br><span class="line">但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</span><br><span class="line"></span><br><span class="line">如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</span><br><span class="line"></span><br><span class="line">所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。</span><br><span class="line"></span><br><span class="line">5.举例推导dp[i]</span><br><span class="line">以输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]为例，dp状态如图：</span><br><span class="line">（在下方）</span><br><span class="line">dp[s.size()]就是最终结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">五部曲中第一部是最困难的. 一般都是遵循&quot;题目问什么, 就把`dp[]设置成什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：carlsun-2</span><br><span class="line">链接：https://leetcode.cn/problems/word-break/solution/dai-ma-sui-xiang-lu-139-dan-ci-chai-fen-50a1a/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/139.jpg"></p>
<h2 id="300-最长递增子序列-medium"><a href="#300-最长递增子序列-medium" class="headerlink" title="300 最长递增子序列 medium"></a>300 最长递增子序列 medium</h2><p>首先说明题目说的升序是严格升序，比如777长递增子序列就只有7，也就是长度只有1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跟之前的题目有点不同的是dp声明不需要额外声明多一个，因为本题是返回最大值。同样也是卡尔的题解。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);<span class="comment">//别忘了初试填充1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//这里还有一个循环</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);<span class="comment">//状态转移方程很重要，注意这里是max，而不是比较dp[i], dp[j] + 1</span></span><br><span class="line">                &#125;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//找出最大值即可</span></span><br><span class="line">            res = Math.max(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">卡哥动态规划五部曲</span><br><span class="line">最长上升子序列是动规的经典题目，这里dp[i]是可以根据dp[j] （j &lt; i）推导出来的，那么依然用动规五部曲来分析详细一波：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i]的定义</span><br><span class="line">dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>状态转移方程</span><br><span class="line">位置i的最长升序子序列等于j从<span class="number">0</span>到i-<span class="number">1</span>各个位置的最长升序子序列 + <span class="number">1</span> 的最大值。</span><br><span class="line"></span><br><span class="line">所以：<span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">注意这里不是要dp[i] 与 dp[j] + <span class="number">1</span>进行比较，而是我们要取dp[j] + <span class="number">1</span>的最大值。</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>dp[i]的初始化</span><br><span class="line">每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是<span class="number">1.</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>确定遍历顺序</span><br><span class="line">dp[i] 是有<span class="number">0</span>到i-<span class="number">1</span>各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>举例推导dp数组</span><br><span class="line">输入：[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">2</span>]，dp数组的变化如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/300.jpg"></p>
<h2 id="1143-最长公共子序列-medium"><a href="#1143-最长公共子序列-medium" class="headerlink" title="1143 最长公共子序列 medium"></a>1143 最长公共子序列 medium</h2><p>需要注意的是本题要求：”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。本题单纯是动态规划，不是背包问题哦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般如果返回dp数组，就好像申请的长度加+1，这样是为了好处理，</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> text1.length(), m = text2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];<span class="comment">//除了定义dp，它还会全部设置为0，像之前有些题是初始化为1，要注意对比</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;<span class="comment">//上面是从1开始，所以我们对比的第一个数是i-1和j-1</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">卡哥的解释比较好懂</span><br><span class="line"><span class="number">1.</span>确定dp数组（dp table）以及下标的含义</span><br><span class="line">dp[i][j]：长度为[<span class="number">0</span>, i - <span class="number">1</span>]的字符串text1与长度为[<span class="number">0</span>, j - <span class="number">1</span>]的字符串text2的最长公共子序列为dp[i][j]</span><br><span class="line"></span><br><span class="line">有同学会问：为什么要定义长度为[<span class="number">0</span>, i - <span class="number">1</span>]的字符串text1，定义为长度为[<span class="number">0</span>, i]的字符串text1不香么？</span><br><span class="line"></span><br><span class="line">这样定义是为了后面代码实现方便，如果非要定义为为长度为[<span class="number">0</span>, i]的字符串text1也可以，大家可以试一试！</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">主要就是两大情况： text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]相同，text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]不相同</span><br><span class="line"></span><br><span class="line">如果text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">如果text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]不相同，那就看看text1[<span class="number">0</span>, i - <span class="number">2</span>]与text2[<span class="number">0</span>, j - <span class="number">1</span>]的最长公共子序列 和 text1[<span class="number">0</span>, i - <span class="number">1</span>]与text2[<span class="number">0</span>, j - <span class="number">2</span>]的最长公共子序列，取最大的。</span><br><span class="line"></span><br><span class="line">即：dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>dp数组如何初始化</span><br><span class="line">先看看dp[i][<span class="number">0</span>]应该是多少呢？</span><br><span class="line"></span><br><span class="line">test1[<span class="number">0</span>, i-<span class="number">1</span>]和空串的最长公共子序列自然是<span class="number">0</span>，所以dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">同理dp[<span class="number">0</span>][j]也是<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">其他下标都是随着递推公式逐步覆盖，初始为多少都可以，那么就统一初始为<span class="number">0</span>。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>从递推公式，可以看出，有三个方向可以推出dp[i][j]，如图：</span><br><span class="line">(下面第一张图)</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>举例推导dp数组</span><br><span class="line">以输入：text1 = <span class="string">&quot;abcde&quot;</span>, text2 = <span class="string">&quot;ace&quot;</span> 为例，dp状态如图：</span><br><span class="line">(下面第二张图)</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/1143-1.jpg"><br><img src="/images/leetcode-java/1143-2.jpg"></p>
<h2 id="416-分割等和子集-medium（0-1背包）"><a href="#416-分割等和子集-medium（0-1背包）" class="headerlink" title="416 分割等和子集 medium（0-1背包）"></a>416 分割等和子集 medium（0-1背包）</h2><p>本题是0-1背包问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums)&#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];<span class="comment">//已经默认初始化为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= nums[i]; j--) &#123;<span class="comment">//逆向循环，而且注意j &gt;= nums[i]，我自己的理解是当可以放进去时候的操作，注意物品i的重量是nums[i]，其价值也是nums[i]</span></span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target == dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体看<a target="_blank" rel="noopener" href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF">Carl的解释</a>，写得挺好，需要好好理解转移方程Math.max(dp[j], dp[j - nums[i]] + nums[i]);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题和完全背包问题的区别的是，一个是物品只能拿一次，一个物品无限拿。</span><br><span class="line">循环上也有区别：</span><br><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题物品的迭代放外层，里层的体积或价值逆向遍历，物品放外面，循环完就没了，也就是物品只能拿一次。</span><br><span class="line">完全背包对物品的迭代放里层，外层的体积或价值正向遍历，物品放里面，每次外层循环都会重新循环物品，也就是物品是无限拿的。</span><br><span class="line">本题可以对比看看<span class="number">139</span>。</span><br><span class="line">简单说明几点</span><br><span class="line">dp[j] 表示： 容量为j的背包，所背的物品价值可以最大为dp[j]，我们本题的容量是sum/<span class="number">2</span> + <span class="number">1</span>来确定的，本题上的dp[j]表示背包总容量是j，最大可以凑成j的子集总和为dp[j]</span><br><span class="line"></span><br><span class="line">本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。</span><br><span class="line">所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br></pre></td></tr></table></figure>
<h3 id="背包问题全理解"><a href="#背包问题全理解" class="headerlink" title="背包问题全理解"></a>背包问题全理解</h3><p>下面是背包问题总结（Carl的笔记加上我自己的理解）：</p>
<p>二维dp数组01背包<br>1.确定dp数组以及下标的含义<br>对于背包问题，有一种写法， 是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。要时刻记着这个dp数组的含义，也就是一共涉及三个数，一个是物品，一个是容量，然后数组里面存的是价值，数组如图展示：<br><img src="/images/leetcode-java/bag-1.png"></p>
<p>2.确定递推公式<br>再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。</p>
<p>那么可以有两个方向推出来dp[i][j]，</p>
<p>不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)<br>放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值<br>所以递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</p>
<p>这里一开始不能理解dp[i - 1][j - weight[i]] + value[i]，因为我一开始想，万一背包里面本来就有东西，为什么仅仅判断j&gt;weight[i]就说能放进去呢?是我多虑了，因为二维数组覆盖了所有情况呀。<br>举个例子，背包容量是4，刚好我们物品大小也是4，这时候j-4＝0，我们会去检查i-1情况下0的价值，如果背包容量是5，那就去检查j-4&#x3D;1时候的价值，所以不存在说本来有东西，他会跳到上一步检查的。</p>
<p>3.dp数组如何初始化<br>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</p>
<p>首先从dp[i][j]的定义出发，如果背包容量j为0的话，即dp[i][0]，无论是选取哪些物品，背包价值总和一定为0。如图：<br><img src="/images/leetcode-java/bag-2.png"><br>再看其他情况。</p>
<p>状态转移方程 dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。</p>
<p>dp[0][j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。</p>
<p>那么很明显当 j &lt; weight[0]的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。</p>
<p>当j &gt;&#x3D; weight[0]时，dp[0][j] 应该是value[0]，因为背包容量放足够放编号0物品。<br>此时dp数组初始化情况如图所示<br><img src="/images/leetcode-java/bag-3.png"><br>dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？</p>
<p>其实从递归公式： dp[i][j] &#x3D; max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]); 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。</p>
<p>初始-1，初始-2，初始100，都可以！</p>
<p>但只不过一开始就统一把dp数组统一初始为0，更方便一些。</p>
<p>4.确定遍历顺序<br>在如下图中，可以看出，有两个遍历的维度：物品与背包重量<br><img src="/images/leetcode-java/bag-4.png"><br>那么问题来了，先遍历 物品还是先遍历背包重量呢？</p>
<p>其实都可以！！ 不过这里针对的是二维数组。</p>
<p>5.举例推导dp数组<br>来看一下对应的dp数组的数值，如图<br><img src="/images/leetcode-java/bag-5.jpg"></p>
<p>一维dp数组01背包<br>1.确定dp数组的定义<br>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。</p>
<p>2.一维dp数组的递推公式<br>dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？</p>
<p>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。</p>
<p>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）</p>
<p>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1][j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，</p>
<p>所以递归公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure>
<p>3.一维dp数组如何初始化<br>关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱。</p>
<p>dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。</p>
<p>那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？</p>
<p>看一下递归公式：dp[j] &#x3D; max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。</p>
<p>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。</p>
<p>那么我假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了。</p>
<p>4.一维dp数组遍历顺序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！</p>
<p>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。</p>
<p>为什么呢？</p>
<p>倒序遍历是为了保证物品i只被放入一次！。但如果一旦正序遍历了，那么物品0就会被重复加入多次！</p>
<p>看完之后发现，也就是二维数组必须要顺着，如果用一维数组处理，要倒着，至于为什么这里需要好好看<a target="_blank" rel="noopener" href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html#%E4%BA%8C%E7%BB%B4dp%E6%95%B0%E7%BB%8401%E8%83%8C%E5%8C%85">卡哥的网站</a>。</p>
<h2 id="474-一和零-medium-（0-1背包）"><a href="#474-一和零-medium-（0-1背包）" class="headerlink" title="474 一和零 medium （0-1背包）"></a>474 一和零 medium （0-1背包）</h2><p>注意这个不是多重背包问题。本题就是0-1背包问题。具体看<a target="_blank" rel="noopener" href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html#%E6%80%9D%E8%B7%AF">卡哥解释</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题相当于有两个维度的背包，m和n。</span></span><br><span class="line"><span class="comment">而不同长度的字符串就是不同大小的待装物品。</span></span><br><span class="line"><span class="comment">这里是求子集的个数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];<span class="comment">//虽然这个是二维数组，但是不是我们理解那个用二维数组解决的背包问题，这是拥有两个维度的背包，实际上我们是用滚动数组来做的。</span></span><br><span class="line">        <span class="keyword">for</span> (String str:strs) &#123;<span class="comment">//先遍历物品</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">onenum</span> <span class="operator">=</span> <span class="number">0</span>, zeronum = <span class="number">0</span>;<span class="comment">//每次遍历物品都要重新计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;<span class="comment">//这个写法mark</span></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//统计每个物品的0和1的数量，注意我们是一个字符串当成一个物品。</span></span><br><span class="line">                    zeronum++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    onenum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值value[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zeronum; i--) &#123;<span class="comment">//请注意这里是在遍历物品的内部循环，然后这个m是背包容量，逆序遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= onenum; j--) &#123;<span class="comment">//背包的第二个维度，也是逆序遍历</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - zeronum][j - onenum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="322-零钱兑换-medium（完全背包）"><a href="#322-零钱兑换-medium（完全背包）" class="headerlink" title="322 零钱兑换 medium（完全背包）"></a>322 零钱兑换 medium（完全背包）</h2><p>每种币的数量是无限，本题属于完全背包问题。注意这个题要取最小的。<a target="_blank" rel="noopener" href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html#_322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2">讲解链接。</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个更好理解，先遍历背包，再遍历物品，和之前不太一样的是，我们取最小的，这点对初始化很重要哦，而且在判断上也要注意一点。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);<span class="comment">//除了0位置，必须要初始化为最大值，不然你要是都是0，用min的时候就都变成0了，被覆盖掉了</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//同上面一样的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= amount; i++) &#123;<span class="comment">//先遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; coins.length; j++) &#123;<span class="comment">//遍历物品，这种写法就比较好理解用无限硬币</span></span><br><span class="line">                <span class="keyword">if</span> (i- coins[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i - coins[j]] != Integer.MAX_VALUE) &#123;<span class="comment">//后面这个不为max值很重要，不然到最后max值会变成负数，然后有这个判断就可以跳过。只有dp[i-coins[j]]不是初始最大值时，该位才有选择的必要</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);<span class="comment">//必须要背包容量打于当前的coin大小才进入这一步</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//物品是coin，背包是amount，这个写法是先遍历物品，再遍历背包，我感觉不如上面一个好理解。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);<span class="comment">//因为求min，所以要把除了0位置的地方赋值为最大值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//把0位置赋值为0，因为你的钱要是为0，就不可能用任何硬币来组合。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;<span class="comment">//物品外循环</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class="comment">//背包内循环 当然这个题也可以反过来循环，不过if条件要改变。本题钱币数量可以无限使用，那么是完全背包。所以遍历的内循环是正序</span></span><br><span class="line">                <span class="keyword">if</span> ((dp[j - coins[i]]) != Integer.MAX_VALUE) &#123;<span class="comment">//只有dp[j-coins[i]]不是初始最大值时，该位才有选择的必要</span></span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这里一开始写内循环是j = 0，但是我们要每个时候都要想dp[j]代表什么含义，当j为0，直接减去coin就是负数了，不过还是没特别理解，多做题把。</span></span><br><span class="line"><span class="comment">dp[j]：凑足总额为j所需钱币的最少个数为dp[j]*/</span></span><br></pre></td></tr></table></figure>
<h2 id="72-编辑距离-hard"><a href="#72-编辑距离-hard" class="headerlink" title="72 编辑距离 hard"></a>72 编辑距离 hard</h2><p>注意word1变成word2，中间的操作不需要指定多少次，反正直到变成word2，增删替都能无数次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> word1.length(), n  = word2.length();</span><br><span class="line">        <span class="type">int</span>[][] dp =  <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;=m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;=n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=m ;i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">这个需要理解几个点，跟其他动态规划有点不一样，但是又是相似的套路。</span><br><span class="line">1.dp[i][j]含义：dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。</span><br><span class="line">注意是到这个位置结尾的单词，而不是整个单词。</span><br><span class="line">时刻理解dp含义！时刻理解dp含义！时刻理解dp含义！时刻理解dp含义！</span><br><span class="line">2.注意删除操作和增加操作是一回事</span><br><span class="line"></span><br><span class="line">理解 word1 上的删除等价 word2 上的增加, word1 上的增加等价于 word2 上的删除，另外一个博主的理解：dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。</span><br><span class="line"></span><br><span class="line">按照我自己理解把</span><br><span class="line">删除操作：我们这时候要删掉word这个位置的元素，那么我向word1前推一个字符查看那时候的步数，也就是dp[i-1]，j位置不变，然后再加上删除这个操作就可以+1步数。</span><br><span class="line">替换操作：word1和word2这个位置没有删除，没有添加，那就同时推前面一个元素。</span><br><span class="line">增加操作(等价于word2删除)：word1这个位置要增加元素操作，然后我们知道word1的增加等价于word2删除，那就dp[j-1]推前一个位置，i不变。</span><br><span class="line">3.初始化和其他方法很不同，因为我们要理解dp[i][0]的含义，dp[i][0] ：以下标i-1为结尾的字符串word1，和空字符串word2，最近编辑距离为dp[i][0]。</span><br><span class="line"></span><br><span class="line">那么dp[i][0]就应该是i，对word1里的元素全部做删除操作，即：dp[i][0] = i，相反dp[0][j]就是对元素进行添加。</span><br><span class="line"></span><br><span class="line">注意上面是i，而不是word1的长度，而不是word1的长度，而不是word1的长度，而不是word1的长度，务必时刻理解dp[i][j]的含义。</span><br></pre></td></tr></table></figure>
<p>借一张图理解，比如ho和ro那个黄色格子(2,2)的意思就是(1,1)一样的步数，那么(1,1)的理解就是h变成r的过程步数，怎么变不重要，我们只关心步数。<br><img src="/images/leetcode-java/72.png"></p>
<h2 id="650-只有两个键的键盘-medium"><a href="#650-只有两个键的键盘-medium" class="headerlink" title="650 只有两个键的键盘 medium"></a>650 只有两个键的键盘 medium</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复制算一次，粘贴算一次</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSteps</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);<span class="comment">//求min务必要初始化最大值</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//但是1是0，因为笔记本上本来就存在一个A，不需要操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;<span class="comment">//也可写成 j &lt;= i，不过除以2更好，要明白复制粘贴的意义，也就是翻倍的意思</span></span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;<span class="comment">//必须要被除尽才可以，这样说明j个A可以通过复制粘贴得到i个A</span></span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[j] + i / j);<span class="comment">//比如6可以除以3，也可以除以2，但是我们要拿最小次数来复制粘贴，当然这里只是打个比方，可能3和2次数一样</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">注意复制是一次操作，粘贴又是一次操作</span><br><span class="line">总体思路：对每一个格子i（i个A），如果i可以被j除尽，说明j个A可以通过复制粘贴得到i个A，复制粘贴次数为i / j。</span><br><span class="line">每个格子的意义：得到目前数量个A需要的最少操作次数</span><br><span class="line">递推公式：dp[i] = min(dp[i], dp[j] + i / j)dp[i]=min(dp[i],dp[j]+i/j)，其中i % j == 0i</span><br><span class="line">初始化：1个A不需要操作，初始化为0</span><br><span class="line"></span><br><span class="line">作者：Reconcile</span><br><span class="line">链接：https://leetcode.cn/problems/2-keys-keyboard/solution/dong-tai-gui-hua-jie-fa-by-reconcile-t3fr/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里举个例子，dp[1]~dp[5]的情况是0 2 3 4 5 </span><br><span class="line">到了dp[6]，答案也是5，因为6可以复制3的情况，然后再粘贴，那么3本身需要3次，6/3=2,3+2＝5。也就是i/j是复制粘贴的次数。</span><br><span class="line"></span><br><span class="line">这里理解下为什么是i/j次，比如dp[8]，</span><br><span class="line">如果我们是复制dp[2]的情况，需要8/2=4次，首先复制AA，然后粘贴三次，一共四次操作加上dp[2]操作。</span><br><span class="line">如果复制dp[4]的情况，8/4=2，首先复制AAAA，然后粘贴一次，一共2次操作加上dp[4]操作。</span><br><span class="line">如果复制dp[1]的情况，8/1=8，首先复制A，然后粘贴七次，一共8次操作加上dp[1]操作。</span><br><span class="line">当然，上面的情况要比较然后取最小值。</span><br></pre></td></tr></table></figure>
<h2 id="10-正则表达式匹配-hard-未完成"><a href="#10-正则表达式匹配-hard-未完成" class="headerlink" title="10 正则表达式匹配 hard(未完成)"></a>10 正则表达式匹配 hard(未完成)</h2><h2 id="121-买卖股票的最佳时机-easy"><a href="#121-买卖股票的最佳时机-easy" class="headerlink" title="121 买卖股票的最佳时机 easy"></a>121 买卖股票的最佳时机 easy</h2><p>这个题目的股票只买卖一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态回归，符合本章节，但是最简单还是贪心算法，因为这个题目的股票只买卖一次。这个做法没有具体去理解，可以看卡哥解释。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp[i][0]代表第i天持有股票的最大收益</span></span><br><span class="line">        <span class="comment">// dp[i][1]代表第i天不持有股票的最大收益</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[length][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第0天不持有股票最大收益</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法，最简单这个</span></span><br><span class="line"><span class="comment">//取左边低值，取右边高值即可，因为只买卖一次。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            low = Math.min(low, prices[i]);</span><br><span class="line">            result = Math.max(result, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个答案是超时的，但至少是自己想出来的，哎，太暴力了。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (prices[j] - prices[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], prices[j] - prices[i]);</span><br><span class="line">                    result = Math.max(result, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188 买卖股票的最佳时机 IV"></a>188 买卖股票的最佳时机 IV</h2><p>这个题目是可以最多交易K次，也就是你交易的次数可以少于k，但是必须在再次购买前出售掉之前的股票，而且利润要最大化。k为1，也就是可以买一次，卖一次，这个算交易一次。k为2，也就是一共可以买2次，卖两次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span> * k; i += <span class="number">2</span>) &#123;<span class="comment">//只初始化第0天的买入状态，然后其他是默认0</span></span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">//第0天上面已经初始化好了，所以直接从第一天开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span> * k - <span class="number">1</span>; j += <span class="number">2</span>) &#123;<span class="comment">//状态要从0开始，然后隔两个操作，长度是2k-1是因为我们总的长度是2k+1，然后现在隔2来操作，只有长度为2k-1才不至于越界，因为2k-1+2为2k+1，这是总长度</span></span><br><span class="line">                dp[i][j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">1</span>], dp[i - <span class="number">1</span>][j] - prices[i]); <span class="comment">//处理买入股票的状态</span></span><br><span class="line">                dp[i][j + <span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][j + <span class="number">2</span>], dp[i - <span class="number">1</span>][j + <span class="number">1</span>] + prices[i]);<span class="comment">//处理卖出股票的状态</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][k * <span class="number">2</span>];<span class="comment">//i的大小是n，那么最后的坐标就是n-1,j的大小是k*2+1，那么坐标就是k*2。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">重点理解</span><br><span class="line">dp长度是dp[price.length][2 * k + 1]</span><br><span class="line">也就是每一天都有2k+1个状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">务必清楚dp[i][j]的意思是第i天买入股票的状态是j</span><br><span class="line">最少有3个状态，0代表不操作，1代表第一次买入，2代表第第一次卖出，如果你的k是2，那么也许还有第二次买入，第二次卖出，当然了，你的交易次数最大是k，不一定非要用完k</span><br><span class="line"></span><br><span class="line">首先是初始化，dp[0][i] = -prices[0];表示买入，因为你买入就是钱是负数，然后如果卖出的话，当前价格加上上次买入的状态，就是你的利润，如-1+5=4，一开始我们买入价格是1，置为负数，然后卖出的时候价格是4，就可以得到利润了，还需要注意我们必须买入第二次的时候，第一次已经交易完毕了，不能连续买入而没有卖出，所以，只要是买入状态，就是负数。</span><br><span class="line"></span><br><span class="line">其次是状态的改变：</span><br><span class="line">dp[i][1]状态有两个情况，我们上面说1就是买入状态，但是这里需要更详细说明，1可能是两个操作，买入和不操作状态。</span><br><span class="line">不操作就是延续前一天的状态：dp[i - 1][1]：前一天买入的状态</span><br><span class="line">买入就是dp[i - 1][0] - price[0]：前一天不操作的状态</span><br><span class="line"></span><br><span class="line">dp[i][2]状态有两个情况，我们上面说2就是卖出状态，但是这里需要更详细说明，2可能是两个操作，卖出和不操作状态。</span><br><span class="line">不操作就是延续前一天的状态：dp[i - 1][2]：前一天不操作的状态</span><br><span class="line">卖出就是dp[i - 1][1] + price[i]：前一天买了股票的钱再加上今天卖出的价格</span><br></pre></td></tr></table></figure>
<h2 id="309-最佳买卖股票时机含冷冻期-medium"><a href="#309-最佳买卖股票时机含冷冻期-medium" class="headerlink" title="309 最佳买卖股票时机含冷冻期 medium"></a>309 最佳买卖股票时机含冷冻期 medium</h2><p>和上一题的区别是，多了一个冷冻期，也就是卖出的第二天不能买入股票，<a target="_blank" rel="noopener" href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html#%E6%80%9D%E8%B7%AF">卡哥笔记</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || prices == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]));</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], Math.max(dp[n - <span class="number">1</span>][<span class="number">2</span>], dp[n - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">主要是理解四个状态的情况和初始化的情况，具体看卡哥的笔记，这里简单写4个状态的意思</span><br><span class="line">0：买入股票状态（今天买入股票，或者是之前就买入了股票然后没有操作）</span><br><span class="line">1：两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span><br><span class="line">2：今天卖出了股票</span><br><span class="line">3：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！</span><br><span class="line">其中1和2都是属于卖出股票的状态，只是分成更细的。</span><br></pre></td></tr></table></figure>
<h2 id="213"><a href="#213" class="headerlink" title="213"></a>213</h2><h2 id="53"><a href="#53" class="headerlink" title="53"></a>53</h2><h2 id="343"><a href="#343" class="headerlink" title="343"></a>343</h2><h2 id="583"><a href="#583" class="headerlink" title="583"></a>583</h2><h2 id="646"><a href="#646" class="headerlink" title="646"></a>646</h2><h2 id="376"><a href="#376" class="headerlink" title="376"></a>376</h2><h2 id="494"><a href="#494" class="headerlink" title="494"></a>494</h2><h2 id="714"><a href="#714" class="headerlink" title="714"></a>714</h2><h1 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h1><h2 id="241-为运算表达式设计优先级-medium"><a href="#241-为运算表达式设计优先级-medium" class="headerlink" title="241 为运算表达式设计优先级 medium"></a>241 为运算表达式设计优先级 medium</h2><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/different-ways-to-add-parentheses/solution/xin-ren-xiang-tong-su-yi-dong-java-fen-z-3xhh/">注意本题只有加减乘三个符号，没有除号，这个博主讲得是最详细容易理解的</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//博主的答案，额外有些不明白的地方多加了解释，分治的思想就是把原问题分成子问题，然后再合并起来。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">diffWaysToCompute</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> divideAndConquer(expression.toCharArray());<span class="comment">//将字符串转换为字符数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">divideAndConquer</span><span class="params">(<span class="type">char</span>[] expression)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//处理一个数字的情况也就是分治划分到最底层的时候</span></span><br><span class="line">        <span class="comment">//isOneNum函数用来判断当前的表达式是否为一个单独的数字</span></span><br><span class="line">        <span class="keyword">if</span> (isOneNum(expression))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//将该数字从char数组转换为一个int型数值</span></span><br><span class="line">             <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class="line">                 num = num*<span class="number">10</span> +expression[i]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//比如98，一开始num为9，下一个循环就是9*10+&#x27;8&#x27;-&#x27;0&#x27;即为98，这里注意下字符要中ASILL码转换</span></span><br><span class="line">             &#125;</span><br><span class="line">             res.add(num);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(expression[i]))&#123;<span class="comment">//扫描到有运算符的情况</span></span><br><span class="line">                <span class="type">char</span>[] left = <span class="keyword">new</span> <span class="title class_">char</span>[i];<span class="comment">//生成左边表达式</span></span><br><span class="line">                <span class="type">char</span>[] right = <span class="keyword">new</span> <span class="title class_">char</span>[expression.length-i-<span class="number">1</span>];<span class="comment">//生成右边表达式</span></span><br><span class="line">                <span class="comment">//切分左右分治所使用的表达式数组</span></span><br><span class="line">                System.arraycopy(expression,<span class="number">0</span>,left,<span class="number">0</span>,i);<span class="comment">//复制左边数组，注意是不含i这个位置的运算符的，具体看下面的例子你就知道，i代表长度</span></span><br><span class="line">                System.arraycopy(expression,i+<span class="number">1</span>,right,<span class="number">0</span>,expression.length-i-<span class="number">1</span>);<span class="comment">//复制右边数组</span></span><br><span class="line">                <span class="comment">//对左边的表达式在进行一次同样的操作  这里是体现分治的思想吧？</span></span><br><span class="line">                List&lt;Integer&gt; leftList = divideAndConquer(left);</span><br><span class="line">                <span class="comment">//对右边的表达式在进行一次同样的操作</span></span><br><span class="line">                List&lt;Integer&gt; rightList = divideAndConquer(right);</span><br><span class="line">                <span class="comment">//计算左右两个表达式在当前用来切分的运算符进行运算后得到的所有可能的结果</span></span><br><span class="line">                List&lt;Integer&gt; tempRes = calculate(leftList,rightList,expression[i]);</span><br><span class="line">                <span class="comment">//将这些结果加入最后的列表中作为这一层分治的最终结果</span></span><br><span class="line">                <span class="keyword">for</span> (Integer num:tempRes)&#123;</span><br><span class="line">                    res.add(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;<span class="comment">//这里容易漏掉</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//calculate函数用来对两个列表的数值逐个进行计算</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">calculate</span><span class="params">(List&lt;Integer&gt; listOne,List&lt;Integer&gt; listTwo,<span class="type">char</span> operator)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;listOne.size();i++)&#123;<span class="comment">//一开始不明白这里为什么有两个循环，请看下面的例子就知道了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;listTwo.size();j++)&#123;</span><br><span class="line">                res.add(calculateTwoNums(listOne.get(i),listTwo.get(j),operator));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//简单的计算函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">calculateTwoNums</span><span class="params">(<span class="type">int</span> num1,<span class="type">int</span> num2,<span class="type">char</span> operator)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1+num2;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> num1-num2;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> num1*num2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//判断是否当前表达式是否为一个数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isOneNum</span><span class="params">(<span class="type">char</span>[] expression)</span>&#123;<span class="comment">//把表达式都扫描一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;expression.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(expression[i]))<span class="comment">//只要发现有一个不是数字，就返回false，</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//如果扫描完全部都是数字，就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy（）是一种本地静态方法，用于将元素从源数组复制到目标数组。</span><br><span class="line">public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span><br><span class="line">Object src : 原数组</span><br><span class="line">int srcPos : 从元数据的起始位置开始</span><br><span class="line">Object dest : 目标数组</span><br><span class="line">int destPos : 目标数组的开始起始位置</span><br><span class="line">int length : 要copy的数组的长度</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">以&quot;2*3-4*5&quot;为例子，看看是如何计算的</span><br><span class="line"></span><br><span class="line">第一轮情况</span><br><span class="line">left and right</span><br><span class="line">2    3-4*5</span><br><span class="line">left and right</span><br><span class="line">3    4*5</span><br><span class="line">left and right</span><br><span class="line">4    5</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[4]    *    [5]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[3]    -    [20]</span><br><span class="line"></span><br><span class="line">left and right</span><br><span class="line">3-4    5</span><br><span class="line">left and right</span><br><span class="line">3    4</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[3]    -    [4]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[-1]    *    [5]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[2]    *    [-17, -5]  //也就是(3-4)*5和3-(4*5)，这也解释了为什么calculate为什么是两个循环。第一和第二个结果出来了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二轮情况</span><br><span class="line">left and right</span><br><span class="line">2*3    4*5</span><br><span class="line">left and right</span><br><span class="line">2    3</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[2]    *    [3]</span><br><span class="line"></span><br><span class="line">left and right</span><br><span class="line">4    5</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[4]    *    [5]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[6]    -    [20]   //第三个结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第三轮情况</span><br><span class="line">left and right</span><br><span class="line">2*3-4    5</span><br><span class="line">left and right</span><br><span class="line">2    3-4</span><br><span class="line">left and right</span><br><span class="line">3    4</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[3]    -    [4]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[2]    *    [-1]</span><br><span class="line"></span><br><span class="line">left and right</span><br><span class="line">2*3    4</span><br><span class="line">left and right</span><br><span class="line">2    3</span><br><span class="line"></span><br><span class="line">leftlist and rightlist</span><br><span class="line">[2]    *    [3]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[6]    -    [4]</span><br><span class="line">leftlist and rightlist</span><br><span class="line">[-2, 2]    *    [5]  //第四和第五个结果</span><br><span class="line"></span><br><span class="line">答案为[-34, -10, -14, -10, 10]</span><br></pre></td></tr></table></figure>
<h2 id="932"><a href="#932" class="headerlink" title="932"></a>932</h2><h2 id="312"><a href="#312" class="headerlink" title="312"></a>312</h2><h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><p><a target="_blank" rel="noopener" href="https://programmercarl.com/">代码随想录</a>正式开刷！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">a.get(i)<span class="comment">//获取第i个元素</span></span><br><span class="line">a.size()</span><br><span class="line">result.add(Arrays.asList(nums[i], nums[left], nums[right])) result是List&lt;List&lt;Integer&gt;&gt; 这样最后的结果类似于[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]，也就是里面的List&lt;Integer&gt;省略，这个出现在<span class="number">15</span>,<span class="number">18</span>题</span><br><span class="line"></span><br><span class="line">String s</span><br><span class="line">s.charAt(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.toString()</span><br><span class="line"></span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">queue.offer(x)<span class="comment">//添加x进去</span></span><br><span class="line">queue.poll()<span class="comment">//取出最后一个元素</span></span><br><span class="line"></span><br><span class="line">HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(key, value)</span><br><span class="line">map.containsKey(key)<span class="comment">//是否存在该元素</span></span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="704-二分查找-easy"><a href="#704-二分查找-easy" class="headerlink" title="704 二分查找 easy"></a>704 二分查找 easy</h3><p>前提是有序，以及没有重复的值，才可以用下面这个算法。<br>下面这个写法是左闭右闭区间，也就是target在这个区间内，所以必须要用小于等于。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123; <span class="comment">//这里要注意是小于等于，比如我们用[5] target=5来举例，l和r都是0，这样就不会进入循环了，所以必须要小于等于。</span></span><br><span class="line">            <span class="type">int</span>  <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left) / <span class="number">2</span>); <span class="comment">//凡是取中间值，必须记住这个公式，如果直接(l+r)/2，可能会溢出。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-移除元素-easy"><a href="#27-移除元素-easy" class="headerlink" title="27 移除元素 easy"></a>27 移除元素 easy</h3><p>注意数组只能覆盖掉哦，所以用到双指针的思路。数组的元素是不能删的，只能覆盖！数组的元素是不能删的，只能覆盖！数组的元素是不能删的，只能覆盖！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题先考虑如果刚好第一个元素就是目标元素，我们应该怎么操作，这时候fast还在第一格，所以不能替换，那么就是先到下一个元素，再替换</span></span><br><span class="line"><span class="comment">那么，所以if应该设置为如果不是这个target的时候再操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> <span class="number">0</span>; fast &lt; nums.length; fast++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">大概思路就是有两个指针，一个快指针一个慢指针</span></span><br><span class="line"><span class="comment">一开始的slow和fast指针都是0，直到遇上val后，这时候fast会比slow多跳一格，也就是slow还是不变，因为我们看代码，只有不等时，slow才会加</span></span><br><span class="line"><span class="comment">那么等到下一次不为val后，我们fast指向的值，就覆盖到之前val的位置上（因为slow指着呢），那么最后slow的指针，也就是最终的长度啦</span></span><br><span class="line"><span class="comment">所以这个题不要来想着怎么去移除元素，而是覆盖元素，运用双指针</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="977-有序数组的平方-easy"><a href="#977-有序数组的平方-easy" class="headerlink" title="977 有序数组的平方 easy"></a>977 有序数组的平方 easy</h3><p>这题给的数组是非递减数组，有负数，如果用暴力算平方然后排序时间复杂度很高，所以没有意思，下面用的是双指针的办法。本题用while的话</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先我们要知道，这是非递减数组，也就是平方之后的最大值，要么是第一个，要么是最后一个，所以可以用双指针的想法去做。</span></span><br><span class="line"><span class="comment">i指向第一个，j指向最后一个，然后判断谁的平方大，大的那个就存到result的最后一个位置，也就是倒着存。</span></span><br><span class="line"><span class="comment">如果是i情况，操作完把i++</span></span><br><span class="line"><span class="comment">如果是j情况，操作完把j--</span></span><br><span class="line"><span class="comment">同时n都要进行相减</span></span><br><span class="line"><span class="comment">因为i和j要看情况要相减，所以在for循环的时候我们发现第三栏空出来没有写了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//别忘了数组最后一个的位置是n-1，而不是n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = n; i &lt;= j;) &#123;<span class="comment">//用小于等于是因为，当他们i和j共同指向这个数后，继续循环对这个数进行操作，不然用小于的话，到了这个数就不进行操作了。</span></span><br><span class="line">            <span class="keyword">if</span> ((nums[i] * nums[i]) &gt; (nums[j]*nums[j])) &#123;</span><br><span class="line">                result[n--] = nums[i] * nums[i++];<span class="comment">//注意前面一个不能i++，因为我们后面还要用到nums[i]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[n--] = nums[j] * nums[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//别忘了数组最后一个的位置是n-1，而不是n</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;<span class="comment">//用小于等于是因为，当他们i和j共同指向这个数后，继续循环对这个数进行操作，不然用小于的话，到了这个数就不进行操作了。</span></span><br><span class="line">            <span class="keyword">if</span> ((nums[i] * nums[i]) &gt; (nums[j]*nums[j])) &#123;</span><br><span class="line">                result[n--] = nums[i] * nums[i++];<span class="comment">//注意前面一个不能i++，因为我们后面还要用到nums[i]</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//这里不能再用条件判断，不然会超时，指不用再判断&lt;</span></span><br><span class="line">                result[n--] = nums[j] * nums[j--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组-medium"><a href="#209-长度最小的子数组-medium" class="headerlink" title="209 长度最小的子数组 medium"></a>209 长度最小的子数组 medium</h3><p>注意是最小哦，举个例子，比如target&#x3D;7，nums&#x3D; [2,3,1,2,4,3],那么连续子数组[1,2,4]和[4,3]都符合，但是要取最小那个，也就是长度为2。本题有点类似于双指针，但是卡哥表达是滑动窗口。还有需要注意，题目是找出<strong>大于等于</strong>target的，一开始还看成等于的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">具体是这么理解的，两个指针，右指针一直走，这时候sum也在累加，一旦sum大于或者出现等于的情况，就把left右移动一位，同时别忘记删除原来的那个left的数字</span></span><br><span class="line"><span class="comment">可以用暴力，但是时间复杂度高，下面这个虽然有while，卡哥解释：不要以为for里放一个while就以为是O(n^2)啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target) &#123;<span class="comment">//题目要求，加个while是为了寻找更小的长度</span></span><br><span class="line">                result = Math.min(result, right - left + <span class="number">1</span>);<span class="comment">//统计长度就是r-l+1</span></span><br><span class="line">                sum -= nums[left++];<span class="comment">//删除原来的left位置上的数字以及left++，如果移动一位还是大于，那就继续while移动，当然了，这时候right是不变的，因为我们还在for循环中</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == Integer.MAX_VALUE ? <span class="number">0</span> : result;<span class="comment">//如果result还是原来的max数，就说明找不到符合的条件，返回0，否则返回result</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="59-螺旋矩阵2-medium"><a href="#59-螺旋矩阵2-medium" class="headerlink" title="59 螺旋矩阵2 medium"></a>59 螺旋矩阵2 medium</h3><p>思路就是一圈圈循环，然后注意控制区间，本题答案是左闭右开写法，这题没涉及什么算法，就是繁琐。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] generateMatrix(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//循环的圈数</span></span><br><span class="line">        <span class="type">int</span> i,j;<span class="comment">//注意必须设置为全局变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//填入的数字，从1开始，一直到n*n</span></span><br><span class="line">        <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">while</span> (loop++ &lt; n / <span class="number">2</span>) &#123;<span class="comment">//这里解释下为什么圈是是n/2，我们想想一个圈的内圈，会上下左右都少一格，也就是x少2，y少2，比如6，第一圈是x是6，第二圈就是4，第三圈就是2，这里代表元素个数，那么用6/2就是总圈数，遇到奇数下面会处理。</span></span><br><span class="line">            <span class="comment">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class="line">            <span class="comment">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class="line">            <span class="comment">//务必注意，进入循环后，loop的值就是1了，代表第loop圈</span></span><br><span class="line">            <span class="keyword">for</span> (j = start; j &lt; n - loop; j++) &#123;<span class="comment">//左开右闭，所以用n-loop来控制，可以看下面卡哥的图就清楚了</span></span><br><span class="line">                res[start][j] = count++;<span class="comment">//模拟上侧从左到右</span></span><br><span class="line">            &#125;<span class="comment">//只有这里是start，下面都是res[i][j]</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = start; i &lt; n - loop; i++) &#123;<span class="comment">//模拟右侧从上到下</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//以3为例，第一圈循环到这里是时候,i和j都变成2了，loop是1，j进入循环内，j首先还是2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里为什么要大于等于loop，我是这么想的，这时候处理右下角的数字，以4为例子，右下角坐标是(3,3)，目前是第一圈，左下角是(3,0),截止点是1(loop),第二圈的左下角是(2,1)，截止点是2(loop)，所以可以大于等于loop，循环完之后就不满足这个条件，就退出去了</span></span><br><span class="line">            <span class="keyword">for</span> (;j &gt;= loop; j--) &#123;<span class="comment">// 模拟下侧从右到左</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (; i &gt;= loop; i--) &#123;<span class="comment">// 模拟左侧从下到上</span></span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;<span class="comment">//别忘了循环完一圈后，开始下一圈了，所以要改变起始点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;<span class="comment">//n为奇数的时候，最后会剩下一格，在while中是没有处理的</span></span><br><span class="line">            res[start][start] = count;<span class="comment">//当然了，也可以为n*n</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卡哥这个图很生动<br><img src="/images/leetcode-java/c-59.png"></p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>务必熟悉定义链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;;<span class="comment">//&#123;&#125;容易漏</span></span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一些总结：</span><br><span class="line">cur一般指向head，pre一般指向<span class="literal">null</span>，如果有虚拟节点，就指向dump，这样保证了head（cur的指向）之前是pre</span><br><span class="line"><span class="number">203</span>：移除元素需要设置虚拟节点，pre和cur，循环的时候<span class="keyword">while</span>（cur！=<span class="literal">null</span>），那么为什么不是cur.next！=<span class="literal">null</span>呢，因为如果你现在到最后一个元素，next必然是空，那么这时候就不会循环，但是如果最后一个元素就是目标val，需要进行操作，而不会进入到循环中</span><br><span class="line">另外，如果一直遇到val，pre不变位置，而是一直指向cur的next，然后cur一直移动</span><br><span class="line"></span><br><span class="line"><span class="number">206</span>:对应反转链表，虚拟节点不好操作，因为你最后要反的，但是pre和cur是要的，pre的话这里没有dump，就先设置为<span class="literal">null</span></span><br><span class="line"><span class="number">19</span>:删除倒数第n个节点，虚拟节点的设置，以及fast和slow需要初试化在dump上而不是head上，因为可能[<span class="number">1</span>]<span class="number">1</span>，如果这样的话，一开始在节点上就不能操作，所以都设置在head的前面</span><br><span class="line">另外，循环是用fast.next!=<span class="literal">null</span>，如果是这样，fast最后是在最后一个元素上，如果直接用fast，则会在<span class="literal">null</span>元素上。然后slow会在需要删除节点的前面一个位置，最后进行改变指针即可</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="203-移除链表元素-easy"><a href="#203-移除链表元素-easy" class="headerlink" title="203 移除链表元素 easy"></a>203 移除链表元素 easy</h3><p>这个是带虚拟头节点的，方便操作,然后设置一个pre和cur指针，如果cur遇到val，就修改pre的next指向，否则pre指向cur，然后cur一直移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意下如何声明链表，因为可能是ACM模式，本解答是在原链表上进行移除，也就是不带虚拟头节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;//下一个节点</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;// 节点的构造函数(无参)</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;// 节点的构造函数(有一个参数)</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;// 节点的构造函数(有两个参数)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.val == val) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;<span class="comment">//当头节点就是目标时，直接把head移动到下一个即可，用while是因为可能遇到[7,7,7] val=7这种情况，就需要一直移动</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;<span class="comment">//当head为空的时，就直接返回null，但是这一句不能写在上面一句之前，比如还是上面那个例子，while后会变成空，然后到了这句就直接返回null，但是如果先写这一句，while执行完后却不会返回null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">       <span class="comment">//当val不是头节点的时候</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;<span class="comment">//声明pre和cur</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> pre.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == val) &#123;<span class="comment">//当cur为目标时候，把pre的next直接指向cur的next即可</span></span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = cur;<span class="comment">//不是目标的时候，继续走下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="707-设计链表-medium"><a href="#707-设计链表-medium" class="headerlink" title="707 设计链表 medium"></a>707 设计链表 medium</h3><p>本答案的链表设计是有虚拟头节点的，这样是为了所有节点可以用一样的操作，不然要分为头节点和其他节点，使用单链表，这个题比较容易漏掉size的数值变化增长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的index起始是0，，也就是我们插入的节点位置就是他的下标位置，所以最大的index是size-1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123;<span class="comment">//题目不需要这个也行，但是我为了练习多写的</span></span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    ListNode head;<span class="comment">//务必注意head是全局变量哦</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyLinkedList</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;<span class="comment">//获取index必须要在size的范围内</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= index; i++) &#123;<span class="comment">//因为我们有一个虚拟头节点，所以要&lt;=index，只有getindex的情况才这样哦，add和delete都不需要</span></span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> currentNode.val;<span class="comment">//返回的值哦</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line"></span><br><span class="line">        addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        addAtIndex(size, val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;<span class="comment">//本题的要求，输入负数则在头部插入</span></span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size ++;<span class="comment">//这个比较容易漏</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;<span class="comment">//找到要插入节点的前驱</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">toAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先让新增的点连接后面，再连接前面。</span></span><br><span class="line">        toAdd.next = pred.next;<span class="comment">//不能和下面一句顺序反过来，不然toAdd的next就断掉了</span></span><br><span class="line">        pred.next = toAdd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;<span class="comment">//这个比较容易漏</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pred</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            pred = pred.next;</span><br><span class="line">        &#125; </span><br><span class="line">        pred.next = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(index);</span></span><br><span class="line"><span class="comment"> * obj.addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj.addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj.deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这里之前有个疑问，为什么每次操作链表都要先声明一个listnode？</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">currentNode</span> <span class="operator">=</span> head;</span><br><span class="line">这样操作的话是cur在动，而head没有动</span><br><span class="line">假设你直接用head操作，这样你第一次getindex是可以的，但是第二次getindex的话，head的位置早就变了。</span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表-easy"><a href="#206-反转链表-easy" class="headerlink" title="206 反转链表 easy"></a>206 反转链表 easy</h3><p>直接在链表的基础上进行反转，也就是改变next的指向，让其反过来，思路就是设置一个pre和cur，然后用temp保存cur的next，再把cur反转到pre。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//需要有个temp来保存cur的next指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//如果cur.next ！= null 会少了设置最后一个节点</span></span><br><span class="line">            temp = cur.next;<span class="comment">//先保存</span></span><br><span class="line">            cur.next = pre;<span class="comment">//指向调转</span></span><br><span class="line">            pre = cur;<span class="comment">//继续移动</span></span><br><span class="line">            cur = temp;<span class="comment">//继续移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-两两交换链表中的节点-meduim"><a href="#24-两两交换链表中的节点-meduim" class="headerlink" title="24 两两交换链表中的节点 meduim"></a>24 两两交换链表中的节点 meduim</h3><p>这个题用了虚拟节点，必须要画图，这样才好理解，定义pre和cur，以两个为一组操作，然后先保存下一组的第一个数，接着操作第一组，改变指针指向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;<span class="comment">//保证有两个节点</span></span><br><span class="line">            temp = cur.next.next;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            pre.next.next = cur;</span><br><span class="line">            cur.next = temp;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/24.jpg"><br>和上一个解答的区别是，这个直接用head代替cur，但是一般我们都是用一个新的cur来写，所以我感觉上面一个风格更适合我。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">while</span> (pre.next != <span class="literal">null</span> &amp;&amp; pre.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next.next;<span class="comment">//先保存一下节点</span></span><br><span class="line">            pre.next = head.next;<span class="comment">//对应步骤一</span></span><br><span class="line">            pre.next.next = head;<span class="comment">//对应步骤二</span></span><br><span class="line">            head.next = temp;<span class="comment">//对应步骤三</span></span><br><span class="line">            pre = head;<span class="comment">//移动一位</span></span><br><span class="line">            head = head.next;<span class="comment">//移动一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;<span class="comment">//注意dump是虚拟节点，所以是dump的next</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/c-24.png"></p>
<h3 id="19-删除链表的倒数第-N-个结点-medium"><a href="#19-删除链表的倒数第-N-个结点-medium" class="headerlink" title="19 删除链表的倒数第 N 个结点 medium"></a>19 删除链表的倒数第 N 个结点 medium</h3><p>这个题一开始想不通怎么去处理倒数这个条件。这就用到了双指针啦，也就是先让fast先跑n步（卡哥说n+1但是我计算后觉得还是n），然后slow和fast同时跑，直到fast移动到末尾（是null哦，不是最后一个元素，也就是最后一个元素的下一个），这时候slow的指向就是待删除的元素，那么在跑的时候，我们再定义一个pre，就可以删除slow元素了。<br>第二次做这个题意识到，这个必须要用一个虚拟节点，不然很难处理[1]1这个情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dump;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">         </span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">            fast = fast.next;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;<span class="comment">//上面两种写法都可以</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//用于保存slow的前面一个元素，方便删除</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre = slow;<span class="comment">//这个必须写第一个顺序，不能写在后面。</span></span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = slow.next;<span class="comment">//slow指向的元素就是我们需要删除的</span></span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dump;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span>) &#123;<span class="comment">//和上面题解的区别</span></span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow.next = slow.next.next;<span class="comment">//和上面题解的区别</span></span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="面试题-02-07-链表相交-easy-同160题"><a href="#面试题-02-07-链表相交-easy-同160题" class="headerlink" title="面试题 02.07. 链表相交 easy 同160题"></a>面试题 02.07. 链表相交 easy 同160题</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/submissions/">题目链接</a>，这个题需要注意交点不是数值相等，而是指针相等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">总体的思路就是定义两个cur，首先是计算他们的长度，然后把长的一个链表放前面，如curA，然后把他们尾部对齐，接着寻找相同的指针即可。</span></span><br><span class="line"><span class="comment">需要注意的是，计算完长度后，请马上让cur重新指向头。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenA</span> <span class="operator">=</span> <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">null</span>) &#123;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;<span class="comment">//这里很关键，计算完长度请马上指向头</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//让curA保持为最长那个，这样方便操作，所以如果B的更长，那就交换一下</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> lenA;</span><br><span class="line">            lenA = lenB;</span><br><span class="line">            lenB = temp;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tem</span> <span class="operator">=</span> curA;<span class="comment">//不能重复用temp</span></span><br><span class="line">            curA = curB;</span><br><span class="line">            curB = tem; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个操作的目的是，让curA移动到和curB对齐的地方</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span> (gap-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) &#123;<span class="comment">//这里不能写成curA.val == curB.val，但是可以通过不少例子，下面举一个例子说明为什么不可以</span></span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA.next;</span><br><span class="line">            curB = curB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//这个不能忘了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">[4,1,8,4,5]</span><br><span class="line">[5,0,1,8,4,5]</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">上面的输入，对齐后是</span><br><span class="line">[5,0,1,8,4,5]</span><br><span class="line">  [4,1,8,4,5]</span><br><span class="line">根据输入，完美可以知道应该是返回8这个节点，但是如果我们用了curA.val == curB.val，则会返回1，这个是错误的</span><br></pre></td></tr></table></figure>
<p>卡哥的图，主要理解curA移动到和curB对齐的地方这个操作<br><img src="/images/leetcode-java/c-02.07.png"></p>
<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><h4 id="141-环形链表-easy"><a href="#141-环形链表-easy" class="headerlink" title="141 环形链表 easy"></a>141 环形链表 easy</h4><p>判断一个链表是否有环，很简单，设置快慢指针，如果最终快指针追上慢指针，说明有环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="142-环形链表II-medium"><a href="#142-环形链表II-medium" class="headerlink" title="142 环形链表II medium"></a>142 环形链表II medium</h4><p>之前做过又忘记！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index1</span> <span class="operator">=</span> fast;</span><br><span class="line">                <span class="type">ListNode</span> <span class="variable">index2</span> <span class="operator">=</span> head;<span class="comment">//第二次写这个题，居然写成slow</span></span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1.next;</span><br><span class="line">                    index2 = index2.next;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> index1;<span class="comment">//也可以返回2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//第二次做这个题忘记返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html">卡哥的详细解释</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">卡哥的答案确实比较详细，这里简单总结下</span><br><span class="line">一个快指针，一个慢指针，快指针走两步，慢指针走一步。</span><br><span class="line">这样子，其实快指针是在慢慢一步步靠近慢指针，如果有环的话，一定会相遇。</span><br><span class="line">当他们相遇的时候，这时候我们重新声明两个指针，一个指向fast，一个指向头，然后他们一步步走，最终相遇的时候，就是入口，这里面涉及一些公式推导，去卡哥网站上看吧。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这里解释下卡哥这句话</span><br><span class="line">那么fast指针走到环入口3的时候，已经走了k + n 个节点，slow相应的应该走了(k + n) / 2 个节点。</span><br><span class="line">因为k是小于n的（图中可以看出），所以(k + n) / 2 一定小于n</span><br><span class="line"></span><br><span class="line">(n + n) / 2 = n ，k &lt; n，所以(k + n) / 2 一定小于n。</span><br><span class="line">也就是说你的fast已经走到了环入口三，而slow还没走到环入口三，并且一开始fast在环入口2的前面，也就是他们已经相遇过了。</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="242-有效的字母异位词-easy"><a href="#242-有效的字母异位词-easy" class="headerlink" title="242 有效的字母异位词 easy"></a>242 有效的字母异位词 easy</h3><p>若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用一个26长度是int数组来记录s的字母个数</span></span><br><span class="line"><span class="comment">然后用t的字母减去相应个数</span></span><br><span class="line"><span class="comment">最后如果发现record数组都是0，那证明就是异味词，否则不是</span></span><br><span class="line"><span class="comment">String中用s.toCharArray</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:s.toCharArray()) &#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;<span class="comment">//toCharArray将字符串转换为字符数组，比如单独输出a 然后a - &#x27;a&#x27; = 0,那么在0的位置上加1，b的话就在1的位置上加1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c:t.toCharArray()) &#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line"><span class="comment">            if (record[i] != 0 ) &#123;</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面这个写法更简洁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : record) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>349 两个数组的交集 easy<br>set可以去重，通过两个set就可以找到交集。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set2 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set1.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set1.contains(i)) &#123;</span><br><span class="line">                set2.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[set2.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : set2) &#123;<span class="comment">//把结果转成数组</span></span><br><span class="line">            result[index++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>202 快乐数 easy<br>这个题其实就是按照题目思路去走即可，需要知道如何拆出数字来获取，比如个位数用mod，然后其他位置依次循环除以10。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//这个题的求和过程中可能会有数字重复出现，所以要用hash的set去重</span></span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span> &amp;&amp; !result.contains(n)) &#123;</span><br><span class="line">            result.add(n);</span><br><span class="line">            n = getnextnum(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getnextnum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">//比如19</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;<span class="comment">//先获得9</span></span><br><span class="line">            sum += temp * temp;<span class="comment">//81</span></span><br><span class="line">            n = n / <span class="number">10</span>;<span class="comment">//然后获得1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-两数之和-easy"><a href="#1-两数之和-easy" class="headerlink" title="1 两数之和 easy"></a>1 两数之和 easy</h3><p>一开始就行想着暴力解法，虽然过了，用了两个循环，但是看了卡哥的解释还是太年轻了,这里有个细节，一定要先判断，然后再put元素进去，否则遇到[3,3] targer&#x3D;6 这种情况，res答案就会变成[1,1]，而不是[0,1]</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里只用了一个循环就可以完成这个任务，用到了map</span></span><br><span class="line"><span class="comment">map&lt;key,value&gt;</span></span><br><span class="line"><span class="comment">放到这个题就是key存nums[i]，value存位置信息。</span></span><br><span class="line"><span class="comment">一开始是存前面的数和位置，到了后面target相减后，如果在map中有匹配的数，那就说明已经找到符合题目的数了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target -nums[i];<span class="comment">//相减后的数</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp)) &#123;<span class="comment">//如果相减后的数在map中，就说明成功了</span></span><br><span class="line">                result[<span class="number">0</span>] = i;</span><br><span class="line">                result[<span class="number">1</span>] = map.get(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="454-四数相加2-medium"><a href="#454-四数相加2-medium" class="headerlink" title="454 四数相加2 medium"></a>454 四数相加2 medium</h3><p>第一次看到这么巧妙的做法，看来还是练题太少了。这个题不用考虑重复的四个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题用到了map来保存前两个数的和以及出现的次数，然后后面两个数用0去相减他们的和得到一个值，</span></span><br><span class="line"><span class="comment">如果这个值在map中存在，那就提取次数，最后累加次数就是答案。</span></span><br><span class="line"><span class="comment">这里一开始不明白为什么用map来保留次数，比如前两个数组是[1,1],[1,1]，那么map中就是(2:4)，也就是和为2的有4个，至于是什么组合我们不用管</span></span><br><span class="line"><span class="comment">因为题目只需要知道最后有多少次</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i :nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(temp)) &#123;</span><br><span class="line">                    map.put(temp, map.get(temp) + <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    map.put(temp, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让语句写更少一些，主要在map的修改上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                map.put(temp, map.getOrDefault(temp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                temp = i + j;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(<span class="number">0</span> - temp)) &#123;</span><br><span class="line">                    res += map.get(<span class="number">0</span> - temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="383-赎金信-easy"><a href="#383-赎金信-easy" class="headerlink" title="383 赎金信 easy"></a>383 赎金信 easy</h3><p>一开始想得挺复杂，看到卡哥提点都是小写字母，可以用一个26大小的char数组保存这句话，就写出来了，没想到和卡哥答案一样，嘻嘻。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : magazine.toCharArray()) &#123;<span class="comment">//注意题目是后者的个数要覆盖前者的个数哦，所以先提取magazine</span></span><br><span class="line">            result[i - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> i : ransomNote.toCharArray()) &#123;</span><br><span class="line">            result[i - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : result) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-三数之和-medium-非哈希法"><a href="#15-三数之和-medium-非哈希法" class="headerlink" title="15 三数之和 medium(非哈希法)"></a>15 三数之和 medium(非哈希法)</h3><p>哈希法太复杂，这里是双指针，而且和454的区别是，454是4个数组，这个题是一个数组，而且不能是重复的三元组，这个题要多看看，可能第二遍又忘记了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题用双指针更加方便</span></span><br><span class="line"><span class="comment">不过一开始是指向i,left,right</span></span><br><span class="line"><span class="comment">left的初始化是i+1</span></span><br><span class="line"><span class="comment">这里有个关键是，必须先进行排序。</span></span><br><span class="line"><span class="comment">学习Arrays.asList</span></span><br><span class="line"><span class="comment">记不住就</span></span><br><span class="line"><span class="comment">                    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">                    res.add(nums[i]);</span></span><br><span class="line"><span class="comment">                    res.add(nums[left]);</span></span><br><span class="line"><span class="comment">                    res.add(nums[right]);</span></span><br><span class="line"><span class="comment">                    result.add(res);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;<span class="comment">//因为已经排序了，如果第一个就大于0，那后面就不可能和为0了</span></span><br><span class="line">                <span class="keyword">return</span> result;<span class="comment">//这个题我试了下，用nums[0]也可以，不过要放在for内，如果在sort下面写nums[0] &gt; 0判断，可能不行，因为用例可以是空的[]，这样就没有nums[0]。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="comment">//加个大于0，是因为怕一开始的情况，0-1=-1就不成立啦</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//去重操作，不能直接写成nums[i] == nums[i + 1]，因为会漏掉比如-1,-1,2这种情况，也就是一开始就筛掉了</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="comment">//不可以在这里写去重条件，也就是最下面else那个，如果这里写的话，万一用例是0,0,0，那么就直接筛掉了，而在下面写，是为了保证已经添加了元祖，再进行去重。</span></span><br><span class="line">                <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));<span class="comment">//添加元祖，然后再去重</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//去重条件，注意righ-1，下面是left + 1</span></span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                    <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;   <span class="comment">//注意这里是left+1            </span></span><br><span class="line">                    right--;</span><br><span class="line">                    left++;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="18-四数之和-medium"><a href="#18-四数之和-medium" class="headerlink" title="18 四数之和 medium"></a>18 四数之和 medium</h3><p>和上一题的区别是，这个是四元组，而且和不是为0，是任意值target。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">具体的区别有，首先不再判断第一个数大于0就continue，因为这个题是任意值。</span></span><br><span class="line"><span class="comment">只需要多加一个for循环，再多一个j，同理如果是5元组，6元组也如此。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;<span class="comment">//i要去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i + <span class="number">1</span> &amp;&amp; nums[j - <span class="number">1</span>] == nums[j]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="comment">//多加一个循环，同时这里需要去重，j也要去重。</span></span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + nums[j] + nums[left] + nums[right];<span class="comment">//因为这个题是任意值，所以用例有个越界的，转成long。</span></span><br><span class="line">                    <span class="keyword">if</span> (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="344-反转字符串-easy"><a href="#344-反转字符串-easy" class="headerlink" title="344 反转字符串 easy"></a>344 反转字符串 easy</h3><p>简简单单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            temp = s[i];</span><br><span class="line">            s[i] = s[s.length - <span class="number">1</span> -i];</span><br><span class="line">            s[s.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一样的效果，只是一个for，一个是用while。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="541-反转字符串2-easy"><a href="#541-反转字符串2-easy" class="headerlink" title="541 反转字符串2 easy"></a>541 反转字符串2 easy</h3><p>比较繁琐，需要定义判断多种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每2k长度进行一次操作，也就是固定一段去处理字符串。</span></span><br><span class="line"><span class="comment">这里题目要求，剩余长度大于少于k，则全部反转，剩余长度小于2k，则反转前k个，所以可以i+k去处理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i += k * <span class="number">2</span>) &#123;<span class="comment">//每隔2k来处理，然后找到起点</span></span><br><span class="line">            reverse(arr, i, Math.min(i + k, n) - <span class="number">1</span>);<span class="comment">//这里用min是怕越界，如果直接用if判断i+k &lt; n又会漏了一些情况，秒！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">            arr[left] = arr[right];</span><br><span class="line">            arr[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-05-替换空格-easy"><a href="#剑指-Offer-05-替换空格-easy" class="headerlink" title="剑指 Offer 05. 替换空格 easy"></a>剑指 Offer 05. 替换空格 easy</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">题目链接</a>，一开始想法的替换空格，但是忘记一个事，%20是三个字符，所以要申请空间，干脆用SrtingBuilder。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实return s.replace(&quot; &quot;,&quot;%20&quot;);即可，但是这是算法题哦</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//第一次用StringBuilder，最后要转成String，也就是直接复制原来s到StringBuilder中</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;  s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="151-颠倒字符串中的单词-medium"><a href="#151-颠倒字符串中的单词-medium" class="headerlink" title="151 颠倒字符串中的单词 medium"></a>151 颠倒字符串中的单词 medium</h3><p>这个题比较多繁琐的东西，下面详细讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> RemoveSpace(s);</span><br><span class="line">        ReverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        ReverseEachWords(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StringBuilder <span class="title function_">RemoveSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ReverseEachWords</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            ReverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">总体思路是</span><br><span class="line">1.去除多余的空格</span><br><span class="line">比如[ the     sky   ]，去除后是[the sky]，要去掉多余的两边空格，以及中间只需要保留一个空格。</span><br><span class="line">函数里面while (start &lt;= end)，这里有个等于号，如果没有的话，会漏掉最后一个字符，因为我们是用start去提取字符，自然start要到最后</span><br><span class="line">重点看if (c != &#x27; &#x27; || sb.charAt(sb.length() - 1) != &#x27; &#x27;)</span><br><span class="line">这句前面部分，是为了保证非空格元素添加进去，而后面则是为了去除两个单词之间多余的空格</span><br><span class="line">举个例子[the  sky]，中间有两个空格，start为4的时候，为第一个空格，此时sb是the，如果看前面第一个条件，是不允许添加的，但是这个是或，后面那个条件sb提取出来的是e，所以，这时候位置4的空格可以添加进去，</span><br><span class="line">这时候sb是[the ]，然后开始第五个位置，同样，前面第一个条件不通过，第二个条件也不通过，因为此时sb最后一个字符是空格，这样的话，两个单词之间，就可以做到保留一个空格</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.翻转字符串</span><br><span class="line">这个没啥好说的，就是字面意思</span><br><span class="line"></span><br><span class="line">3.翻转单词</span><br><span class="line">这个就有意思了，我们检测到空格位置，就说明检测完一个单词，然后再把这个单词放进翻转字符串，即可完成，这里别忘了，翻转字符串的end是位置，不是长度，</span><br><span class="line">所以ReverseString(sb, start, end - 1);这个容易漏掉end-1</span><br></pre></td></tr></table></figure>
<h3 id="剑指-Offer-58-II-左旋转字符串-easy"><a href="#剑指-Offer-58-II-左旋转字符串-easy" class="headerlink" title="剑指 Offer 58 - II. 左旋转字符串 easy"></a>剑指 Offer 58 - II. 左旋转字符串 easy</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">题目链接</a>，感觉卡哥写的还复杂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己写的，感觉还行，后来看了下官方题解，居然一样！</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-实现-strStr-easy-KMP"><a href="#28-实现-strStr-easy-KMP" class="headerlink" title="28 实现 strStr() easy(KMP)"></a>28 实现 strStr() easy(KMP)</h3><p>别看是easy题，这是KMP算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">KMP算法的目的就是解决字符串匹配，其实挺神奇的，不过具体的数学原理是啥，有点懵，先把一些概念解释清楚</span><br><span class="line">首先理解前缀和后缀，以及前缀表</span><br><span class="line">以要在文本串：aabaabaafa 中查找是否出现过一个模式串：aabaaf这个为例子。</span><br><span class="line">我们要构建模式串(needle)的前缀表。</span><br><span class="line"><span class="number">1.</span>前缀的理解，概念是指不包含最后一个字符的所有以第一个字符开头的连续子串</span><br><span class="line">a</span><br><span class="line">aa</span><br><span class="line">aab</span><br><span class="line">aaba</span><br><span class="line">aabaa</span><br><span class="line">上面五个都是前缀，不包含最后一个字符哦</span><br><span class="line"><span class="number">2.</span>后缀的理解，指不包含第一个字符的所有以最后一个字符结尾的连续子串。</span><br><span class="line">f</span><br><span class="line">af</span><br><span class="line">aaf</span><br><span class="line">baaf</span><br><span class="line">abaaf</span><br><span class="line">上面五个都是后缀，不包含第一个字符哦</span><br><span class="line"><span class="number">3.</span>前缀表，也就是最长相等前后缀（均用不减<span class="number">1</span>的操作，有些KMP的next数组用减<span class="number">1</span>）。</span><br><span class="line">a <span class="number">0</span></span><br><span class="line">aa <span class="number">1</span>  这里前缀a，后缀a，相等的长度就是<span class="number">1</span></span><br><span class="line">aab <span class="number">0</span></span><br><span class="line">aaba <span class="number">1</span> 只有前缀a和后缀a相等</span><br><span class="line">aabaa <span class="number">2</span> 前缀aa和后缀aa相等</span><br><span class="line">aabaaf <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span>就是我们模式串的前缀表。</span><br><span class="line"></span><br><span class="line">再举一个例子asdfasdfasdf</span><br><span class="line">next表是[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">前缀asdfasdf</span><br><span class="line">后缀asdfasdf</span><br><span class="line">也就是前缀和后缀是有重叠位置的时候</span><br><span class="line">所以这里是强化下我们的概念，前缀是不包含最后一个字符，后缀是不包含第一个字符，所以他们即便是重叠的，都没关系，我们重点关注的是概念！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">大致的解题思路是</span><br><span class="line"><span class="number">1.</span>首先构建好前缀表</span><br><span class="line"><span class="number">2.</span>循环文本串，然后循环匹配，如果不匹配，则寻找之前匹配的位置，如果匹配，j++，最后如果出现了文本串则根据题目要求返回相应值。</span><br></pre></td></tr></table></figure>
<p>下面这个图很好解释了为什么当我们遇到不匹配的字符后，因为next数组记录了相等前后缀长度，遇到不匹配的字符后，j回退到next[j-1]，这个next[j-1]就是他们之前的最长相等前后缀长度，也就是回退到这个位置的时候，模式串从0到这个位置的字符，是和主串i位置之前的字符相等，之前字符的长度，就是模式串从0到这个位置的字符的长度，这是核心理解。至于next数组为什么那么求，目前还没有深刻的理解，但是至少理解了，为什么要回退这个步骤。<br><img src="/images/leetcode-java/kmp.jpg"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        getNext(next, needle);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;<span class="comment">//这里是从0开始的哦</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i  - needle.length() + <span class="number">1</span>;<span class="comment">//因为我们是要找主串上的起始位置，所以 是用i去减，而不是j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//这句可写可不写，因为初始化的时候都是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;<span class="comment">//i是从1开是的，因为你只有一个字母的时候，肯定是0，所以第一个不用考虑，直接从第二个位置开始</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j))&#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="459-重复的子字符串-easy-KMP"><a href="#459-重复的子字符串-easy-KMP" class="headerlink" title="459 重复的子字符串 easy(KMP)"></a>459 重复的子字符串 easy(KMP)</h3><p>重点理解周期长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        getNext(next, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n % (n - next[n - <span class="number">1</span>]) == <span class="number">0</span> &amp;&amp; next[n - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">这个题也是kmp的题目，寻找重复的子串</span><br><span class="line">注意理解一个概念：</span><br><span class="line">数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</span><br><span class="line">所以我们求完next数组后</span><br><span class="line">n % (n - next[n - <span class="number">1</span>]) == <span class="number">0</span> n是长度，next[n - <span class="number">1</span>]也就是最长的相同前后缀的长度</span><br><span class="line">next[n - <span class="number">1</span>] != <span class="number">0</span>这个是为了保证，next数组最后一个长度不是<span class="number">0</span>，否则判断出错，下面举个例子</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;abac&quot;</span>的next数组是[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]，如果没有next[n - <span class="number">1</span>] != <span class="number">0</span>这个条件，那就是<span class="number">4</span> % (<span class="number">4</span> - <span class="number">0</span>) == <span class="number">0</span>就返回了<span class="literal">true</span>，实际上是<span class="literal">false</span>，所以要保证最长相同前后缀长度不为<span class="number">0</span>先</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;aaaa&quot;</span>的next数组是[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]，那么<span class="number">4</span> %(<span class="number">4</span> - <span class="number">3</span>) ==<span class="number">0</span>返回<span class="literal">true</span>，<span class="number">4</span>-<span class="number">3</span>=<span class="number">1</span>也就是说这个周期长度是<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="232-用栈实现队列-easy"><a href="#232-用栈实现队列-easy" class="headerlink" title="232 用栈实现队列 easy"></a>232 用栈实现队列 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; Stackin;<span class="comment">//首先全局定义</span></span><br><span class="line">    Stack&lt;Integer&gt; Stackout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        Stackin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();<span class="comment">//别忘了new</span></span><br><span class="line">        Stackout = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        Stackin.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpStackin();</span><br><span class="line">        <span class="keyword">return</span> Stackout.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpStackin();</span><br><span class="line">        <span class="keyword">return</span> Stackout.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Stackin.isEmpty() &amp;&amp; Stackout.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpStackin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!Stackout.isEmpty()) <span class="keyword">return</span>;<span class="comment">//先检查出栈，如果出栈不为空，则直接使用出栈队列，也就是返回一个号空</span></span><br><span class="line">        <span class="keyword">while</span> (!Stackin.isEmpty()) &#123;<span class="comment">//如果入栈不为空，要把入栈的全部移动到出栈，注意入栈此时要删除元素</span></span><br><span class="line">            Stackout.push(Stackin.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">这个题是用两个栈来实现队列的操作</span><br><span class="line">队列：先进先出 栈：先进后出</span><br><span class="line">pop：移除元素并返回该元素</span><br><span class="line">peak：返回队列开头元素</span><br><span class="line">push：添加元素</span><br><span class="line">那么用栈去完成队列的功能，需要两个栈，一个为作为入栈，一个作为出栈。</span><br><span class="line"></span><br><span class="line">入栈：直接就是push元素进去</span><br><span class="line">pop：检查出栈有无元素，有的话直接操作出栈的元素，如果出栈是空的话，那么将入栈的目前所有的元素全部移动到出栈中，再操作出栈pop</span><br><span class="line">peak：和pop一样的道理</span><br><span class="line">pip和peak都是java内置的，所以直接调用，我们主要是负责把入栈的元素移动到出栈中，这样才可以实现队列先进先出的功能</span><br><span class="line">那么判断栈是否为空，只要两个都是空，那么就是空栈</span><br></pre></td></tr></table></figure>
<h3 id="225-用队列实现栈-easy"><a href="#225-用队列实现栈-easy" class="headerlink" title="225 用队列实现栈 easy"></a>225 用队列实现栈 easy</h3><p>题目要求必须要用两个队列<br>pop移除并返回栈顶元素<br>top返回栈顶元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于LinkedList一些api</span></span><br><span class="line"><span class="comment">peekFirst()此方法用于检索链表的第一个元素，初始元素或开始元素，但不会从列表中删除第一个元素。</span></span><br><span class="line"><span class="comment">peekLast()方法用于返回此双端队列表示的队列的最后一个元素，但不删除该元素。</span></span><br><span class="line"><span class="comment">pollLast()检索并删除此列表的最后一个元素，如果此列表为空，则返回null。</span></span><br><span class="line"><span class="comment">pollFirst()检索并删除此列表的第一个元素，如果此列表为空，则返回null。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以用queue，也可以用deque</span></span><br><span class="line"><span class="comment">用了两个deque，核心在pop上，弹出元素的时候，思路就是先把que1除了最后一个元素，然后将其他元素全部移到que2中</span></span><br><span class="line"><span class="comment">这时候que1只剩下一个元素，这个元素就是需要的值，然后再将que2变成que1即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que1;</span><br><span class="line">    Deque&lt;Integer&gt; que2;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que1.addLast(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> que1.size();</span><br><span class="line">        n--;<span class="comment">//除了最后一个元素，其余元素都要移到que2中</span></span><br><span class="line">        <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            que2.addLast(que1.peekFirst());</span><br><span class="line">            que1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que1.pollFirst();</span><br><span class="line">        que1 = que2;</span><br><span class="line">        que2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que1.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>下面是用双端队列，抖机灵用的，只用一个队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; que;<span class="comment">//双端队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        que.addLast(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;<span class="comment">//栈顶：最后一个入栈的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> que.pollLast();<span class="comment">//栈的是先进后出，队列是先进先出，所以从队列最后返回也就是对应栈的先进后出</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.peekLast();<span class="comment">//和上面一样的道理，只不过不需要删除元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="20-有效的括号-easy"><a href="#20-有效的括号-easy" class="headerlink" title="20 有效的括号 easy"></a>20 有效的括号 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个栈（其实双端队列也行）</span></span><br><span class="line"><span class="comment">然后扫描字符串s，如果是(,就在栈中放)，如果是[，就在栈中放]，如果是&#123;，就在栈中放&#125;。</span></span><br><span class="line"><span class="comment">然后如果扫描到),],&#125;如果这时候的栈顶是该元素，就删除，如果不是，说明不匹配了，直接返回false，还有一种情况是，栈是空的，也是不匹配的情况</span></span><br><span class="line"><span class="comment">最后检查栈是不是为空，为空就说明全部匹配上了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; que = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                que.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                que.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                que.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (que.isEmpty() || que.peek() != s.charAt(i)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (que.peek() == s.charAt(i)) &#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1047-删除字符串中的所有相邻重复项-easy"><a href="#1047-删除字符串中的所有相邻重复项-easy" class="headerlink" title="1047 删除字符串中的所有相邻重复项 easy"></a>1047 删除字符串中的所有相邻重复项 easy</h3><p>这个可以看卡哥的动画，瞬间就可以明白</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义一个双端队列</span></span><br><span class="line"><span class="comment">如果队列是空的或者队列的顶元素和当前s[i]不一样，就把s[i]押进队列中，</span></span><br><span class="line"><span class="comment">如果当前s[i]和顶元素一样的话，就删除该队列中该元素，这也就是&quot;对对碰消失&quot;的核心</span></span><br><span class="line"><span class="comment">最后就是把里面的元素提取出来整合到字符串中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        ArrayDeque&lt;Character&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (que.isEmpty() || que.peek() != ch) &#123;</span><br><span class="line">                que.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                que.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//队列最后是[a,c]的话，首先弹出c,然后再弹出a，所以pop后加上result才能正确拼接</span></span><br><span class="line">        <span class="keyword">while</span> (!que.isEmpty()) &#123;</span><br><span class="line">            result = que.pop() + result;<span class="comment">//有个不留意的地方，第一次写成result += que.pop()； 相当于result = result + que.pop()，这是错误的，加错了。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="150-逆波兰表达式求值-medium"><a href="#150-逆波兰表达式求值-medium" class="headerlink" title="150 逆波兰表达式求值 medium"></a>150 逆波兰表达式求值 medium</h3><p>这个题看动画就秒懂了，这个是后缀表达式，可以依次顺序来计算结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个小知识点： &quot;&quot;是String类型，&#x27;&#x27;是char类型</span></span><br><span class="line"><span class="comment">思路就是，如果检测到有符号，就说明需要运算，就弹出之前的两个值进行运行，然后再把结果push到队列中即可。</span></span><br><span class="line"><span class="comment">但是注意先弹出的元素是后运算的，比如 6 3 /,先弹出3，然后弹出6，所以你要定义好两个变量去保存，别搞乱顺序运算</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ch:tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(ch) || <span class="string">&quot;-&quot;</span>.equals(ch) || <span class="string">&quot;*&quot;</span>.equals(ch)|| <span class="string">&quot;/&quot;</span>.equals(ch))&#123;<span class="comment">//力扣的问题，不能用==，只能用equals</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> que.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> que.pop();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(ch)) &#123;</span><br><span class="line">                    que.push(temp2 + temp1);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(ch))  &#123;</span><br><span class="line">                    que.push(temp2 - temp1);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(ch))  &#123;</span><br><span class="line">                    que.push(temp2 * temp1);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(ch))  &#123;</span><br><span class="line">                    que.push(temp2 / temp1);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    que.push(Integer.valueOf(ch));</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">就是上面解法的简化版，但是需要注意减法和除法，而上面则不需要顾虑太多</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; que = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String ch:tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+&quot;</span>.equals(ch)) &#123;</span><br><span class="line">                que.push(que.pop() + que.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-&quot;</span>.equals(ch))  &#123;</span><br><span class="line">                que.push(-que.pop() + que.pop());<span class="comment">//这里需要前面加个负号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(ch))  &#123;</span><br><span class="line">                que.push(que.pop() * que.pop());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;/&quot;</span>.equals(ch))  &#123;<span class="comment">//除法要注意</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> que.pop();</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> que.pop();</span><br><span class="line">                que.push(temp2 / temp1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                que.push(Integer.valueOf(ch));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="239-滑动窗口最大值-hard"><a href="#239-滑动窗口最大值-hard" class="headerlink" title="239 滑动窗口最大值 hard"></a>239 滑动窗口最大值 hard</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">巩固知识</span><br><span class="line">add/offer/offerLast添加队尾，三个方法等价；</span><br><span class="line">push/offerFirst添加队头，两个方法等价。</span><br><span class="line">remove/pop/poll/pollFirst删除队头，四个方法等价；</span><br><span class="line">pollLast删除队尾。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add/remove源自集合，添加到队尾 / 从队头删除；</span><br><span class="line">offer/poll源自队列 添加到队尾/ 从队头删除；</span><br><span class="line">push/pop源自栈   添加到队头/ 从队头删除；</span><br><span class="line">offerFirst/offerLast/pollFirst/pollLast源自双端队列（两端都可以进也都可以出），offerFirst添加到队头，offerLast添加到队尾，pollFirst从队头删除，pollLast从队尾删除。</span><br><span class="line"></span><br><span class="line">peek()方法用于返回此双端队列表示的队列的头元素，但不删除该元素。</span><br><span class="line"></span><br><span class="line">java最好别用Stack来实现栈的功能，官方说的，不推荐使用，所以可以用deque来做栈</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个题是用单调队列来完成的</span></span><br><span class="line"><span class="comment">队列中只用于保存位置，而不是保存nums的具体值，这样的原因是，可以用于判断是否超过了滑动窗口的范围。</span></span><br><span class="line"><span class="comment">队列的头代表的位置始终是值最大的</span></span><br><span class="line"><span class="comment">具体操作：</span></span><br><span class="line"><span class="comment">首先判断队列中的范围是否超过滑动窗口的范围，如果超过了，则要移除，因为先进入队列的位置是最早的，所以看队列的头来判断</span></span><br><span class="line"><span class="comment">然后判断nums[i]是否比队列尾巴所代表的nums值要大，如果大了，就移除队尾的元素，但是小于可以插进去队列，这也说明队列是单调的，单调递减</span></span><br><span class="line"><span class="comment">最后就是把结果放入res中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        ArrayDeque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + <span class="number">1</span>) &#123;<span class="comment">//判断队头是否超过滑动窗口的范围</span></span><br><span class="line">                deque.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) &#123;<span class="comment">//保证单调，判断队尾是否小于下一个值，如果是，就不断移除队列尾元素，直到符合要求</span></span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offer(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;<span class="comment">//比如k=3，i从2开始就可以取出元素放了，然后每移动一次都放一次</span></span><br><span class="line">                res[x++] = nums[deque.peek()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="347-前k个高频元素-medium"><a href="#347-前k个高频元素-medium" class="headerlink" title="347 前k个高频元素 medium"></a>347 前k个高频元素 medium</h3><p>之前做过，但是发现之前的方法有点复杂，下面是小顶堆的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;Integer, Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o1.getValue() - o2.getValue());</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : entries) &#123;</span><br><span class="line">            queue.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; k) &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            result[i] = queue.poll().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">思路是首先是先用map来存储key和value，value就是统计次数。</span><br><span class="line">set来保存这个键值后构建小顶堆，小顶堆poll掉的是小数，留下来的是大数，然后判断队列中的大数是否超过k</span><br><span class="line">超过k就poll掉，最后用一个数组来保留结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下面是一些语法记录：以[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>], k = <span class="number">2</span>为例子</span><br><span class="line">map不能直接使用迭代器，所以用set</span><br><span class="line">map有一个方法叫做entrySet(),这方法可以将Map的键值对的映射关系作为set集合的元素存储到Set集合当中，而这种映射关系的类型就是Entry的类型。</span><br><span class="line">Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。</span><br><span class="line">Set&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">上面这句话打印出来的entries是[<span class="number">1</span>=<span class="number">3</span>, <span class="number">2</span>=<span class="number">2</span>, <span class="number">3</span>=<span class="number">1</span>]</span><br><span class="line">当然了，直接打印map.entrySet()打印出来也是[<span class="number">1</span>=<span class="number">3</span>, <span class="number">2</span>=<span class="number">2</span>, <span class="number">3</span>=<span class="number">1</span>]，用set还是为了能够迭代</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">构建小顶堆的作用是能保证每次取出的元素都是队列中权值最小的</span><br><span class="line">如果是大顶堆则是<span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((o1, o2) -&gt; o2.getValue() - o1.getValue());</span><br><span class="line">PriorityQueue（优先队列）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add和remove是一对，源自Collection；</span><br><span class="line">offer和poll是一对，源自Queue；</span><br><span class="line">push和pop是一对，源自Deque，其本质是栈（Stack类由于某些历史原因，官方已不建议使用，使用Deque代替）；</span><br><span class="line">offerFirst/offerLast和pollFirst/pollLast是一对，源自Deque，其本质是双端队列。</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>递归三部曲：<br>1.确定递归函数的参数和返回值<br>2.确定终止条件<br>3.确定单层递归的逻辑</p>
<p>务必熟悉定义二叉树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode() &#123;&#125;;<span class="comment">//&#123;&#125;容易漏</span></span><br><span class="line">    TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里注意下递归中reurn的问题</span></span><br><span class="line"><span class="comment">如果是TreeNode 一般return null;</span></span><br><span class="line"><span class="comment">如果是获得元素的值，这里的return代表终止运行程序，也不能return 0哦，直接终止即可，看530。</span></span><br><span class="line"><span class="comment">如果求深度，就return 0 看104</span></span><br><span class="line"><span class="comment">如果判断是话 就return true 看98</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="94-144-145-二叉数递归遍历（递归法）-easy"><a href="#94-144-145-二叉数递归遍历（递归法）-easy" class="headerlink" title="94&#x2F;144&#x2F;145 二叉数递归遍历（递归法） easy"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（递归法） easy</h3><p>递归遍历三步骤：1.确定输入的参数和返回值（定义递归函数入口） 2.确定终止条件 3.确定递归逻辑（函数内容）</p>
<p>144 前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        preOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        result.add(root.val);</span><br><span class="line">        preOrder(root.left, result);</span><br><span class="line">        preOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>94 中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        inOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        inOrder(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>145 后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        postOrder(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        postOrder(root.left, result);</span><br><span class="line">        postOrder(root.right, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="94-144-145-二叉数递归遍历（迭代法）-easy"><a href="#94-144-145-二叉数递归遍历（迭代法）-easy" class="headerlink" title="94&#x2F;144&#x2F;145 二叉数递归遍历（迭代法） easy"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（迭代法） easy</h3><p>144 前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前序遍历是中-左-右，迭代法用栈来解决 入栈的顺序是中-右-左</span></span><br><span class="line"><span class="comment">需要注意的是，栈是先进后出，所以如果要达到中左右的效果，需要右边先进栈，这样就可以后出。</span></span><br><span class="line"><span class="comment">还需要注意stack的类型是TreeNode哦</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//去掉ArrayList&lt;Integer&gt;中的Integer也可以的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">             result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;<span class="comment">//这里务必注意不能写成else if，比如[3,1,2]，如果这样写答案为[3,2],因为if else只会判断一次，这样就把left给丢掉了</span></span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>94 中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">中序遍历：左-中-右</span></span><br><span class="line"><span class="comment">迭代法就是先把左节点全部压进栈中，然后等空了就弹出来顺便取值，然后再压右节点进去</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() || root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                result.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>145 后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果。</span></span><br><span class="line"><span class="comment">和前序迭代法很相似，只有两个地方不同：1.压栈顺序2.结果翻转</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//去掉ArrayList&lt;Integer&gt;中的Integer也可以的</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span>  stack.pop();</span><br><span class="line">             result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);<span class="comment">//先压左边</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);<span class="comment">//最后要翻转</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="94-144-145-二叉数递归遍历（统一迭代法）-easy"><a href="#94-144-145-二叉数递归遍历（统一迭代法）-easy" class="headerlink" title="94&#x2F;144&#x2F;145 二叉数递归遍历（统一迭代法） easy"></a>94&#x2F;144&#x2F;145 二叉数递归遍历（统一迭代法） easy</h3><p>因为迭代法的写法是针对每种遍历顺序定制的，没有统一的规律，所以才有统一迭代法。<br>144 前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前序遍历：中-左-右   在本方法的压栈顺序为：右-左-中</span></span><br><span class="line"><span class="comment">中序遍历：左-中-右   在本方法的压栈顺序为：右-中-左 </span></span><br><span class="line"><span class="comment">后序遍历：左-右-中   在本方法的压栈顺序为：中-右-左</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里有个细节的地方就是添加了中节点后还添加了一个null节点，那么读取的时候，会不会读到null呢</span></span><br><span class="line"><span class="comment">答案是会的，但是当我们读到null时候（每次while都会重新读取栈顶），就会触发else这里，然后继续pop取值，这时候就是一个新的node，然后加入该节点的val进入结果中 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">push和pop是一对</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次做的反思，首先没有考虑到倒着顺序进行进栈和压栈</span></span><br><span class="line"><span class="comment">其次，在内部node的处理上，还是还是习惯写成root，感觉自己就像背题一样而没有去理解题目</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);<span class="comment">//压入root</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();<span class="comment">//提取栈顶元素并删除</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right);<span class="comment">//添加右节点（空节点不入栈）</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);<span class="comment">//添加左节点（空节点不入栈）</span></span><br><span class="line">                stack.push(node);<span class="comment">// 添加中节点</span></span><br><span class="line">                stack.push(<span class="literal">null</span>);<span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。                </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不推荐用stack，这里用LinkedList替代</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LinkedList中的pop()和poll()的区别</span></span><br><span class="line"><span class="comment">poll是队列数据结构实现类的方法，从队首获取元素，同时获取的这个元素将从原队列删除</span></span><br><span class="line"><span class="comment">pop是栈结构的实现类的方法，表示返回栈顶的元素，同时该元素从栈中删除，当栈中没有元素时，调用该方法会发生异常</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">同样，还有push，offer和add区别</span></span><br><span class="line"><span class="comment">push是把LinkedList当做栈来用</span></span><br><span class="line"><span class="comment">offer和add是当做链表或者队列来用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();<span class="comment">//List是没有push方法的，所以前面是LinkedList&lt;TreeNode&gt;</span></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) stack.push(temp.right);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) stack.push(temp.left);</span><br><span class="line">                stack.push(temp);</span><br><span class="line">                stack.push(<span class="literal">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = stack.pop();</span><br><span class="line">                result.add(temp.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>94 中序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(<span class="literal">null</span>);  </span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);              </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>145 后序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">                stack.push(node);</span><br><span class="line">                stack.push(<span class="literal">null</span>); </span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right);    </span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);           </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="102-二叉树的层序遍历-medium"><a href="#102-二叉树的层序遍历-medium" class="headerlink" title="102 二叉树的层序遍历 medium"></a>102 二叉树的层序遍历 medium</h3><p>用队列先进先出的特性，对每层保存然后poll出来，顺序就是层序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">具体解法：</span></span><br><span class="line"><span class="comment">对每一层进行操作，那么怎么判断是这层呢</span></span><br><span class="line"><span class="comment">用len来判断，当队列加完这层后，再用len计算长度，然后一个个出列，处理完一层，再处理一层，这样就做到层序遍历。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<span class="comment">//注意我们输出的格式如[[[1],[2,3],[4,5,6]]]</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();<span class="comment">//队列存的是TreeNode</span></span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; ietmList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();<span class="comment">//先定义</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();<span class="comment">//记录长度</span></span><br><span class="line">            <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;<span class="comment">//while哦，一直加节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();<span class="comment">//第二次做的时候，把这个放到了while上面，不应该！</span></span><br><span class="line">                ietmList.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);<span class="comment">//这里是temp不是root</span></span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(ietmList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="226-翻转二叉树-easy"><a href="#226-翻转二叉树-easy" class="headerlink" title="226 翻转二叉树 easy"></a>226 翻转二叉树 easy</h3><p>递归法，可以对比下前序遍历的递归（后序也可以，但是不可以用中序）。<br>做这个题一开始用List去保存，哎，年轻。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//root也可以</span></span><br><span class="line">        swapTree(root);</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);<span class="comment">//第二次写，居然写成swapTree，实质上还是没有理解好递归,处理根的时候，就是交换，然后左右就是递归</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swapTree</span><span class="params">(TreeNode node)</span> &#123;<span class="comment">//第二次写的时候写了TreeNode left，TreeNode right两个参数，其实不需要，按照遍历递归，先处理左边，再处理右边</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>层序遍历，可以好好看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                swapTree(temp);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swapTree</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="101-对称二叉树-easy"><a href="#101-对称二叉树-easy" class="headerlink" title="101 对称二叉树 easy"></a>101 对称二叉树 easy</h3><p>判断是不是对称二叉树，返回true或者false，用了递归法内外是否一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对称，那么就是判断内外是否一样</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">先判断节点空的三种情况：都空，左空，右空。</span></span><br><span class="line"><span class="comment">然后都不空了，判断值是否相等，但是这里只能判断不等的情况返回false，不能写成相等情况返回true，理由如下：</span></span><br><span class="line"><span class="comment">此时就是：左右节点都不为空，且数值相同的情况，已经被我们过滤完了，此时才做递归，做下一层的判断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以如果你是判断了相同的，但是可能不同的没有过滤就进入递归了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">再一次做还是错误，首先是大概有印象是用内外，但是没有用到函数compare，导致一直写错</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//注意不能写成if (left.val == right.val) return true; </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">outSide</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">inSide</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">        <span class="keyword">return</span> outSide &amp;&amp; inSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="104-二叉树最大深度-easy"><a href="#104-二叉树最大深度-easy" class="headerlink" title="104 二叉树最大深度 easy"></a>104 二叉树最大深度 easy</h3><p>使用递归法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.确定参数</span></span><br><span class="line"><span class="comment">2.确定终止条件</span></span><br><span class="line"><span class="comment">3.递归逻辑：先求它的左子树的深度，再求的右子树的深度，最后取左右深度最大的数值 再+1 （加1是因为算上当前中间节点）就是目前节点为根节点的树的深度。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> maxDepth(root.left);<span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> maxDepth(root.right);<span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(left, right);<span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="111-二叉树的最小深度-easy"><a href="#111-二叉树的最小深度-easy" class="headerlink" title="111 二叉树的最小深度 easy"></a>111 二叉树的最小深度 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个最小深度和最大深度是有区别的</span></span><br><span class="line"><span class="comment">比如，如果左子树都是空的，右子树一直叠加，那么最小深度，是算右子树那边的</span></span><br><span class="line"><span class="comment">那么就需要做出一个判断</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次做的时候，没有考虑到要同时满足条件再返回1+right或者left</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);<span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);<span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) &#123;<span class="comment">//左边空，右边不空，则返回右边长度，可以直接写成if (root.left == null)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + left;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span> + Math.min(left, right);<span class="comment">//找到最小值</span></span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="222-完全二叉树的节点个数-medium"><a href="#222-完全二叉树的节点个数-medium" class="headerlink" title="222 完全二叉树的节点个数 medium"></a>222 完全二叉树的节点个数 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">层序遍历即可，这个是自己想到的，然后套用前面的代码修改</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树-easy"><a href="#110-平衡二叉树-easy" class="headerlink" title="110 平衡二叉树 easy"></a>110 平衡二叉树 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于深度和高度，这只是力扣中的定义，其他教科书可能不一样</span></span><br><span class="line"><span class="comment">二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。</span></span><br><span class="line"><span class="comment">二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">关于这个题，首先要了解平衡二叉树的概念，然后如果已经检测到左右子树相差大于1，剩下都是返回-1，否则返回的是正常高度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次做存在的问题：</span></span><br><span class="line"><span class="comment">1.没有想到用一个辅助getheight函数，注意这个题是返回一个true还是false，而我们当然要用高度来判断</span></span><br><span class="line"><span class="comment">2.遗忘左-右绝对值的问题</span></span><br><span class="line"><span class="comment">3.需要注意如果已经不平衡的情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;<span class="comment">//不为-1，就返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//如果已经不平衡了，就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//如果已经不平衡了，就返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(left - right) &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//Math.abs函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="257-二叉树的所有路径-easy-1"><a href="#257-二叉树的所有路径-easy-1" class="headerlink" title="257 二叉树的所有路径 easy"></a>257 二叉树的所有路径 easy</h3><p><a href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy">代码此链接</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以前做过，为什么又忘记，这次复查到的问题：</span><br><span class="line">constructpath(root, <span class="string">&quot;&quot;</span>, paths);<span class="comment">//中间的参数，不能有空格，</span></span><br><span class="line">StringBuffer是append，还有需要toString()</span><br><span class="line">ArrayList是add</span><br><span class="line">递归函数里面的<span class="keyword">if</span> <span class="keyword">else</span>是套在第一个<span class="keyword">if</span>中的</span><br><span class="line">递归：<span class="number">1.</span>确定参数<span class="number">2.</span>终止条件<span class="number">3.</span>确定递归逻辑</span><br></pre></td></tr></table></figure>
<p>这个代码主要是为了方便理解回溯</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorderdfs(root, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderdfs</span><span class="params">(TreeNode root, List&lt;String&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        path.add(root.val);<span class="comment">//容易漏</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(path.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);<span class="comment">//注意这里是先加节点，然后继续加&quot;-&gt;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(path.get(path.size() - <span class="number">1</span>));<span class="comment">//因为最后一个的后面不需要加&quot;-&gt;&quot;，所以单独拿出来</span></span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            preorderdfs(root.left, res, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            preorderdfs(root.right, res, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量的写法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//第二次居然写成List&lt;List&lt;String&gt;&gt;</span></span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        backtrack(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        path.add(root.val);<span class="comment">//第二次写漏了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                sb.append(path.get(i)).append(<span class="string">&quot;-&gt;&quot;</span>);<span class="comment">//不要写成sb.append(path.get(i).append(&quot;-&gt;&quot;));append要放在外面</span></span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(path.get(path.size() - <span class="number">1</span>));</span><br><span class="line">            result.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            backtrack(root.left);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            backtrack(root.right);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="404-左叶子之和-easy"><a href="#404-左叶子之和-easy" class="headerlink" title="404 左叶子之和 easy"></a>404 左叶子之和 easy</h3><p>有点像求深度那个题，也是左右中的顺序，不同点是判断左叶子节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> sumOfLeftLeaves(root.left);<span class="comment">//左子树的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> sumOfLeftLeaves(root.right);<span class="comment">//右子树的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            mid = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left + right + mid;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">迭代法，这个和层序遍历还是有一点点差别的，没有len之后进行循环，这个要注意</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                sum += node.left.val;               </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.offer(node.right);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="513-找树左下角的值-medium"><a href="#513-找树左下角的值-medium" class="headerlink" title="513 找树左下角的值 medium"></a>513 找树左下角的值 medium</h3><p>用层序遍历的思路即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个代码是根据层序遍历后自己写的，但是写的不好，可以看第二个代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>) result = temp.val;</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">                len--;</span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;<span class="comment">//我这里设置了一个标志，当len为0，代表循环准备进入下一层</span></span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代法一直没调试好while，就是类似于层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;TreeNode&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();<span class="comment">//需要注意的是，len不用再--</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//这里用for就会简洁很多</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) result = temp.val;</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h3><h4 id="112-路径总和-easy"><a href="#112-路径总和-easy" class="headerlink" title="112 路径总和 easy"></a>112 路径总和 easy</h4><p>这个题目表达的不太清楚，实际上是判断路径有没有符合targetsum，只要有一个符合就返回true。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用减法来一步步走，走到最后叶子节点，如果此时target和叶节点相等，就说明找到了，这个题目只需要找到一个即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> targetSum == root.val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="113-路径总和2-easy"><a href="#113-路径总和2-easy" class="headerlink" title="113 路径总和2 easy"></a>113 路径总和2 easy</h4><p>这个题要结合<a href="#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-easy-1">257</a>，还有就是257的返回值和这个题不一样，257需要箭头指向，也就是类型是String，具体看是如何处理的，和112的区别是需要把target值都符合的添加进来，这三个题都要好好敲一遍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preorderdfs(root, targetSum, res, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorderdfs</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path)</span> &#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetSum == root.val) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            preorderdfs(root.left, targetSum - root.val, res, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            preorderdfs(root.right, targetSum - root.val, res, path);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过中序和前序-后序构建二叉树"><a href="#通过中序和前序-后序构建二叉树" class="headerlink" title="通过中序和前序&#x2F;后序构建二叉树"></a>通过中序和前序&#x2F;后序构建二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先要务必清楚要有中序遍历，前序和后序是不能组成二叉树的。</span><br><span class="line">这里只讲后序和中序构造二叉树。</span><br><span class="line">后序是：左右根</span><br><span class="line">中序是：左根右</span><br><span class="line">所以我们先从后序的最后一个数字可以定位根节点，然后在中序中找到这个值，就可以区分左子树和右子树啦</span><br><span class="line">也就是定义一个helper，这是用中序来构建二叉树。</span><br><span class="line"></span><br><span class="line">以后序遍历为例子的思路：</span><br><span class="line">首先把中序的值按照&lt;值，序号&gt;来存到map中，因为后面我们要用后序数组的值来寻找中序数组的序号，所以用&lt;值&gt;可以找到中序的&lt;下标序号&gt;</span><br><span class="line">然后在主方法中，先找到后序根的值，然后用map来定位到中序的index，然后新建root即可，注意后序的话要先构建右子树，再构建左子树</span><br></pre></td></tr></table></figure>
<h4 id="105-从前序与中序遍历序列构造二叉树-medium"><a href="#105-从前序与中序遍历序列构造二叉树-medium" class="headerlink" title="105 从前序与中序遍历序列构造二叉树 medium"></a>105 从前序与中序遍历序列构造二叉树 medium</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="type">int</span>[] inorder;</span><br><span class="line">    <span class="type">int</span> pre_idx;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootval</span> <span class="operator">=</span> preorder[pre_idx];</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval);</span><br><span class="line">        pre_idx++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(rootval);</span><br><span class="line">        root.left = helper(left, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre_idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer val : inorder) &#123;</span><br><span class="line">            map.put(val, idx++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, preorder.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="106-从中序与后序遍历序列构造二叉树-medium"><a href="#106-从中序与后序遍历序列构造二叉树-medium" class="headerlink" title="106 从中序与后序遍历序列构造二叉树 medium"></a>106 从中序与后序遍历序列构造二叉树 medium</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] inorder;<span class="comment">//成员变量</span></span><br><span class="line">    <span class="type">int</span>[] postorder;</span><br><span class="line">    <span class="type">int</span> post_idx;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootval</span> <span class="operator">=</span> postorder[post_idx];</span><br><span class="line">        post_idx--;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootval);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(rootval);</span><br><span class="line">        root.right = helper(index + <span class="number">1</span>, right);<span class="comment">//注意这里有需要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。</span></span><br><span class="line">        root.left = helper(left, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.inorder = inorder;<span class="comment">//使用this关键字指成员变量的值</span></span><br><span class="line">        <span class="built_in">this</span>.postorder = postorder;</span><br><span class="line">        post_idx = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer val : inorder) &#123;</span><br><span class="line">            map.put(val, idx++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="654-最大二叉树-medium"><a href="#654-最大二叉树-medium" class="headerlink" title="654 最大二叉树 medium"></a>654 最大二叉树 medium</h3><p>首先就是找到最大的值的下标，然后切成左边和右边，用前序遍历递归构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左闭右闭区间，和上面的106题目一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//这里是大于</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max_i</span> <span class="operator">=</span> max(nums, l ,r);<span class="comment">//每次递归都要重新找最大值的下标</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[max_i]);<span class="comment">//前序构造二叉树</span></span><br><span class="line">        root.left = construct(nums, l , max_i - <span class="number">1</span>);<span class="comment">//这里是-1</span></span><br><span class="line">        root.right = construct(nums, max_i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;<span class="comment">//这里是小于等于</span></span><br><span class="line">            <span class="keyword">if</span> (nums[max_i] &lt; nums[i]) &#123;</span><br><span class="line">                max_i = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左闭右开区间，这里我觉得不如左闭右开区间好记</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> construct(nums, <span class="number">0</span>, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_i</span> <span class="operator">=</span> max(nums, l ,r);<span class="comment">//每次递归都要重新找最大值的下标</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[max_i]);<span class="comment">//前序构造二叉树</span></span><br><span class="line">        root.left = construct(nums, l , max_i);<span class="comment">//注意这里还是max_i</span></span><br><span class="line">        root.right = construct(nums, max_i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max_i</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[max_i] &lt; nums[i]) &#123;</span><br><span class="line">                max_i = i; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树-easy"><a href="#617-合并二叉树-easy" class="headerlink" title="617 合并二叉树 easy"></a>617 合并二叉树 easy</h3><p>总体比较简单，看递归的返回值处理，其实就是两个二叉树覆盖在一起,思路就是重新构造一个二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;<span class="comment">//root1空就返回root2</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> root1.val + root2.val;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        root.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root.right = mergeTrees(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="700-二叉搜索树的搜索-easy"><a href="#700-二叉搜索树的搜索-easy" class="headerlink" title="700 二叉搜索树的搜索 easy"></a>700 二叉搜索树的搜索 easy</h3><p>需要注意的是，在递归的时候是用return，另外要了解搜索树的构造。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">也可以写成</span></span><br><span class="line"><span class="comment">        if (root == null) return null;</span></span><br><span class="line"><span class="comment">        if (root.val == val) return root;</span></span><br><span class="line"><span class="comment">这里是思路就是根据二叉搜索树的特点，找到了就返回root，如果大于就递归左子树，小于就递归右子树</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> searchBST(root.val &gt; val ? root.left: root.right, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个感觉代码上不够简洁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == val) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) <span class="keyword">return</span> searchBST(root.right, val);<span class="comment">//这里是用return，当前节点小，就要去右子树查找</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; val) <span class="keyword">return</span> searchBST(root.left, val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//最后是返回null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树-medium"><a href="#98-验证二叉搜索树-medium" class="headerlink" title="98 验证二叉搜索树 medium"></a>98 验证二叉搜索树 medium</h3><p>第二次做又忘记，二叉搜索树中序遍历是升序的，根据这个特性来完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;<span class="comment">//重要！注意前面声明是long而不是Long</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;<span class="comment">//如果左边有false，就返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;<span class="comment">//不符合二叉搜索树的定义</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root.val;<span class="comment">//记录上一个遍历的节点</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个代码只是为了说明pre的位置也很重要，这个代码更好理解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;<span class="comment">//重要！注意前面声明是long而不是Long</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">l</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果pre = root.val写在这里，又会覆盖掉，导致无法判断下面</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) &#123;<span class="comment">//关键部分，如果根比左边小，就肯定不符合了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pre = root.val;<span class="comment">//记录上一个遍历的节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">        <span class="comment">//如果放到这里是出错的 pre = root.val;</span></span><br><span class="line">        <span class="keyword">return</span> l &amp;&amp; r;<span class="comment">//左右都是true才能返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">下面重点来解释</span><br><span class="line">首先利用二叉搜索树升序的特性来做，也就是左子树&lt;根&lt;右子树</span><br><span class="line">所以递归顺序是左根右</span><br><span class="line"></span><br><span class="line">先说第一个<span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">为什么不用<span class="type">int</span>，因为测试案例的原因，不解释了</span><br><span class="line">这里主要解释为什么要用min，因为后台测试数据中有<span class="type">int</span>最小值，也就是有极端情况</span><br><span class="line">有这个案例：[-<span class="number">2147483648</span>]这个是<span class="type">int</span>的最小值，如果你的pre随便设置，最后结果是<span class="literal">false</span>，但是其实这个也算二叉搜索树，因为递归过程中会比较pre和root.val，你的pre这时候是大于val的，所以会<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第二个重点解释 pre = root.val;的位置问题，如果根据第二个解答写在r的下面</span><br><span class="line">对于[<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="literal">null</span>,<span class="literal">null</span>,<span class="number">3</span>,<span class="number">6</span>]案例是错误的答案，输出是<span class="literal">true</span>，但是实际上是<span class="literal">false</span></span><br><span class="line">画出这个二叉树，可以发现右子树中是出现一个<span class="number">3</span>，二叉搜索树的定义是根要比所有的右子树都小，你现在根比右边大，就是不合理的。</span><br><span class="line">所以进入右边之前，要保存上一个root的val，但是其实我觉得还有一个理解就是递归顺序就是左-根-右，这个pre其实就是递归到根的情况</span><br><span class="line">这样才可以用中序遍历 左边小于右边来比较</span><br></pre></td></tr></table></figure>
<h3 id="530-二叉搜索树的最小绝对差-medium"><a href="#530-二叉搜索树的最小绝对差-medium" class="headerlink" title="530 二叉搜索树的最小绝对差 medium"></a>530 二叉搜索树的最小绝对差 medium</h3><p>根据二叉搜索树的定义，用中序遍历完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个自己写的，可能有些不够简练,但是好记</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        traversal(root, result);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; result.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res = Math.min(res, result.get(i + <span class="number">1</span>) - result.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(root.left, result);</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        traversal(root.right, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个代码更精简</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode pre;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span> &#123;<span class="comment">//使用中序遍历，和上一个题类似哦</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        traversal(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            result = Math.min(result, root.val - pre.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;<span class="comment">//记录上一个节点</span></span><br><span class="line">        traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="501-二叉搜索树的众数-easy"><a href="#501-二叉搜索树的众数-easy" class="headerlink" title="501 二叉搜索树的众数 easy"></a>501 二叉搜索树的众数 easy</h3><p>用了中序遍历，也是利用二叉搜索树的性质，中序遍历是按照顺序升序的，主要是理解处理的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和98题结合看，一样是用中序的逻辑和pre，但是这里的pre初始化是null，和98的不一样</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxcount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        traversal(root);</span><br><span class="line">        <span class="type">int</span> result[] = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            result[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//左</span></span><br><span class="line">        traversal(root.left);</span><br><span class="line"><span class="comment">//根</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.val != root.val) &#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxcount) &#123;</span><br><span class="line">            list.clear();<span class="comment">//删除动态数组中的所有元素</span></span><br><span class="line">            list.add(root.val);<span class="comment">//第二次写的时候忘记这里的逻辑</span></span><br><span class="line">            maxcount = count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == maxcount)&#123;</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右</span></span><br><span class="line">        traversal(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="236-二叉树的最近公共祖先-medium"><a href="#236-二叉树的最近公共祖先-medium" class="headerlink" title="236 二叉树的最近公共祖先 medium"></a>236 二叉树的最近公共祖先 medium</h3><p>这个题需要好好看卡哥的讲解。这里容易漏掉一种情况，就是p是q的祖先，或者反过来，第二次看这个题还是没有想到为什么用后序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要从小到上，也就是先获取叶子节点，所以后序遍历</span></span><br><span class="line"><span class="comment">用递归的解法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) &#123;<span class="comment">//第二次写居然写成p == null，q == null，还是理解不到位，这里要理解为如果找到了 节点p或者q，或者遇到空节点，就返回。</span></span><br><span class="line">            <span class="keyword">return</span> root;<span class="comment">//注意不是返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;<span class="comment">// 若未找到节点 p 或 q</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;<span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;<span class="comment">// 若找到一个节点</span></span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 若找到两个节点</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="235-二叉搜索树的最近公共祖先-easy"><a href="#235-二叉搜索树的最近公共祖先-easy" class="headerlink" title="235 二叉搜索树的最近公共祖先 easy"></a>235 二叉搜索树的最近公共祖先 easy</h3><p>用上面一个代码也是可以的，不过我们可以利用二叉搜索树的性质来完成。也就是如果root的值都小于p和q，那就去右区间找，如果都大于就在左区间找，如果在p和q的区间内，说明找到，就返回root。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="701-二叉搜索树中的插入操作-medium"><a href="#701-二叉搜索树中的插入操作-medium" class="headerlink" title="701 二叉搜索树中的插入操作 medium"></a>701 二叉搜索树中的插入操作 medium</h3><p>利用二叉搜索树的性质来插入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;<span class="comment">//找到插入节点的位置了，并把插入的节点返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);<span class="comment">//第二次做手误写成root.val</span></span><br><span class="line">            <span class="comment">/*或者写成这样</span></span><br><span class="line"><span class="comment">            TreeNode node = new TreeNode(val);</span></span><br><span class="line"><span class="comment">            return node;</span></span><br><span class="line"><span class="comment">            */</span>    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root-&gt;left或者root-&gt;right将其接住</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val) &#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val);<span class="comment">// 第二次做居然写成return了</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val) &#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//一直容易忘记这个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="450-删除二叉搜索树中的节点-medium"><a href="#450-删除二叉搜索树中的节点-medium" class="headerlink" title="450 删除二叉搜索树中的节点 medium"></a>450 删除二叉搜索树中的节点 medium</h3><p>有点难度的题，下面有具体解释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//情况1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//情况2</span></span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;<span class="comment">//情况3</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;<span class="comment">//情况4</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;<span class="comment">//情况5</span></span><br><span class="line">            <span class="keyword">while</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp = temp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root.val = temp.val;</span><br><span class="line">            root.right = deleteNode(root.right, temp.val);<span class="comment">//因为这个节点是root的右孩子中，所以用root的右孩子作为新root，同时删除这个节点原来的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//最后别忘了返回root</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一共五种情况</span><br><span class="line"><span class="number">1.</span>没找到删除的节点，直接返回<span class="literal">null</span></span><br><span class="line">然后开始搜索正确的位置，找到节点的情况</span><br><span class="line"><span class="number">2.</span>左右孩子都是空的，返回<span class="literal">null</span></span><br><span class="line"><span class="number">3.</span>右孩子空，把左孩子补上去</span><br><span class="line"><span class="number">4.</span>左孩子空，把有孩子补上去</span><br><span class="line"><span class="number">5.</span>有左右孩子，这个情况最复杂，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点，下面详细讲操作。</span><br><span class="line"></span><br><span class="line">先找到这个key的右孩子，然后一直找这个右孩子的最左边的孩子，这时候就顺便把这个孩子的节点值设为root，然后递归删除这个值。</span><br></pre></td></tr></table></figure>
<h3 id="669-修剪二叉搜索树-medium"><a href="#669-修剪二叉搜索树-medium" class="headerlink" title="669 修剪二叉搜索树 medium"></a>669 修剪二叉搜索树 medium</h3><p>把范围之外的节点清除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在边界范围外的，好好看看下面的注释，为什么要return,和上一题对比</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//第二次做的时候漏了，任何情况都要考虑空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;<span class="comment">//不在范围内的节点，需要继续寻找。小于val，就去右边区间寻找，抛弃其左子树整体。</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);<span class="comment">// 如果当前结点小于下界，直接将修剪后的右子树替换当前节点并返回，所以要return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;<span class="comment">//不在范围内的节点，需要继续寻找。大于val，就去左边区间寻找，抛弃其右子树整体。</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high); <span class="comment">// 如果当前结点大于上界，直接将修剪后的左子树替换当前节点并返回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果数字在区间内,就去裁剪左右子节点</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树-easy"><a href="#108-将有序数组转换为二叉搜索树-easy" class="headerlink" title="108 将有序数组转换为二叉搜索树 easy"></a>108 将有序数组转换为二叉搜索树 easy</h3><p>可以对比下构造二叉树那个题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bst(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);<span class="comment">//因为下面的递归是用左闭右闭区间，所以长度-1。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//左闭右闭的区间，所以当区间 left &gt; right的时候，就是空节点了</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);<span class="comment">//构造中间节点</span></span><br><span class="line">        <span class="comment">//然后构造两边</span></span><br><span class="line">        root.left = bst(nums, left, mid - <span class="number">1</span>);<span class="comment">//mid已经用了，所以要减1</span></span><br><span class="line">        root.right = bst(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="538-把二叉搜索树转换为累加树-medium"><a href="#538-把二叉搜索树转换为累加树-medium" class="headerlink" title="538 把二叉搜索树转换为累加树 medium"></a>538 把二叉搜索树转换为累加树 medium</h3><p>这个先看定义，就是使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。中序遍历是升序，这样不方便累加，要从后往前，也就是中反的中序遍历，右中左。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//定义sum</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;<span class="comment">//这个很关键</span></span><br><span class="line">        convertBST(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h2><p>一般用于组合，切割，子集，排列，棋盘问题。<br>回溯三部曲<br>1.回溯函数模板返回值以及参数，返回值一般为void<br>2.回溯终止条件<br>3.回溯遍历过程<br>回溯模板</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<span class="comment">//for可以理解为横向遍历</span></span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归，递归可以理解为纵向遍历</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">关于剪枝操作，这是卡哥原话</span><br><span class="line">剪枝精髓是：<span class="keyword">for</span>循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。</span><br></pre></td></tr></table></figure>
<h3 id="77-组合-medium"><a href="#77-组合-medium" class="headerlink" title="77 组合 medium"></a>77 组合 medium</h3><p>注意取过的数字不再取，也就是没有(4,4)这种情况，组合是无序(也就是(1,2)和(2,1)是一样的，取一个就可以)，排列是有序(两个答案都要)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个代码没有进行剪枝处理</span></span><br><span class="line"><span class="comment">返回范围 [1, n] 中所有可能的 k 个数的组合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        backtrack(n, k ,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//return语句后不带返回值，作用是退出该程序的运行，终止本层的递归</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt;= n; i++) &#123;<span class="comment">//startindex是为了让程序知道从哪个数字开始取，不能重复的，for (int i = startindex; i &lt;= n - (k - path.size()) + 1; i++)这是剪枝处理</span></span><br><span class="line">            path.add(i);<span class="comment">//把这个数字加进去</span></span><br><span class="line">            backtrack(n, k, i + <span class="number">1</span>);<span class="comment">//递归开始，纵向遍历</span></span><br><span class="line">            path.removeLast();<span class="comment">//把这个数字取出来，再加其他数字，比如原来[1,2]，然后把2取出来，把3加进去，就有[1,3]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">注意这个才有removeLast的操作，arraylist是没有的。</span><br><span class="line">对剪枝的理解</span><br><span class="line">比如 n = <span class="number">7</span>, k = <span class="number">4</span>，那么从 <span class="number">5</span> 开始搜索就已经没有意义了，这是因为即使把 <span class="number">5</span> 选上，后面的数只有 <span class="number">6</span> 和 <span class="number">7</span>，一共就 <span class="number">3</span> 个候选数，凑不出 <span class="number">4</span> 个数的组合。因此，搜索起点有上界。 </span><br></pre></td></tr></table></figure>
<h3 id="216-组合总和-III-medium"><a href="#216-组合总和-III-medium" class="headerlink" title="216 组合总和 III medium"></a>216 组合总和 III medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找出所有相加之和为 n 的 k 个数的组合，只使用数字1到9，每个数字 最多使用一次 </span></span><br><span class="line"><span class="comment">和上一题的区别是，这个题的n的目标数，潜在的范围其实是[1,9]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtrack(k, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> sum, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="comment">// 减枝，这句话没有也是可以通过的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == sum) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            backtrack(k, n, sum + i, i + <span class="number">1</span>);<span class="comment">//和下面解法的区别</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        backtrack(k, n, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> sum, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="comment">// 减枝，这句话没有也是可以通过的</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == sum) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt;= <span class="number">9</span>; i++)&#123;<span class="comment">//这里也可以进行剪枝</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            sum += i;<span class="comment">//最开始是看到这个写法，后面看到更简洁，就更新了，我觉得和上一个解法的区别是在递归的时候sum有i去控制大小，而这里没有，所以递归后还要减掉。</span></span><br><span class="line">            backtrack(k, n, sum, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">            sum -= i;<span class="comment">//这里是容易忘记的，因为你回溯，务必减去上一个数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-电话号码的字母组合-medium"><a href="#17-电话号码的字母组合-medium" class="headerlink" title="17 电话号码的字母组合 medium"></a>17 电话号码的字母组合 medium</h3><p>这个题和上一题的区别是，这个题相当于多个区间进行取值，而上个题是一个区间内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] numString = &#123;<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;<span class="comment">//这是为了对应2~9，特意空出两个字符</span></span><br><span class="line">        backtrack(numString, digits, <span class="number">0</span>);<span class="comment">//这个0，是获取第一个digits的数字用的</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String[] numString, String digits, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == digits.length()) &#123;<span class="comment">//这个条件也是不一样的，因为在循环数字</span></span><br><span class="line">            result.add(temp.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> numString[digits.charAt(num) - <span class="string">&#x27;0&#x27;</span>];<span class="comment">//先把这个数字对应的字母取出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;<span class="comment">//这就是和上题的区别，i=0，是这个区间的开始，而上一个题的同一个区间，所以要找下一个数</span></span><br><span class="line">            temp.append(str.charAt(i));<span class="comment">//这里是append</span></span><br><span class="line">            backtrack(numString, digits, num + <span class="number">1</span>);</span><br><span class="line">            temp.deleteCharAt(temp.length() - <span class="number">1</span>);<span class="comment">//还有这个用法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="39-组合总和-medium"><a href="#39-组合总和-medium" class="headerlink" title="39 组合总和 medium"></a>39 组合总和 medium</h3><p>结合216来看，和216的区别是，这里给了一个数组的范围，其次，数组元素的可以重复使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);<span class="comment">//排序很重要</span></span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;<span class="comment">//没有这句也是报错的，如果 sum + candidates[i] &gt; target 就终止遍历</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtrack(candidates, target, sum + candidates[i], i);<span class="comment">//这里不是i + 1，就体现了可以重复使用这个数组的思想</span></span><br><span class="line">            path.removeLast(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和-II-medium-1"><a href="#40-组合总和-II-medium-1" class="headerlink" title="40 组合总和 II medium"></a>40 组合总和 II medium</h3><p>这里实际上要完成两个任务，一个是不能有重复元素(是指这个数组中不能重复用这个数，但是数组本身是可以有重复是数字的，比如这个数组可以存在两个1，但是每个1只能用一次)，第二个是不能有重复组合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解决不能有重复组合，需要在for中进行去除，也就是对每层的处理</span></span><br><span class="line"><span class="comment">解决不能重复数字以前则遇到过，在回溯的时候，i＋1即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> idx; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; idx &amp;&amp; candidates[i - <span class="number">1</span>] == candidates[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="comment">//这里就是重复组合的问题</span></span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">break</span>;</span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            backtrack(candidates, target, sum + candidates[i], i + <span class="number">1</span>);<span class="comment">//i+1解决重复元素的问题</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="131-分割回文串-medium"><a href="#131-分割回文串-medium" class="headerlink" title="131 分割回文串 medium"></a>131 分割回文串 medium</h3><p>回文串 是正着读和反着读都一样的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtrack(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startindex == s.length()) &#123;<span class="comment">//切割线到了最后作为终止条件</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ishuiwen(s, startindex, i)) &#123;<span class="comment">//这里已经判断了是否回文，所以在上面终止条件直接添加结果即可</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(startindex, i + <span class="number">1</span>);</span><br><span class="line">                path.add(str);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtrack(s, i + <span class="number">1</span>);<span class="comment">//因为也是不能往回走，所以+1</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ishuiwen</span><span class="params">(String s, <span class="type">int</span> startindex, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">首先我们要明白startindex的作用就是相当于切割线的作用</span><br><span class="line">这个题的<span class="keyword">for</span>循环是切了第一根线（横向），然后回溯递归的过程是纵向（切第二跟线），这样可以实现切割不同字符串的效果。</span><br><span class="line">那么又有一个疑问，为什么是两条线，因为第一条线固定第一个位置，然后第二根线是一个个位置继续切。</span><br><span class="line"></span><br><span class="line">问题<span class="number">1</span>：为什么回溯结束条件是<span class="keyword">if</span> (startindex == s.length())</span><br><span class="line">当切割线到了最后，说明后面不能再切了，所以这里要设置结束条件并添加结果。</span><br><span class="line">可是，这里没有判断回文呀？</span><br><span class="line">其实不是的，下面<span class="keyword">for</span>循环的时候，已经判断回文，如果不是回文的话，不参加递归，所以，只要参加了递归，就一定是回文。</span><br><span class="line"></span><br><span class="line">这个题要好好看卡哥的画图，可以理解这个切割线。</span><br><span class="line"></span><br><span class="line">substring(start,end)是左开右闭，也就是end序号是没有截取到了，而我们判断回本的时候，end是参与了判断的，所以这里要加<span class="number">1</span>让这个字符串截取到。</span><br></pre></td></tr></table></figure>
<h3 id="93-复原ip地址-medium"><a href="#93-复原ip地址-medium" class="headerlink" title="93 复原ip地址 medium"></a>93 复原ip地址 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        backtrack(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(String s, <span class="type">int</span> startindex, <span class="type">int</span> pointnum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pointnum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isvalid(s, startindex, s.length() - <span class="number">1</span>)) &#123;<span class="comment">//逗点已经写了3个，也就是切成了4份，最后再判断完第四个区间即可</span></span><br><span class="line">                result.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isvalid(s, startindex, i)) &#123;<span class="comment">//substring是左开右闭</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">&quot;.&quot;</span> + s.substring(i + <span class="number">1</span>);<span class="comment">//在str的后⾯插⼊⼀个逗点</span></span><br><span class="line">                pointnum++;<span class="comment">//记录逗点个数</span></span><br><span class="line">                backtrack(s, i + <span class="number">2</span>, pointnum);<span class="comment">//插⼊逗点之后下⼀个⼦串的起始位置为i+2</span></span><br><span class="line">                pointnum--;<span class="comment">//回溯的时候恢复</span></span><br><span class="line">                s = s.substring(<span class="number">0</span>, i + <span class="number">1</span>) + s.substring(i + <span class="number">2</span>);<span class="comment">//回溯除去逗点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//continue也可以</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isvalid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start) == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;<span class="comment">// start != end是为了这个条件：当[0,0,0,0]，单独传入一个0就是start等于end，所以也可以写成start&lt;end</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++) &#123;<span class="comment">//这里的end注意下，是&lt;=哦</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) &lt; <span class="string">&#x27;0&#x27;</span> || s.charAt(i) &gt; <span class="string">&#x27;9&#x27;</span>) &#123;<span class="comment">//这个判断可以省略，案例不存在非法字符</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//最后返回true也容易忘记</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个题和上面题的区别：</span><br><span class="line"><span class="number">1.</span>没有path变量</span><br><span class="line">这个题从头到尾都需要整个s，而之前的题目的类似于从里面选若干个元素。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>ip有效判断</span><br><span class="line">首先最主要的判断是区间必须是左小右大，也就是start&gt;end是非法的</span><br><span class="line">first：<span class="number">0</span>开头的数字不合法，但是如果单独<span class="number">0</span>的话是可以的，比如[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">second：遇到⾮数字字符不合法（这个可以不需要，因为案例中都是数字）</span><br><span class="line">third：大于<span class="number">255</span>的不合法</span><br></pre></td></tr></table></figure>
<h3 id="78-子集-medium"><a href="#78-子集-medium" class="headerlink" title="78 子集 medium"></a>78 子集 medium</h3><p>和77的区别是这个是回溯的if条件的不同，这里是小于等于，还有就是不能有return。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &lt;= nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">//这里不能写return;否则出错，有return说明要终止本层的递归，我们要取树上的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="90-子集2-medium"><a href="#90-子集2-medium" class="headerlink" title="90 子集2 medium"></a>90 子集2 medium</h3><p>遇到这个重复元素的，想都不用想，先排序，然后再处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &lt;= nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">//不要有return哦，否则会终止本层递归，我们要取树上的节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; startindex &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) &#123;<span class="comment">//子集不能有重复的</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="491-递增子序列-medium"><a href="#491-递增子序列-medium" class="headerlink" title="491 递增子序列 medium"></a>491 递增子序列 medium</h3><p>这个题不能排序，要用到原数组的顺序，所以可能会出现[4,6,4,7]这种数组，所以上一题子集不能重复的代码思想不能用到，要用map要判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtrack(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) &#123;<span class="comment">//因为是递增子集，所以必须要有至少两个数才可以</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//for循环中用map来记录使用过的数字次数，避免最后由重复子集。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//满足递增子集，所以上一个数要是大于下一个数就去掉，还有就是这个数有重复用也去掉</span></span><br><span class="line">            <span class="keyword">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.getLast() || map.getOrDefault(nums[i], <span class="number">0</span>) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);<span class="comment">//用了这个数就加1</span></span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtrack(nums, i + <span class="number">1</span>);<span class="comment">//i+1纵向遍历不能重复的</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="comment">//这里不需要map减去之前用过的数哦，我的理解是这个主要是因为用在for循环的横向遍历中，要是这里减1会出现重复的子集，可以对比下target那些题。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>if条件也可以写成这样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> startindex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startindex; i &lt; nums.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.getLast()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.getOrDefault(nums[i], <span class="number">0</span>) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="comment">//这里是区别哦</span></span><br><span class="line"></span><br><span class="line">        map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        path.add(nums[i]);</span><br><span class="line">        backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="46-全排列-medium"><a href="#46-全排列-medium" class="headerlink" title="46 全排列 medium"></a>46 全排列 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//和组合的区别1</span></span><br><span class="line">            <span class="keyword">if</span> (path.contains(nums[i])) &#123;<span class="comment">//和组合的区别2</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backtrack(nums);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">讲解组合和排列的区别</span><br><span class="line">组合也就是[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]和[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>]是一样的</span><br><span class="line">而排列则视为他们是两个不同的结果。</span><br><span class="line"></span><br><span class="line">所以在组合问题中使用了startindex来控制横向遍历中的重复元素问题</span><br><span class="line">而排列则不需要，因为我们还会使用以前用过的数字，所以排列的时候，<span class="keyword">for</span>就是全体元素的遍历，但是用过的数是不能用的，所以用path.contains来排除</span><br><span class="line"></span><br><span class="line">这也是组合和排列的区别啦</span><br></pre></td></tr></table></figure>
<h3 id="47-全排列2-medium-1"><a href="#47-全排列2-medium-1" class="headerlink" title="47 全排列2 medium"></a>47 全排列2 medium</h3><p>这题的数组中可以有重复的数字，那么又如何去重呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和40题一样的是，需要先进行排序</span></span><br><span class="line"><span class="comment">解决横向遍历中的重复数字i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]也想到了</span></span><br><span class="line"><span class="comment">但是这里是全排列问题，在纵向遍历中会重复，所以这里需要用到一个used的数组</span></span><br><span class="line"><span class="comment">不过这个题不好理解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] used;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.fill(used, <span class="literal">false</span>);</span><br><span class="line">        backtrack(nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//used[i -1] == false说明同⼀树层nums[i - 1]使⽤过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; used[i -<span class="number">1</span>] == <span class="literal">false</span>) &#123;<span class="comment">//这里的used[i -1] == false也能填true，但是代表两个意思，具体看卡哥解释</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;<span class="comment">//如果同⼀树⽀nums[i]没使⽤过开始处理</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;<span class="comment">//标记</span></span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                backtrack(nums);</span><br><span class="line">                path.removeLast();</span><br><span class="line">                used[i] = <span class="literal">false</span>;<span class="comment">//取消标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="332-重新安排行程-hard"><a href="#332-重新安排行程-hard" class="headerlink" title="332 重新安排行程 hard"></a>332 重新安排行程 hard</h3><h3 id="51-N皇后-hard"><a href="#51-N皇后-hard" class="headerlink" title="51 N皇后 hard"></a>51 N皇后 hard</h3><h3 id="21-解数独-hard"><a href="#21-解数独-hard" class="headerlink" title="21 解数独 hard"></a>21 解数独 hard</h3><h2 id="贪心算法-1"><a href="#贪心算法-1" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="455-分发饼干-easy"><a href="#455-分发饼干-easy" class="headerlink" title="455 分发饼干 easy"></a>455 分发饼干 easy</h3><p>思路很简单，一个for循环就行，先排序，小饼干分给小胃口，然后注意越界问题就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; g.length &amp;&amp; s[i] &gt;= g[j]) &#123;<span class="comment">//必须j &lt; g.length放前面，先判断超界问题，这个是可能忘记的，因为饼干数量和小朋友数量不一定是一样的</span></span><br><span class="line">                count++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="376-摆动序列-medium"><a href="#376-摆动序列-medium" class="headerlink" title="376 摆动序列 medium"></a>376 摆动序列 medium</h3><p>可动态规划，要明确返回的是原始序列的长度哦，但是这个原始序列不一定就是题目给的全体，可能是子序列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//初始化是1，至于为什么，可以理解下[1,1]这个数组，最后返回是数量2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;<span class="comment">//从头到尾进行遍历，注意因为要第二个数减去第一个数，所以从1开始</span></span><br><span class="line">            cur = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((cur &gt; <span class="number">0</span> &amp;&amp; pre &lt;= <span class="number">0</span>) || (cur &lt; <span class="number">0</span> &amp;&amp; pre &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                pre = cur;<span class="comment">//要在if中加，这样才能保留上一个坡，而不是在if外围加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="53-最大子数组和-medium"><a href="#53-最大子数组和-medium" class="headerlink" title="53 最大子数组和 medium"></a>53 最大子数组和 medium</h3><p>可动态规划，这里不要太关注数组下标，一开始老想着这个left和right，和209进行一个对比（这个题是算长度，以及人家有目标值），要注意是连续的子区间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (count &gt; result) &#123;</span><br><span class="line">                result = count;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果 -<span class="number">2</span> <span class="number">1</span> 在一起，计算起点的时候，一定是从<span class="number">1</span>开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</span><br><span class="line"></span><br><span class="line">利用两个数来完成这个题，result来记录最大的值，同时也是结果值，而count是记录区间的值</span><br><span class="line"></span><br><span class="line">我们要知道最大和，意味着我们不能加上负数，否则只会越来越小，而count是记录区间的大小，当区间大小为负数的时候，我们就不要这个区间了，在下个位置重新开始记录初始化为<span class="number">0</span>，在这个过程中一直对比最大值即可。</span><br><span class="line"></span><br><span class="line">和<span class="number">209</span>的区别，<span class="number">209</span>是求最小的长度，而且是有targer的，当和大于等于这个targer后在慢慢看最小的长度，而本题是计算和</span><br></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机II-medium"><a href="#122-买卖股票的最佳时机II-medium" class="headerlink" title="122 买卖股票的最佳时机II medium"></a>122 买卖股票的最佳时机II medium</h3><p>可动态规划，贪心思想：局部最优：收集每天的正利润，全局最优：求得最大利润。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            result += Math.max((prices[i] - prices[i - <span class="number">1</span> ]),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="55-跳跃游戏-medium"><a href="#55-跳跃游戏-medium" class="headerlink" title="55 跳跃游戏 medium"></a>55 跳跃游戏 medium</h3><p>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cover</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//这里是cover是值步数，而这个步数能否覆盖到最后即可判断为true。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= cover; i++) &#123;<span class="comment">//注意这里是cover 不是nums的长度，因为cover初试值是0，所以要小于等于哦</span></span><br><span class="line">            cover = Math.max(i + nums[i], cover);<span class="comment">//cover是会改变的</span></span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//cover是对应数组下标，所以nums的长度-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="45-跳跃游戏2-medium"><a href="#45-跳跃游戏2-medium" class="headerlink" title="45 跳跃游戏2 medium"></a>45 跳跃游戏2 medium</h3><p>和上一题的区别是这题要算出一个最小的步数，只需要考虑覆盖的范围是不是到最后一个，而本题没那么简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里解释为什么循环是nums.length - 1而不是nums.length</span></span><br><span class="line"><span class="comment">在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设我们就是nums.length，用案例[2,3,1,1,4]</span></span><br><span class="line"><span class="comment">那么最大范围是下标会是 2（第一次可以跳的下标范围） 4（第二次可以跳的下标范围） 8，其实在第二步4的时候已经到了最后了，但是又多跳一步，然后最大范围可以是8，也就是避免刚好到了末尾又跳</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//上次跳跃可达范围右边界（下次的最右起跳点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxcount</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//目前能跳到的最远位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//跳跃次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;<span class="comment">//注意上一题的循环变量是cover</span></span><br><span class="line">            maxcount = Math.max((i + nums[i]), maxcount);<span class="comment">//取最大的范围</span></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123; <span class="comment">// 到达上次跳跃能到达的右边界了</span></span><br><span class="line">                end =  maxcount;<span class="comment">// 目前能跳到的最远位置变成了下次起跳位置的有边界</span></span><br><span class="line">                step++; <span class="comment">// 进入下一次跳跃</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1005-K-次取反后最大化的数组和-easy"><a href="#1005-K-次取反后最大化的数组和-easy" class="headerlink" title="1005 K 次取反后最大化的数组和 easy"></a>1005 K 次取反后最大化的数组和 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路就是让最小的负数的开始取反(排序)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果所有的负数已经取反了，但是k还是大于0，那就让重新排序，让前面小的值来取反，每次都要重新排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最后求和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = -nums[i];          </span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Arrays.sort(nums);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//小于k哦</span></span><br><span class="line">                nums[i] = -nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            result += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="134-加油站-medium"><a href="#134-加油站-medium" class="headerlink" title="134 加油站 medium"></a>134 加油站 medium</h3><p>要充分利用贪心的思想。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路如下，设置两个变量totalsum和cursum。</span></span><br><span class="line"><span class="comment">totalsum就是全部的加油量减去耗油量，如果大于0，说明是可以跑完一圈的</span></span><br><span class="line"><span class="comment">然后在这个的基础上，我们可以去找开始出发点，利用到cursum，这个变量就是从[i,j]范围内的加油量减去耗油量，如果是负数的话，我们的起始点就设置为下一个数，然后重新计算cursum</span></span><br><span class="line"><span class="comment">我一开始在想的时候，会考虑到cost[i]是去第i+1个的耗油量，cursum里面是计算gas[i]-cost[i]，所以会不会不对应呢，其实不会的</span></span><br><span class="line"><span class="comment">比如gas是[3,4]，cost是[4,2]，你如果在0号，那么cursum就是-1.也就是说当前加的油不够去下一站，所以这个是对应上的，那么这个起始点就不能选择，所以就移动一位检查下一个起始点，务必注意cursum要重新置0。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cursum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalsum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;</span><br><span class="line">            cursum += gas[i] - cost[i];</span><br><span class="line">            totalsum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (cursum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cursum = <span class="number">0</span>;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalsum &lt; <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="135-分发糖果-hard-1"><a href="#135-分发糖果-hard-1" class="headerlink" title="135 分发糖果 hard"></a>135 分发糖果 hard</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">领悟的关键，更新的时候能不能用上新的值来比较，遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里需要注意从前往后遍历，需要用右边来对比左边，然后更新右边的值，那么下一次循环再对比，原来右边的值变成左边，这时候再进行右边是否大于左边去更新，因为这时候左边的值是新值，是有意义的</span></span><br><span class="line"><span class="comment">如果我们来更新左边的值，比如左边大于右边，然后更新左边的值，到了下一次循环，下一次的左边是一个旧值，没有意义，我们用不到新的值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">然后处理完左边循环（右比左大），然后处理从右边开始的循环，左边比右边大，更新左边的值（注意这时候不是右边原来的值加1，不然会破坏原来前序遍历的结果），需要取就取candys[i + 1] + 1 和 candys[i] 最大的糖果数量</span></span><br><span class="line"><span class="comment">比如举个例子[1,3,4,5,2]，前序遍历完后糖果数组是[1,2,3,4,1]，如果你这时候用candys[i+1]+1更新的话，就变成[1,2,3,2,1]，第四个位置就乱套了，所以取他们的最大值即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candys =  <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(candys,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;<span class="comment">//右边比左边大</span></span><br><span class="line">                candys[i] = candys[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;<span class="comment">//左边比右边大</span></span><br><span class="line">                candys[i] = Math.max(candys[i], candys[i + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : candys) &#123;</span><br><span class="line">            result += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="860-柠檬树找零-easy"><a href="#860-柠檬树找零-easy" class="headerlink" title="860 柠檬树找零 easy"></a>860 柠檬树找零 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">别看代码特多逻辑判断，其实很简单，就三种情况</span></span><br><span class="line"><span class="comment">1.付款5元的，直接收取，记录5元张数</span></span><br><span class="line"><span class="comment">2.付款10元的，只能找5元，记录10元张数，同时找5元（减张数），如果不够找，直接返回false</span></span><br><span class="line"><span class="comment">3.付款20元的，可以找10元和5元的，也可以纯5元的，这时候就判断够不够找，不够也返回false</span></span><br><span class="line"><span class="comment">最后别忘了返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">twenty</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//其实也可以不用这个参数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bills.length; i++) &#123;</span><br><span class="line">            temp = bills[i] / <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">1</span>) &#123;</span><br><span class="line">                five++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (five &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                twenty++;</span><br><span class="line">                <span class="keyword">if</span> (ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five = five - <span class="number">3</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="406-根据身高重建队列-medium-1"><a href="#406-根据身高重建队列-medium-1" class="headerlink" title="406 根据身高重建队列 medium"></a>406 根据身高重建队列 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思想就是先排序（高到低排），再插队（下标就是插入的位置），至于为什么，这是贪心的思想，数学证明很难哦，局部最优做到总体最优，矮个子排在哪都对高个子没有影响，但是高个子排在矮个子前面就会造成影响。所以，矮个子要主动选择位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people,(a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        );<span class="comment">//这里有分号</span></span><br><span class="line">        LinkedList&lt;<span class="type">int</span>[]&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] p : people) &#123;<span class="comment">//这里是people哦</span></span><br><span class="line">            que.add(p[<span class="number">1</span>],p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入是[[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">5</span>,<span class="number">2</span>]]，最终结果是[[<span class="number">5</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">0</span>],[<span class="number">5</span>,<span class="number">2</span>],[<span class="number">6</span>,<span class="number">1</span>],[<span class="number">4</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">1</span>]]</span><br><span class="line">这里好多语法是第一次见，详细记录一下</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];<span class="comment">//如果身高相同，就按照比他高的人数进行升序排序，也就是第二个位置的数进行由小到大排</span></span><br><span class="line"><span class="keyword">return</span> b[<span class="number">0</span>] - a[<span class="number">0</span>];<span class="comment">//否则身高不相同，就按照逆序排，也就是从高到矮排</span></span><br><span class="line"></span><br><span class="line">a和b分别代表第一个数组和第二个数组</span><br><span class="line"><span class="number">0</span>和<span class="number">1</span>就是这个数组的身高和比他高的人数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LinkedList.add(<span class="type">int</span> index,E elemnt)<span class="comment">//add(索引位置,待插入元素)</span></span><br><span class="line">也就是按照数组第二个位置进行插入即可</span><br><span class="line"></span><br><span class="line">将que转成数组，下面是打印出第一个数的情况</span><br><span class="line"><span class="type">int</span>[][] res = que.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);</span><br><span class="line">System.out.print(Arrays.toString(res[<span class="number">0</span>]));<span class="comment">//输出是[5, 0]</span></span><br><span class="line">二维数组可以不定义列数，但必须定义行数。</span><br></pre></td></tr></table></figure>
<h3 id="452-用最小数量的箭引爆气球-medium"><a href="#452-用最小数量的箭引爆气球-medium" class="headerlink" title="452 用最小数量的箭引爆气球 medium"></a>452 用最小数量的箭引爆气球 medium</h3><p>学习下这个二维数组的排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">先理解为什么要排序，可以理解为这个数组的顺序只是告诉你他们的位置而已</span></span><br><span class="line"><span class="comment">然后要知道，一只箭射的是可以重叠的区间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">首先获得第一个气球的右边界</span></span><br><span class="line"><span class="comment">然后循环判断，如果下一个气球的左边界比上一个气球的右边界还小（等于也行），说明他们是重叠的，可以用一只箭，然后更新这个右边界的值</span></span><br><span class="line"><span class="comment">为什么要更新这个右边界的值呢，怎么更新呢？</span></span><br><span class="line"><span class="comment">如果第一个区间是[0,100]，那么初试的右边界是100,第二个区间是[3,4],他们可以用一只箭，但是如果第三个区间是[5,6]，需要新箭了，因为[3,4]和[5,6]不重叠，不能用一只箭</span></span><br><span class="line"><span class="comment">所以更新区间的策略是用最大右边界的值和当前区间的右边界值进行比较，取小的那个</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个题要纵向看，如下图所示</span></span><br><span class="line"><span class="comment">然后接着下一个区间，判断左边界和比最大右边区间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>],b[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //用x[0] - y[0] 会大于2147483647 造成整型溢出</span></span><br><span class="line"><span class="comment">        Arrays.sort(points,(a, b) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            return a[0] - b[0];</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//因为无论如何至少有一支箭</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightedge</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; rightedge) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                rightedge = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightedge = Math.min(rightedge, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/452.jpg"></p>
<h3 id="435-无重叠区间-medium"><a href="#435-无重叠区间-medium" class="headerlink" title="435 无重叠区间 medium"></a>435 无重叠区间 medium</h3><p>去掉重叠的区间，[1,2],[2,3]不算重叠，然后计算需要去掉的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和上个题很像，但是这个题是去除重叠的区间，计数即可，不需要返回去除后的区间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">思路是左边区间从小到大排序</span></span><br><span class="line"><span class="comment">然后取第一个数组的右边区间作为右边界rightedge</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">开始循环，如果第二个数的左边区间小于rightedge，说明重叠了，这时候要count++，至于移除哪个，你不需要纠结，你计数即可，然后重新取右边区间</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">可以看到，这个题和上一题的逻辑 是有点相反的！</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次做的反思：关于min的问题，这里是相交的时候取最小的右边，二个数的左边区间小于rightedge，重叠，肯定要移除一个，但是为什么保留较小的右边呢，因为如果你的rightedge很大的话，说明很多区间是可能发生重叠的，所以才是这个道理</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightedge</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//和上一题不同哦，这里是计算去掉区间的个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; rightedge) &#123;<span class="comment">//现在数组的左区间小于右边界，说明有重叠，需要去掉</span></span><br><span class="line">                count++;</span><br><span class="line">                rightedge = Math.min(rightedge, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                rightedge = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="763-划分字母区间-medium-1"><a href="#763-划分字母区间-medium-1" class="headerlink" title="763 划分字母区间 medium"></a>763 划分字母区间 medium</h3><p>字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们需要输出的是每个片段的长度</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意是尽可能多的片段，然后相同字母都在一起，不然要最少片段，就不用分割了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法就是</span></span><br><span class="line"><span class="comment">1.统计每一个字符最后出现的位置</span></span><br><span class="line"><span class="comment">2.从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] edge = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();<span class="comment">//把字符串分割成一个个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            edge[chars[i] - <span class="string">&#x27;a&#x27;</span>] = i;<span class="comment">//不断更新该字符的最远距离，存进edge中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">//初始化-1是为了减的时候多加一个1，因为我们要返回个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//用来标记最远距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            index = Math.max(index, edge[chars[i] - <span class="string">&#x27;a&#x27;</span>]);<span class="comment">//获取该字符的最远距离，进入第二轮的话就是和上一个相比</span></span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;<span class="comment">//如果当前位置刚好就是这个距离，就说明找到分割点了</span></span><br><span class="line">                list.add(i - last);<span class="comment">//计算长度</span></span><br><span class="line">                last = i;<span class="comment">//更新last，准备下一次计算</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="56-合并区间-mediun"><a href="#56-合并区间-mediun" class="headerlink" title="56 合并区间 mediun"></a>56 合并区间 mediun</h3><p>这个题注意下返回的输出格式。注意[1,4],[4,5]也要合并的，变成[1,5]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, (a ,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftedge</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightedge</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; rightedge) &#123;<span class="comment">//左边区间大于的上一个数的右边界，说明可以把之前的边界合并在一起了</span></span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftedge, rightedge&#125;);</span><br><span class="line">                leftedge = intervals[i][<span class="number">0</span>];</span><br><span class="line">                rightedge = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//这个就是小于等于号的情况</span></span><br><span class="line">                rightedge = Math.max(intervals[i][<span class="number">1</span>], rightedge);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftedge, rightedge&#125;);<span class="comment">//上面的数循环完后，会漏掉最后一个区间的，所以最后加上</span></span><br><span class="line">        <span class="keyword">return</span> result.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[result.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面452,435,56题，需要好好理解什么时候是需要比较max的右边界的，而且上面三个题，都是左边区间排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">别忘了均是左边区间排序，从小到大，还有循环都是从<span class="number">1</span>开始</span><br><span class="line"></span><br><span class="line"><span class="number">452</span> </span><br><span class="line">在右边界内，也就是当前数组的左边区间小于右边界，说明重叠了，可以穿过同一只箭，不需要更新箭的数量，但是这时候要更新右边区间，要缩小右边区间的范围，所以要用min来对比</span><br><span class="line">反之如果大于这个右区间，就要增加箭的数量，然后更新右边界</span><br><span class="line"></span><br><span class="line"><span class="number">435</span></span><br><span class="line">去掉重叠的区间注意[<span class="number">1</span>,<span class="number">2</span>][<span class="number">2</span>,<span class="number">3</span>]不重叠</span><br><span class="line">在右边界内，也就是当前数组的左边区间小于右边界，说明需要去掉一个数组，count++，同时需要更新右边界min来比较，为什么要min呢，可以这么想，万一第一个的右边界很大，覆盖了全部数组，那必须得去掉啊</span><br><span class="line">如果不在边界，就直接更新右边界的值即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">56</span></span><br><span class="line">注意[<span class="number">4</span>,<span class="number">5</span>]，[<span class="number">5</span>,<span class="number">6</span>]也是需要合并的</span><br><span class="line">这个题要记录左右边界</span><br><span class="line">在右边界外，也就是当前数组的左边区间大于右边界，可以直接添加元素了，为什么不用小于等于呢（别忘了上面一行什么情况需要合并），其实也可以的，只是里面内容不一样而已，添加了元素后，要更新左右边界</span><br><span class="line">反正，只需要更新右边界，因为不确定下一个是不是还是重叠的，所以这里不添加元素，只是改变右边界</span><br><span class="line">循环完后，会漏掉最后一个区间的，所以最后加上</span><br><span class="line">这个题的的返回值要注意下</span><br></pre></td></tr></table></figure>
<h2 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>确定dp[i]的含义</span><br><span class="line"><span class="number">2.</span>确定递推公式（转移方程）</span><br><span class="line"><span class="number">3.</span>初始化dp数组</span><br><span class="line"><span class="number">4.</span>确定遍历顺序</span><br><span class="line"><span class="number">5.</span>举例推导dp数组</span><br></pre></td></tr></table></figure>
<h3 id="509-斐波那契数-easy"><a href="#509-斐波那契数-easy" class="headerlink" title="509 斐波那契数 easy"></a>509 斐波那契数 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i] 第i个数的斐波那契数</span><br><span class="line"><span class="number">2.</span>转移方程 dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line"><span class="number">3.</span>初始化dp[<span class="number">0</span>],dp[<span class="number">1</span>]</span><br><span class="line"><span class="number">4.</span>dp[i]依赖dp[i-<span class="number">1</span>]和dp[i-<span class="number">2</span>]，按照顺序遍历</span><br><span class="line"><span class="number">5.</span>自己推导一下<span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span></span><br><span class="line"></span><br><span class="line">这里注意一个点就是求dp[n]，也就是初始化数组的大小是n+<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n;  </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//这是需要注意理解题目的</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++ ) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="70-爬楼梯-easy-1"><a href="#70-爬楼梯-easy-1" class="headerlink" title="70 爬楼梯 easy"></a>70 爬楼梯 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">先理解题目，每次可以爬两级或者爬一级，也就是你可以在dp[i-<span class="number">2</span>]的级上爬两级，也可以在dp[i-<span class="number">1</span>]的级上爬一级，那么爬楼梯的方法就有dp[i-<span class="number">1</span>]加上dp[i-<span class="number">2</span>]</span><br><span class="line">本题不需要dp[<span class="number">0</span>]，因为这样没有意义，没有说爬<span class="number">0</span>级的楼梯，所以dp[<span class="number">1</span>]和dp[<span class="number">2</span>]需要初始化，由于是求dp[n]，所以数组的长度也就是需要n+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i]爬到第i层楼梯的方法数</span><br><span class="line"><span class="number">2.</span>根据我上面写的题意可以推出 dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]</span><br><span class="line"><span class="number">3.</span>第<span class="number">0</span>层没意义，但是会生成数组的时候会自动初始化<span class="number">0</span>，我们也不需要管，dp[<span class="number">1</span>]=<span class="number">1</span>,dp[<span class="number">2</span>]=<span class="number">2</span></span><br><span class="line"><span class="number">4.</span>dp[i]依赖dp[i-<span class="number">1</span>]和dp[i-<span class="number">2</span>]，按照顺序遍历</span><br><span class="line"><span class="number">5.</span>可以自己推导下前面几个，比如 <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n;  </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="746-使用最小花费爬楼梯-easy"><a href="#746-使用最小花费爬楼梯-easy" class="headerlink" title="746 使用最小花费爬楼梯 easy"></a>746 使用最小花费爬楼梯 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">这个题需要好好看看讲解哦，本题的要求是花费最小的体力值，然后首先看下面的例子理解下顶部是哪里！！！这个一开始我很懵，跟<span class="number">70</span>一样，也是一次可以跳<span class="number">1</span>级或者<span class="number">2</span>级</span><br><span class="line">例子<span class="number">1</span>：cost = [<span class="number">10</span>,<span class="number">15</span>-,<span class="number">20</span>]，支付 <span class="number">15</span> ，向上爬两个台阶，到达楼梯顶部，顶部这里是没有体现的，也就是跳到cost[<span class="number">2</span>]是一级，然后再跳到顶部是一级，一共两级</span><br><span class="line"></span><br><span class="line">这里-标记了跳的台阶</span><br><span class="line"></span><br><span class="line">例子<span class="number">2</span>：cost = [<span class="number">1</span>-,<span class="number">100</span>,<span class="number">1</span>-,<span class="number">1</span>,<span class="number">1</span>-,<span class="number">100</span>,<span class="number">1</span>-,<span class="number">1</span>-,<span class="number">100</span>,<span class="number">1</span>-],一共支付<span class="number">6</span>，从下标为<span class="number">0</span>的台阶开始</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">0</span>]，向上爬两个台阶，到达下标为 <span class="number">2</span> 的台阶。</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">2</span>]，向上爬两个台阶，到达下标为 <span class="number">4</span> 的台阶。</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">4</span>]，向上爬两个台阶，到达下标为 <span class="number">6</span> 的台阶。</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">6</span>]，向上爬一个台阶，到达下标为 <span class="number">7</span> 的台阶。</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">7</span>]，向上爬两个台阶，到达下标为 <span class="number">9</span> 的台阶。</span><br><span class="line">- 支付 <span class="number">1</span> cost[<span class="number">9</span>]，向上爬一个台阶，到达楼梯顶部。</span><br><span class="line"></span><br><span class="line">看到题目的例子后，需要注意，最后一个楼梯顶部，在数组中是没有体现他的位置的，也就是后移一个，其实不需要纠结这个问题</span><br><span class="line">因为你只要最后取数组倒数两个进行比较就行，哪个花费体力小就用哪个，这样他们都可以跳到楼顶</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i]到达第i个台阶需要花费的最少体力</span><br><span class="line"><span class="number">2.</span>因为我们需要花费最少的体力，然后可以跳<span class="number">1</span>级或者<span class="number">2</span>级，也就是 dp[i]=dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>]</span><br><span class="line"><span class="number">3.</span>初始化<span class="number">2</span>个就行，dp[<span class="number">0</span>]和dp[<span class="number">1</span>]</span><br><span class="line"><span class="number">4.</span>dp[i]依赖dp[i-<span class="number">1</span>]和dp[i-<span class="number">2</span>]，按照顺序遍历</span><br><span class="line"><span class="number">5.</span>推导一下cost = [<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>] 的dp数组是[<span class="number">1</span>,<span class="number">100</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">103</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">104</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">这里的转移方程详细说下，dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">这里为什么是cost[i]而不是cost[i-<span class="number">1</span>]或者cost[i-<span class="number">2</span>]</span><br><span class="line">因为我们想，我们现在是取到了前面两个比较小的值，然后本级需要跳，就要花费，先不考虑我们这个级跳<span class="number">1</span>级还是<span class="number">2</span>级的问题，因为我们先把整个dp数组弄出来，最后比较最后两个的值</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cost == <span class="literal">null</span> || cost.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cost.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cost[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[cost.length - <span class="number">2</span>], dp[cost.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">/*这部分可以不写，因为不存在这个范围的用例</span></span><br><span class="line"><span class="comment">        if (cost == null || cost.length == 0) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (cost.length == 1) &#123;</span></span><br><span class="line"><span class="comment">            return cost[0];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cost.length];</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; cost.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(dp[cost.length - <span class="number">2</span>], dp[cost.length - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="62-不同路径-medium"><a href="#62-不同路径-medium" class="headerlink" title="62 不同路径 medium"></a>62 不同路径 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i][j]代表到从（<span class="number">0</span> ，<span class="number">0</span>）出发，到(i, j) 有dp[i][j]条不同的路径。</span><br><span class="line"><span class="number">2.</span>题目说只能从右边还有下边走，所以只依赖两个方向的路径，dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]</span><br><span class="line"><span class="number">3.</span>dp初始化，第一行和第一列的坐标都是<span class="number">1</span>，因为只有一个方向走</span><br><span class="line"><span class="number">4.</span>遍历顺序就是从左到右</span><br><span class="line"><span class="number">5.</span>自己手动画下推导数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span> [m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-不同路径2-medium"><a href="#63-不同路径2-medium" class="headerlink" title="63 不同路径2 medium"></a>63 不同路径2 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">和上一题五部曲差不多，这里直说区别</span><br><span class="line"></span><br><span class="line">首先初始化问题</span><br><span class="line">初始化只在第一行和第一列，但是如果遇到障碍，需要<span class="keyword">break</span>，而不是<span class="keyword">continue</span>，这个的意思是，障碍后面的格子，都是<span class="number">0</span>了，但是如果你是<span class="keyword">continue</span>的话，只是单纯障碍这一格子是<span class="number">0</span>，但是后面是<span class="number">1</span></span><br><span class="line">而我们需要知道，你只要有障碍，后面都不能通过了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在具体递推公式的时候，遇到障碍则跳过，不是<span class="keyword">break</span>，因为你<span class="keyword">break</span>的话就全部结束了，而<span class="keyword">continue</span>只是跳过这个格子，这样这个格子就会为<span class="number">0</span>，在其他位置需要加他的时候，就是加<span class="number">0</span>。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="343-整数拆分-medium"><a href="#343-整数拆分-medium" class="headerlink" title="343 整数拆分 medium"></a>343 整数拆分 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这个题感觉没那么容易理解</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i] 分拆数字i，可以得到的最大乘积为dp[i]。</span><br><span class="line"><span class="number">2.</span>当i&gt;=<span class="number">2</span> 时，假设对正整数 i 拆分出的第一个正整数是 j（<span class="number">1</span>&lt;=j&lt;i），则有以下两种方案：<span class="number">1.</span>将 i拆分成j和i−j的和，且i−j 不再拆分成多个正整数，此时的乘积是j*(i-j)；<span class="number">2.</span>将 ii 拆分成 jj 和 i-ji−j 的和，且 i-ji−j 继续拆分成多个正整数，此时的乘积是j*dp[i-j]。</span><br><span class="line">上面其实不容易懂，需要这样理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘，因为题目要求可以至少拆分出<span class="number">2</span>个。</span><br><span class="line"><span class="number">3.</span>首先要清楚，dp[<span class="number">0</span>]和dp[<span class="number">1</span>]，因为<span class="number">0</span>无法拆分，<span class="number">1</span>也无法拆分，所以初始化要从<span class="number">2</span>开始，<span class="number">2</span>=<span class="number">1</span>+<span class="number">1</span>，然后<span class="number">1</span>*<span class="number">1</span>=<span class="number">1</span>，dp[<span class="number">2</span>]=<span class="number">1</span>，然后注意数组长度是n+<span class="number">1</span></span><br><span class="line"><span class="number">4.</span>遍历顺序也是第一次见，需要i和j，然后也是顺序遍历</span><br><span class="line"><span class="number">5.</span>自己可以手动推导，比如n=<span class="number">10</span>，dp数组是<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">18</span>,<span class="number">27</span>,<span class="number">36</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i - j; j++) &#123;<span class="comment">//这里j的范围需要注意是小于等于i-j</span></span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="96-不同的二叉搜索树-medium"><a href="#96-不同的二叉搜索树-medium" class="headerlink" title="96 不同的二叉搜索树 medium"></a>96 不同的二叉搜索树 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">这个题其实算困难了，尤其是递推关系，没做过压根不知道，可以看卡哥的图</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i] ： <span class="number">1</span>到i为节点组成的二叉搜索树的个数为dp[i]</span><br><span class="line"><span class="number">2.</span>递推公式</span><br><span class="line">元素<span class="number">1</span>为头结点搜索树的数量 = 右子树有<span class="number">2</span>个元素的搜索树数量 * 左子树有<span class="number">0</span>个元素的搜索树数量</span><br><span class="line">元素<span class="number">2</span>为头结点搜索树的数量 = 右子树有<span class="number">1</span>个元素的搜索树数量 * 左子树有<span class="number">1</span>个元素的搜索树数量</span><br><span class="line">元素<span class="number">3</span>为头结点搜索树的数量 = 右子树有<span class="number">0</span>个元素的搜索树数量 * 左子树有<span class="number">2</span>个元素的搜索树数量</span><br><span class="line">有<span class="number">2</span>个元素的搜索树数量就是dp[<span class="number">2</span>]</span><br><span class="line">有<span class="number">1</span>个元素的搜索树数量就是dp[<span class="number">1</span>]</span><br><span class="line">有<span class="number">0</span>个元素的搜索树数量就是dp[<span class="number">0</span>]</span><br><span class="line">所以dp[<span class="number">3</span>] = dp[<span class="number">2</span>] * dp[<span class="number">0</span>] + dp[<span class="number">1</span>] * dp[<span class="number">1</span>] + dp[<span class="number">0</span>] * dp[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">递推公式：dp[i] += dp[j - <span class="number">1</span>] * dp[i - j]</span><br><span class="line">这个不好记，可以看dp[<span class="number">3</span>]，第一个是dp[<span class="number">2</span>]*dp[<span class="number">0</span>]，i=<span class="number">3</span>，然后j是从<span class="number">1</span>开始，所以可以想到i-j,然后另外一个规律就是<span class="number">2</span>+<span class="number">0</span>=<span class="number">2</span>，前面<span class="number">3</span>-<span class="number">1</span>=<span class="number">0</span>，另外一个就是j-<span class="number">1</span>=<span class="number">0</span>，此时j=<span class="number">1</span>哦</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>dp[<span class="number">0</span>] = <span class="number">1</span>，dp[<span class="number">1</span>]=<span class="number">1</span>,<span class="number">1</span>的话好理解，但是<span class="number">0</span>的话不好理解，但是我们后面用到乘法，所以初始化为<span class="number">1</span>更好。</span><br><span class="line"><span class="number">4.</span>节点数为i的状态是依靠 i之前节点数的状态，从前往后即可</span><br><span class="line"><span class="number">5.</span>可以推导下</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;=n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] += dp[i - j] * dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="416-分割等和子集-medium"><a href="#416-分割等和子集-medium" class="headerlink" title="416 分割等和子集 medium"></a>416 分割等和子集 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>-<span class="number">1</span>背包问题</span><br><span class="line">nums里面可以看成物品，每个物品只能用一次，题目拆解后可以发现target是背包容量</span><br><span class="line"></span><br><span class="line">对于一维dp数组，务必先遍历物品，反正倒着遍历容量（因为每次元素不能重复使用），其次还要注意j&gt;=nums[i]，而不是<span class="number">0</span></span><br><span class="line"></span><br><span class="line">这里 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">max中的dp[j]可以理解为二维数组中的dp[i-<span class="number">1</span>]，因为如果用一维数组dp[i - <span class="number">1</span>]那一层拷贝到dp[i]上</span><br><span class="line"></span><br><span class="line">五部曲</span><br><span class="line"><span class="number">1.</span>dp[j]表示容量为j的背包，所背物品价值最高是dp[j]</span><br><span class="line"><span class="number">2.</span>dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);本题的物品，既是容量，也是价值</span><br><span class="line"><span class="number">3.</span>题目给的价值都是正整数的话，都可以初始化为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>遍历顺序：使用一维数组的话，物品遍历的<span class="keyword">for</span>循环放在外层，遍历背包的<span class="keyword">for</span>循环放在内层，且内层<span class="keyword">for</span>循环倒序遍历！</span><br><span class="line"><span class="number">5.</span>自己递推试试，注意本题的容量是target，所以数组的长度是target+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">这里有个细节就是，target可能不能被整除，所以先要判断能不能被<span class="number">2</span>取模</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//很细的细节</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target] == target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1049-最后一块石头的重量II-medium"><a href="#1049-最后一块石头的重量II-medium" class="headerlink" title="1049 最后一块石头的重量II medium"></a>1049 最后一块石头的重量II medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个题和上个题的区别是，上个题能不能正好装满，这个题是求最多能装多少</span><br><span class="line">其实一开始看这个题，有点懵，一直纠结一直拿两块石头应该怎么拿。</span><br><span class="line">看了分析后，其实这个题的本意是尽量让石头分成重量相同的两堆，这样相撞后的石头最小。同样，本题物品的重量为store[i]，物品的价值也为store[i]。</span><br><span class="line">也就是当我们把所有重量求和/<span class="number">2</span>，就可以求我们的dp数组，然后这个题不需要考虑sum能否被整除<span class="number">2</span>，因为本题说了是最多能装多少</span><br><span class="line">最后，我们理解下题目需要返回什么，按照上面的思路，其实石头被分成两堆，一堆是dp[target]，一堆是sum-dp[target],然后相减就是剩下石头的重量</span><br><span class="line"></span><br><span class="line">五部曲和上面一题一样</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : stones) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stones.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum -  <span class="number">2</span> * dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="494-目标和-medium"><a href="#494-目标和-medium" class="headerlink" title="494 目标和 medium"></a>494 目标和 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">涉及组合问题，而且这个题和其他背包问题不太一样，有点难度，下面详细讲下，本题也是<span class="number">0</span>-<span class="number">1</span>背包。</span><br><span class="line"></span><br><span class="line">首先理解一点是如何表达target</span><br><span class="line">我们可以计算出这个数组的总和sum，然后我们想想都是加号的数字和为a，都是减号的数字和为b，</span><br><span class="line">那么a-b就是sum，然后a+b就是target(这里和卡哥有点出入，我按照自己的理解去写，他是反过来的)</span><br><span class="line">b= a-sum </span><br><span class="line">a+a-sum=target</span><br><span class="line">a=(target+sum)/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">a即为bagsize</span><br><span class="line">这里需要考虑<span class="number">2</span>个问题，一个是target的绝对值如果大于sum，是不可能组成的，因为可能有这种案例</span><br><span class="line">第二个考虑就是(target+sum)%<span class="number">2</span>==<span class="number">1</span>的话，也是不行的，例如sum 是<span class="number">5</span>，target是<span class="number">2</span>的话其实就是无解的，根本无法组合出来，<span class="number">4</span>-<span class="number">1</span>=<span class="number">3</span>,<span class="number">3</span>-<span class="number">2</span>=<span class="number">1</span>，压根组合不到<span class="number">2</span>，也就是要求sum+target一定为偶数才行，至于为啥，还没想通。</span><br><span class="line"></span><br><span class="line">那么这里a就可以理解为背包容量，为什么呢，我们理解为组成加号和为a情况有多少种</span><br><span class="line">那么dp[a+<span class="number">1</span>]，这是dp数组长度</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">五部曲</span><br><span class="line"><span class="number">1.</span>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</span><br><span class="line"><span class="number">2.</span>这里的递推公式不一样！！！！其实也不算完全理解</span><br><span class="line">不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。</span><br><span class="line">那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。</span><br><span class="line">例如：dp[j]，j 为<span class="number">5</span></span><br><span class="line">已经有一个<span class="number">1</span>（nums[i]） 的话，有 dp[<span class="number">4</span>]种方法 凑成 dp[<span class="number">5</span>]。</span><br><span class="line">已经有一个<span class="number">2</span>（nums[i]） 的话，有 dp[<span class="number">3</span>]种方法 凑成 dp[<span class="number">5</span>]。</span><br><span class="line">已经有一个<span class="number">3</span>（nums[i]） 的话，有 dp[<span class="number">2</span>]中方法 凑成 dp[<span class="number">5</span>]。</span><br><span class="line">已经有一个<span class="number">4</span>（nums[i]） 的话，有 dp[<span class="number">1</span>]中方法 凑成 dp[<span class="number">5</span>]。</span><br><span class="line">已经有一个<span class="number">5</span> （nums[i]）的话，有 dp[<span class="number">0</span>]中方法 凑成 dp[<span class="number">5</span>]。</span><br><span class="line">那么凑整dp[<span class="number">5</span>]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</span><br><span class="line">这个是组合类问题，递推公式为：dp[j] += dp[j - nums[i]]</span><br><span class="line"><span class="number">3.</span>初始化</span><br><span class="line">这里必须要设置dp[<span class="number">0</span>]为<span class="number">1</span>，这个可以理解为容量为<span class="number">0</span>的背包，有一种方法，就是装<span class="number">0</span>件物品。但是如果初始化是<span class="number">0</span>后面无法推导。</span><br><span class="line"><span class="number">4.</span>遍历顺序，物品放外面（数组），容量放里面（bagsize）。</span><br><span class="line"><span class="number">5.</span>推导数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            sum += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(target) &gt; sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bagsize</span> <span class="operator">=</span> (sum + target) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagsize + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagsize; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[bagsize];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="474-零和一-medium"><a href="#474-零和一-medium" class="headerlink" title="474 零和一 medium"></a>474 零和一 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这个题 也没那么容易，本质也是<span class="number">0</span>-<span class="number">1</span>背包问题</span><br><span class="line"></span><br><span class="line">sts数组就是物品，然后这里很难理解的就是m和n，这里不能理解为多重背包，这里要理解为有两个维度的背包。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i][j]：最多有i个<span class="number">0</span>和j个<span class="number">1</span>的strs的最大子集的大小为dp[i][j]，也就是里面存的是大小</span><br><span class="line"><span class="number">2.</span>dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + <span class="number">1</span>);</span><br><span class="line"><span class="number">3.</span>初始化就是<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>遍历顺序，这个题有点不一样哦，里面是两个维度的容量，但是总体上还是物品在外面遍历，容量在里面遍历（倒着）</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str:strs) &#123;<span class="comment">//物品，也就是每个数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">onenum</span> <span class="operator">=</span> <span class="number">0</span>, zeronum = <span class="number">0</span>;<span class="comment">//每次都要重新计算数组的0和1的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    zeronum++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    onenum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//下面是容量，注意题目m是代表0，n是代表1，不需要搞错了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zeronum; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>  <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= onenum; j--) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - zeronum][j - onenum] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背包问题解析合集"><a href="#背包问题解析合集" class="headerlink" title="背包问题解析合集"></a>背包问题解析合集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">总结一下，<span class="number">0</span>-<span class="number">1</span>背包物品先，容量倒着来，完全背包物品先，容量顺着来</span><br><span class="line">组合问题物品先，容量顺着来，排列问题容量先从头来</span><br><span class="line"></span><br><span class="line">至于是写dp[j]还是dp[i]，是根据你把j和i定义成什么，其实都是dp[容量],也就是用容量的下标来表示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>   <span class="number">0</span>-<span class="number">1</span>背包</span><br><span class="line">表示物品只能拿一次，先遍历物品（顺序），再遍历容量（倒着，保证物品只被添加一次）</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">倒着的原因，这里举个例子</span><br><span class="line">    重量  价值</span><br><span class="line">物品<span class="number">0</span> <span class="number">1</span>   <span class="number">15</span></span><br><span class="line">物品<span class="number">1</span> <span class="number">3</span>   <span class="number">20</span></span><br><span class="line">物品<span class="number">2</span> <span class="number">4</span>   <span class="number">30</span></span><br><span class="line"></span><br><span class="line">如果是正序遍历</span><br><span class="line">dp[<span class="number">1</span>] = dp[<span class="number">1</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">15</span></span><br><span class="line">dp[<span class="number">2</span>] = dp[<span class="number">2</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line">我们可以看到dp[<span class="number">2</span>]这样是加了两次物品<span class="number">0</span>的重量</span><br><span class="line"></span><br><span class="line">但是如果是倒序遍历</span><br><span class="line">dp[<span class="number">2</span>] = dp[<span class="number">2</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">15</span> （dp数组已经都初始化为<span class="number">0</span>）</span><br><span class="line">dp[<span class="number">1</span>] = dp[<span class="number">1</span> - weight[<span class="number">0</span>]] + value[<span class="number">0</span>] = <span class="number">15</span></span><br><span class="line"></span><br><span class="line">最后再次说明dp[j]的意思是容量为j的背包，所背的物品价值可以最大为dp[j]。</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>   完全背包</span><br><span class="line">表示物品可以添加多次，先遍历物品（顺序），再遍历容量（顺序，可以添加多次）</span><br><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量，顺序遍历，顺序遍历</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">另外说一些额外的：</span><br><span class="line"><span class="number">01</span>背包中二维dp数组的两个<span class="keyword">for</span>遍历的先后循序是可以颠倒了，一维dp数组的两个<span class="keyword">for</span>循环先后循序一定是先遍历物品，再遍历背包容量。</span><br><span class="line">完全背包中，对于一维dp数组来说，其实两个<span class="keyword">for</span>循环嵌套顺序同样无所谓！但是代码还是有点不一样，这里就看个参考，不要记了</span><br><span class="line"><span class="comment">// 先遍历背包，再遍历物品</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= bagWeight; j++) &#123; <span class="comment">// 遍历背包容量，别忘了，这里是j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - weight[i] &gt;= <span class="number">0</span>) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>   组合数和排列数问题，组合不强调元素之间的顺序（也就是[<span class="number">1</span>,<span class="number">5</span>]和[<span class="number">5</span>,<span class="number">1</span>]是一回事），排列强调元素之间的顺序，初始化dp[<span class="number">0</span>]为<span class="number">1</span>，至于为什么，没有原因。</span><br><span class="line"><span class="number">494</span>是组合问题，初始化dp[<span class="number">0</span>]为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">组合代码，和完全背包一样，都是先遍历物品，再遍历容量</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">排列代码 ，这个不一样哦，先遍历容量，再遍历，而且背包遍历容量，是从<span class="number">0</span>开始的，注意背包</span><br><span class="line">如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[<span class="number">4</span>]的时候，结果集只有 &#123;<span class="number">1</span>,<span class="number">3</span>&#125; 这样的集合，不会有&#123;<span class="number">3</span>,<span class="number">1</span>&#125;这样的集合，因为nums遍历放在外层，<span class="number">3</span>只能出现在<span class="number">1</span>后面！</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];<span class="comment">//注意要有背包容量大于等于coins[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="377-组合总和Ⅳ-medium"><a href="#377-组合总和Ⅳ-medium" class="headerlink" title="377 组合总和Ⅳ medium"></a>377 组合总和Ⅳ medium</h3><p>这个其实是排列+完全背包问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i]: 凑成目标正整数为i的排列个数为dp[i]</span><br><span class="line"><span class="number">2.</span>求排列 dp[i] += dp[i - nums[j]];</span><br><span class="line"><span class="number">3.</span>dp[<span class="number">0</span>] = <span class="number">1</span>，组合排列都是这样初始化，其他位置为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>外层<span class="keyword">for</span>遍历背包，内层<span class="keyword">for</span>循环遍历物品，且注意背包容量要大于物品，不然会越界</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp =<span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= target; j++) &#123;<span class="comment">//容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//物品</span></span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - nums[i]]; <span class="comment">//且注意背包容量要大于物品，不然会越界</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="518-零钱兑换II-medium"><a href="#518-零钱兑换II-medium" class="headerlink" title="518 零钱兑换II medium"></a>518 零钱兑换II medium</h3><p>完全背包+组合，注意这里是求凑成总金额的硬币组合数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[j]：凑成总金额j的货币组合数为dp[j]</span><br><span class="line"><span class="number">2.</span>组合数，dp[j] += dp[j - coins[i]]</span><br><span class="line"><span class="number">3.</span>dp[<span class="number">0</span>] = <span class="number">1</span>，组合排列都是这样初始化，其他位置为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>顺序遍历物品（金币），顺序遍历容量（钱总额）</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;<span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class="comment">//容量</span></span><br><span class="line">                dp[j] += dp[j - coins[i]]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="322-零钱兑换-medium"><a href="#322-零钱兑换-medium" class="headerlink" title="322 零钱兑换 medium"></a>322 零钱兑换 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">和上题的区别</span><br><span class="line">本题求的是硬币的最小个数，最小的话，有顺序和没有顺序都可以，也就是排列组合都没有关系，但是符合完全背包（钱币可以无限用）</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[j]：凑足总额为j所需钱币的最少个数为dp[j]</span><br><span class="line"><span class="number">2.</span>递推公式：dp[j] = min(dp[j - coins[i]] + <span class="number">1</span>, dp[j]);，其实这里我还没理解为啥加<span class="number">1</span></span><br><span class="line"><span class="number">3.</span>首先凑足总金额为<span class="number">0</span>所需钱币的个数一定是<span class="number">0</span>，那么dp[<span class="number">0</span>] = <span class="number">0</span>;其次其他下标需要为最大值</span><br><span class="line"><span class="number">4.</span>完全背包，先遍历顺序物品，然后顺序遍历容量</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;<span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++) &#123;<span class="comment">//容量</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != Integer.MAX_VALUE) <span class="comment">// 如果dp[j - coins[i]]是初始值则跳过</span></span><br><span class="line">                    &#123;dp[j] = Math.min(dp[j],dp[j - coins[i]] + <span class="number">1</span>);&#125;<span class="comment">//看了别人的解释，金额为11的最小硬币数 和 金额为(11-一个面值)的最小硬币数+1 比较最小值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];<span class="comment">//因为可能不能组合成功，那么就返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全背包也可以先写容量，再写物品，但是要多加一个判断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= amount; j++) &#123;<span class="comment">//其实j从0开始也行的，但是我们之前声明了dp[0]，所以没意义，直接从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span> &amp;&amp; dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="279-完全平方数-medium-1"><a href="#279-完全平方数-medium-1" class="headerlink" title="279 完全平方数 medium"></a>279 完全平方数 medium</h3><p>和前面一题差不多，这里把完全平方数看做物品。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= j; i++) &#123;<span class="comment">//物品，平方数是0没有意义，而且写0也会错的，自己推导一下就知道，这里直接是用i，而不是像数组那样</span></span><br><span class="line">                <span class="comment">/*if (j - i * i &gt;= 0)  加上这句也是可以的*/</span> dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * i &lt;= n; i++) &#123;<span class="comment">//物品</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;<span class="comment">//容量</span></span><br><span class="line">                <span class="keyword">if</span> (j - i * i &gt;= <span class="number">0</span>) dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);<span class="comment">//这里和之前总结的东西有点区别，为什么这里要if判断，有个原因就是这里是直接用i本身，而不是用数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="139-单词拆分-medium-1"><a href="#139-单词拆分-medium-1" class="headerlink" title="139 单词拆分 medium"></a>139 单词拆分 medium</h3><p>这道题类似于完全平方数分割。单词就是物品，字符串s就是背包，完全背包问题，求能否组成背包，因为分割子串的特殊性，遍历背包放在外循环，将遍历物品放在内循环更方便一些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*跟下面的解法一样的，只是习惯了j代表背包容量而已*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];<span class="comment">//默认都是false的</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">//dp[0]表示如果字符串为空的话，说明出现在字典里。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= s.length(); j++) &#123;<span class="comment">//容量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++) &#123;<span class="comment">//物品</span></span><br><span class="line">                <span class="keyword">if</span> (wordDict.contains(s.substring(i, j)) &amp;&amp; dp[i] == <span class="literal">true</span>) &#123;<span class="comment">//(j,i)，注意是j开始，这里表示起始位置，左开右闭，dp[j]==true表示字符串长度为j的话，可以拆分为一个或者多个在字典中出现的单词，也就是之前的单词都是能拆的，然后如果后面也能拆，再把dp[i]置为true</span></span><br><span class="line">                    dp[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];<span class="comment">//默认都是false的</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;<span class="comment">//dp[0]表示如果字符串为空的话，说明出现在字典里。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//容量</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;<span class="comment">//物品</span></span><br><span class="line">                <span class="keyword">if</span>(wordDict.contains(s.substring(j,i)) &amp;&amp; dp[j] == <span class="literal">true</span>) &#123; <span class="comment">//(j,i)，注意是j开始，这里表示起始位置，左开右闭，dp[j]==true表示字符串长度为j的话，可以拆分为一个或者多个在字典中出现的单词，也就是之前的单词都是能拆的，然后如果后面也能拆，再把dp[i]置为true</span></span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">卡哥将得很详细，复制一下记录</span><br><span class="line">单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。substring(start,end)是左开右闭。</span><br><span class="line"></span><br><span class="line">拆分时可以重复使用字典中的单词，说明就是一个完全背包！</span><br><span class="line"></span><br><span class="line">动规五部曲分析如下：</span><br><span class="line"></span><br><span class="line">1.确定dp数组以及下标的含义</span><br><span class="line">dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">2.确定递推公式</span><br><span class="line">如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j &lt; i）。</span><br><span class="line"></span><br><span class="line">所以递推公式是 if([j, i] 这个区间的子串出现在字典里 &amp;&amp; dp[j]是true) 那么 dp[i] = true。</span><br><span class="line"></span><br><span class="line">3.dp数组如何初始化</span><br><span class="line">从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</span><br><span class="line"></span><br><span class="line">那么dp[0]有没有意义呢？</span><br><span class="line"></span><br><span class="line">dp[0]表示如果字符串为空的话，说明出现在字典里。</span><br><span class="line"></span><br><span class="line">但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。</span><br><span class="line"></span><br><span class="line">下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。</span><br><span class="line"></span><br><span class="line">4.确定遍历顺序</span><br><span class="line">题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。</span><br><span class="line"></span><br><span class="line">还要讨论两层for循环的前后循序。</span><br><span class="line"></span><br><span class="line">如果求组合数就是外层for循环遍历物品，内层for遍历背包。</span><br><span class="line"></span><br><span class="line">如果求排列数就是外层for遍历背包，内层for循环遍历物品。</span><br><span class="line"></span><br><span class="line">本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！</span><br><span class="line"></span><br><span class="line">那么本题使用求排列的方式，还是求组合的方式都可以。</span><br><span class="line"></span><br><span class="line">即：外层for循环遍历物品，内层for遍历背包 或者 外层for遍历背包，内层for循环遍历物品 都是可以的。</span><br><span class="line"></span><br><span class="line">但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。</span><br><span class="line"></span><br><span class="line">如果要是外层for循环遍历物品，内层for遍历背包，就需要把所有的子串都预先放在一个容器里。（如果不理解的话，可以自己尝试这么写一写就理解了）</span><br><span class="line"></span><br><span class="line">所以最终我选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环。内循环从前到后。</span><br><span class="line"></span><br><span class="line">5.举例推导dp[i]</span><br><span class="line">以输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]为例，dp状态如图：</span><br><span class="line">（在下方）</span><br><span class="line">dp[s.size()]就是最终结果。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ps:</span><br><span class="line">五部曲中第一部是最困难的. 一般都是遵循&quot;题目问什么, 就把`dp[]设置成什么</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者：carlsun-2</span><br><span class="line">链接：https://leetcode.cn/problems/word-break/solution/dai-ma-sui-xiang-lu-139-dan-ci-chai-fen-50a1a/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/139.jpg"></p>
<h3 id="198-打家劫舍-medium-1"><a href="#198-打家劫舍-medium-1" class="headerlink" title="198 打家劫舍 medium"></a>198 打家劫舍 medium</h3><p>居然一开始和背包问题联系起来了，其实不是一回事啊！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i]表示考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]。</span><br><span class="line"><span class="number">2.</span>确定递推公式，决定dp[i]的因素就是第i房间偷还是不偷。偷第i间房子，那么dp[i] = dp[i-<span class="number">2</span>]+nums[i]，因为不能导致报警，如果不偷第i间房子，dp[i]=dp[i-<span class="number">1</span>]，这里不是表明要偷i-<span class="number">1</span>房哦，要牢记dp[i]的概念，i以内的房间，所以dp[i] = max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line"><span class="number">3.</span>从递推公式可以看出，要初始化dp[<span class="number">0</span>]和dp[<span class="number">1</span>]，这里注意dp[<span class="number">1</span>]是要求最大值哦，不是单纯赋值nums[<span class="number">1</span>]</span><br><span class="line"><span class="number">4.</span>确定遍历顺序，从前到后</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[<span class="number">1</span>], nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="213-打家劫舍2-medium"><a href="#213-打家劫舍2-medium" class="headerlink" title="213 打家劫舍2 medium"></a>213 打家劫舍2 medium</h3><p>和上一题的区别是，上一题的房子都是在一条街道，而本题的房子，是围成一圈，第一间和最后一间挨着。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没做过的话，确实不好想</span><br><span class="line">其实就是分成两部分，一部分不包含最后一个元素，一部分不包含第一个元素，然后比较他们的最大值</span><br><span class="line">其余的和上一题一样。</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(robRange(nums, <span class="number">0</span> , end - <span class="number">1</span>), robRange(nums, <span class="number">1</span>, end));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];<span class="comment">//如果不写这句，遇到[0,0]会出错，因为这时候传进来的start和end都是相等的</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span> [nums.length];</span><br><span class="line">        dp[start] = nums[start];<span class="comment">//主体的逻辑也要根据start和end来写哦</span></span><br><span class="line">        dp[start + <span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;<span class="comment">//注意小于等于end</span></span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];<span class="comment">//注意返回的是end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="337-打家劫设3-medium"><a href="#337-打家劫设3-medium" class="headerlink" title="337 打家劫设3 medium"></a>337 打家劫设3 medium</h3><p>这题用上了二叉树了，树形dp是第一次遇到！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先要用后序遍历，因为通过递归函数的返回值来做下一步计算。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>用长度为<span class="number">2</span>的大小数组来保存，dp[<span class="number">0</span>]表示不偷当前节点所获得的最大金钱，dp[<span class="number">1</span>]表示偷当前节点所获得的最大金钱。</span><br><span class="line"><span class="number">2.</span>到了这里不是递推公式了，而是初始化，<span class="keyword">if</span> (cur == NULL) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;，相当于初始化</span><br><span class="line"><span class="number">3.</span>确定遍历顺序，通过递归左节点，得到左节点偷与不偷的金钱。通过递归右节点，得到右节点偷与不偷的金钱。</span><br><span class="line"><span class="number">4.</span>确定单层递归的逻辑，如果是偷当前节点，那么左右孩子就不能偷，如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，因为只要不挨着就行，所以不一定要偷的</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] res = dfs(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dfs(TreeNode root) &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] left = dfs(root.left);<span class="comment">//左孩子</span></span><br><span class="line">        <span class="type">int</span>[] right = dfs(root.right);<span class="comment">//右孩子</span></span><br><span class="line">        </span><br><span class="line">        res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]);<span class="comment">//不偷当前节点的话，左右孩子可以偷，也可以不偷，关键在于取最大</span></span><br><span class="line">        res[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];<span class="comment">//偷当前节点，那么左右孩子都不能偷，0代表不偷，left和right代表左右孩子</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="121-买卖股票的最佳时机-easy-1"><a href="#121-买卖股票的最佳时机-easy-1" class="headerlink" title="121 买卖股票的最佳时机 easy"></a>121 买卖股票的最佳时机 easy</h3><p>只买卖一次！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">需要强化一个概念，持有不代表今天买，不持有不代表今天卖，可能是维持前一天的状态！！！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i][<span class="number">0</span>]代表第i天持有股票的最多现金，dp[i][<span class="number">1</span>]代表第i天不持有股票股票所得最多现金，注意注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态，也就是第二维的<span class="number">0</span>和<span class="number">1</span>代表持有和不持有，第一维只代表天</span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">第i天持有股票即dp[i][<span class="number">0</span>]</span><br><span class="line">持有表示可能之前就买了，那么就保持上一天的状态呗，也就是等于dp[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">也可能表示今天买了，那么就是-price[i]</span><br><span class="line">所以dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line"></span><br><span class="line">第i天不持有股票即dp[i][<span class="number">1</span>]</span><br><span class="line">不持有表示之前早就卖了，那就维持前一天的状态，dp[i-<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">也可能今天卖了，那就是dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i],也就是前一天还是持有的状态，然后今天卖了，其实前一天的价格是负数，因为你持有了，加上今天的价格，就是利润</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], prices[i] + dp[i - <span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>从递推公式可以看到，需要依赖dp[<span class="number">0</span>][<span class="number">0</span>]和dp[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">4.</span>遍历顺序，从前往后</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">//0代表持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//1代表卖出，初始化不持有就表示现金为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];<span class="comment">//用第二个维度的1是因为，本题不持有股票状态所得金钱一定比持有股票状态得到的多！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心算法，找最左最小值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span>  Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            low = Math.min(low, prices[i]);<span class="comment">//找最左最小值</span></span><br><span class="line">            result = Math.max(result, prices[i] - low);<span class="comment">//取最大利润</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机2-medium"><a href="#122-买卖股票的最佳时机2-medium" class="headerlink" title="122 买卖股票的最佳时机2 medium"></a>122 买卖股票的最佳时机2 medium</h3><p>和上一题的区别是，这个题可以每天进行买卖，也就是可以多次买卖。最多只能持有一股股票，也可以先购买，然后在同一天出售。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">0</span>]);<span class="comment">//唯一的区别，如果是第i天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            result += Math.max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);<span class="comment">//把每次正利润都累加，所以这里用一个0来比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="123-买卖股票最佳时机3-hard"><a href="#123-买卖股票最佳时机3-hard" class="headerlink" title="123 买卖股票最佳时机3 hard"></a>123 买卖股票最佳时机3 hard</h3><p>限制了最多可以完成两笔交易！也就是买卖一次，可以买卖两次，也可以不买卖。这题难不少！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">这题和之前的状态不一样，之前的第二个维度，<span class="number">0</span>代表持有，<span class="number">1</span>代表不持有</span><br><span class="line"><span class="number">1.</span>确定下标含义</span><br><span class="line"></span><br><span class="line">而本题只能最多买卖<span class="number">2</span>次，那么可以设置<span class="number">5</span>个状态，也是第二个维度来表示</span><br><span class="line"><span class="number">0</span>代表不操作</span><br><span class="line"><span class="number">1</span>代表第一次持有</span><br><span class="line"><span class="number">2</span>代表第一次不持有</span><br><span class="line"><span class="number">3</span>代表第二次持有</span><br><span class="line"><span class="number">4</span>代表第二次不持有</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>递推公式</span><br><span class="line">以dp[i][<span class="number">1</span>]为例</span><br><span class="line">操作一：第i天买入股票了，那么dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] - prices[i]，注意这里是前一天的<span class="number">0</span></span><br><span class="line">操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">取他们最大</span><br><span class="line"></span><br><span class="line">其他一样递推</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span></span><br><span class="line">只需要初始化买入状态，即便第二次买入可能要考虑第一次买入</span><br><span class="line">总之 dp[<span class="number">0</span>][<span class="number">1</span>],dp[<span class="number">0</span>][<span class="number">3</span>] = -price[<span class="number">0</span>]</span><br><span class="line"><span class="number">4.</span>遍历顺序就是从左到右</span><br><span class="line"><span class="number">5.</span>推导</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//0没有操作，1第一次持有，2第一次不持有，3第二次持有，4第二次不持有</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">5</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];<span class="comment">//不写也能通过</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">4</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="188-买卖股票最佳时机4-hard"><a href="#188-买卖股票最佳时机4-hard" class="headerlink" title="188 买卖股票最佳时机4 hard"></a>188 买卖股票最佳时机4 hard</h3><p>最多可以完成k笔交易，和上一题没啥区别，就是k次而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//唯一区别，为了满足测试用例</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span> * k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span> * k + <span class="number">1</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = -prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">2</span> * k + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + (<span class="type">int</span>)Math.pow(-<span class="number">1</span>,j) * prices[i]);<span class="comment">//注意int</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="309-最佳买卖股票时机含冷冻期-medium-1"><a href="#309-最佳买卖股票时机含冷冻期-medium-1" class="headerlink" title="309 最佳买卖股票时机含冷冻期 medium"></a>309 最佳买卖股票时机含冷冻期 medium</h3><p>比122多了一个冷冻期，支持多次交易，但是也不会太容易</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">关键在于有一个冷冻期，那么本题设置<span class="number">4</span>种状态</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>持有（可能是保持前一天的持有状态，可能是今天买入）</span><br><span class="line"><span class="number">2.</span>不持有（这个不一样，反正今天不能卖！），两天前就卖出了股票，度过了冷冻期，一直没操作，今天保持卖出股票状态</span><br><span class="line"><span class="number">3.</span>卖出（也就是把之前股票问题的不持有状态拆成两个状态，一个不持有，一个卖出，等下讲解）</span><br><span class="line"><span class="number">4.</span>冷冻期，只有一天</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>递推公式</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>持有状态下</span><br><span class="line"><span class="number">1.1</span> 保持前一天的持有状态</span><br><span class="line"><span class="number">1.2</span> 昨天是冷冻期，今天买入</span><br><span class="line"><span class="number">1.3</span> 之前早就卖出股票并且度过了冷冻期，今天可以买入</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>不持有状态下</span><br><span class="line"><span class="number">2.1</span> 保持前一天的不持有的状态</span><br><span class="line"><span class="number">2.2</span> 冷冻期（这个不容易想到，因为冷冻期代表你已经卖了股票了，你可以保持这个状态表示不持有）</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>卖出</span><br><span class="line"><span class="number">3.1</span> 前一天持有了才能卖出</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>冷冻期</span><br><span class="line"><span class="number">4.1</span> 前一天卖出就会触发冷冻期</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化</span><br><span class="line">只需要设置持有状态下就可以，其他均为<span class="number">0</span>，也就是dp[<span class="number">0</span>][<span class="number">0</span>] = -price[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>遍历顺序就是从前到后</span><br><span class="line"><span class="number">5.</span>推导</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>] - prices[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]));</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>]; </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">1</span>], Math.max(dp[prices.length - <span class="number">1</span>][<span class="number">2</span>], dp[prices.length - <span class="number">1</span>][<span class="number">3</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="714-买卖股票的最佳时机含手续费-medium"><a href="#714-买卖股票的最佳时机含手续费-medium" class="headerlink" title="714 买卖股票的最佳时机含手续费 medium"></a>714 买卖股票的最佳时机含手续费 medium</h3><p>也是无限次交易，只是多了一个手续费，参考122就行啦，多一个手续费。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="300-最长递增子序列-medium-1"><a href="#300-最长递增子序列-medium-1" class="headerlink" title="300 最长递增子序列 medium"></a>300 最长递增子序列 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度</span><br><span class="line"><span class="number">2.</span>位置i的最长升序子序列等于j从<span class="number">0</span>到i-<span class="number">1</span>各个位置的最长升序子序列 + <span class="number">1</span> 的最大值。所以要用双重循环</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">这里注意j是大小是从<span class="number">0</span>到i(不包含i)，我们需要取dp[j] + <span class="number">1</span>的最大值</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化，这里和之前的dp问题有些不一样，每一个i的长度至少都是可以为<span class="number">1</span>，所以全部先设置为<span class="number">1</span></span><br><span class="line"><span class="number">4.</span>顺序遍历</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>];<span class="comment">//不能设置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                    result = Math.max(result, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//本题不能直接用一维数组最后一个位置的值来返回，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="674-最长连续递增序列-easy"><a href="#674-最长连续递增序列-easy" class="headerlink" title="674 最长连续递增序列 easy"></a>674 最长连续递增序列 easy</h3><p>和上一题的区别是，本题要求连续，上一题的话可以隔开元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]。</span><br><span class="line"><span class="number">2.</span><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>);因为要连续，所以需要比较上一个，而不是像上一题一样从<span class="number">0</span>到j去找</span><br><span class="line"><span class="number">3.</span>初始化，也是全部初试化为<span class="number">1</span>，因为每个i</span><br><span class="line"><span class="number">4.</span>确定遍历顺序，就是从前到后</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>];<span class="comment">//不能设置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//注意没有max，要理解上题为什么有max</span></span><br><span class="line">                result = Math.max(dp[i], result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//本题不能直接用一维数组最后一个位置的值来返回，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="718-最长重复子数组-medium"><a href="#718-最长重复子数组-medium" class="headerlink" title="718 最长重复子数组 medium"></a>718 最长重复子数组 medium</h3><p>也是连续子序列问题，但是这里是两个数组的对比</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">本题的含义不一样！！！注意看！！！本题的含义不一样！！！注意看！！！本题的含义不一样！！！注意看！！！</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i][j] ：以下标i-<span class="number">1</span>为结尾的A（指第一个数组），和以下标j-<span class="number">1</span>为结尾的B（指第二个数组），最长重复子数组长度为dp[i][j]。 （特别注意： “以下标i-<span class="number">1</span>为结尾的A（指第一个数组）” 标明一定是 以A[i-<span class="number">1</span>]为结尾的字符串 ）</span><br><span class="line">以前都是下标i，但是本题是下标i-<span class="number">1</span>，我是这么觉得的，因为比较的时候，从<span class="number">0</span>开始的话，往前面推是-<span class="number">1</span>，因为这里涉及两个数组，不方便，而且我们回过头去看之前的dp问题，也是有i-<span class="number">1</span>的元素在的，而本题是同时比较两个数组</span><br><span class="line"><span class="number">2.</span>当A[i - <span class="number">1</span>] 和B[j - <span class="number">1</span>]相等的时候，dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="number">3.</span>初始化，<span class="number">0</span>即可，dp[i][<span class="number">0</span>] 和dp[<span class="number">0</span>][j]初始化为<span class="number">0</span>，java的话本来就默认<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>循环遍历，从前到后，第一组先，然后再第二组</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];<span class="comment">//注意两个数组可能大小是不一样的！！！！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//方便在遍历的时候就找到最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;<span class="comment">//没有max比较</span></span><br><span class="line">                    result = Math.max(result, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//本题不能直接用二维数组最后一个位置的值来返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1143-最长公共子序列-medium-1"><a href="#1143-最长公共子序列-medium-1" class="headerlink" title="1143 最长公共子序列 medium"></a>1143 最长公共子序列 medium</h3><p>连续的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i][j]：长度为[<span class="number">0</span>, i - <span class="number">1</span>]的字符串text1与长度为[<span class="number">0</span>, j - <span class="number">1</span>]的字符串text2的最长公共子序列长度为 dp[i][j]</span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">text1[i-<span class="number">1</span>] 与 text2[j-<span class="number">1</span>]相同情况下</span><br><span class="line">如果text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">text1[i-<span class="number">1</span>] 与 text2[j-<span class="number">1</span>]不相同情况下(重点理解这里，不是太好理解)</span><br><span class="line">如果text1[i - <span class="number">1</span>] 与 text2[j - <span class="number">1</span>]不相同，那就看看text1[<span class="number">0</span>, i - <span class="number">2</span>]与text2[<span class="number">0</span>, j - <span class="number">1</span>]的最长公共子序列 和 text1[<span class="number">0</span>, i - <span class="number">1</span>]与text2[<span class="number">0</span>, j - <span class="number">2</span>]的最长公共子序列，取最大的。</span><br><span class="line">dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>统一初始化为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>从前到后遍历</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);<span class="comment">//这个不容易理解</span></span><br><span class="line">                &#125;</span><br><span class="line">                result =Math.max(dp[i][j], result);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//其实本题是可以直接返回dp[text1.length()][text2.length()]，不需要result也可以。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长序列问题总结"><a href="#最长序列问题总结" class="headerlink" title="最长序列问题总结"></a>最长序列问题总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">总体分为几种情况的组合，单数组和双数组，连续或者子序</span><br><span class="line"><span class="number">1.</span>定义</span><br><span class="line">如果是单数组，就直接定义一维的，直接按照<span class="number">0</span>~i-<span class="number">1</span>的位置来即可，定义长度就是数组长度，但是如果是双数组，用i-<span class="number">1</span>代表dp[i][j]更好，也就是长度需要加<span class="number">1</span>，同时双数组就定义两个维度。</span><br><span class="line"><span class="number">2.</span>状态转移方程需要根据题目意思来</span><br><span class="line"><span class="number">3.</span>确定初始化，对于单数组，都是比较自己，因为单独一个元素就是一个长度序列，所以应该全部初始化为<span class="number">1</span>，但是对于双数组，则需要比较，所以在比较的情况下再确定长度，也就是初始化为<span class="number">0</span>即可。</span><br><span class="line"><span class="number">4.</span>从前到后遍历</span><br><span class="line"><span class="number">5.</span>推导数组</span><br><span class="line"></span><br><span class="line">另外说几点，对于求连续的，不需要max来比较，直接前一个位置+<span class="number">1</span>就行</span><br><span class="line">但是对于子序，需要考虑前面的所有情况</span><br><span class="line"></span><br><span class="line">另外说下关于返回值的问题，以前我们的dp问题，都能用数组的最后一个位置的值返回，但是本系列只有<span class="number">1143</span>可以这么做</span><br><span class="line">我的理解是这样的，最重要是看dp的定义</span><br><span class="line"><span class="number">300</span>：i之前包括i的以nums[i]结尾最长上升子序列的长度，以他为结尾，意味着他要包含进去，但是包含他的，不一定是最长的长度，所以要不断找最大值</span><br><span class="line"><span class="number">674</span>：以下标i为结尾的数组的连续递增的子序列长度为dp[i]，也是和上面一样的意思去判断</span><br><span class="line"><span class="number">718</span>：以下标i-<span class="number">1</span>为结尾的A，和以下标j-<span class="number">1</span>为结尾的B，最长重复子数组长度为dp[i][j]，也是和上面一样</span><br><span class="line">所以上面三个题，都需要来比较来找到最大值</span><br><span class="line"><span class="number">1143</span>：长度为[<span class="number">0</span>,i-<span class="number">1</span>]的字符串text1与长度为[<span class="number">0</span>,j-<span class="number">1</span>]的字符串text2的最长公共子序列长度为dp[i][j]</span><br><span class="line"></span><br><span class="line">当然了，其实我是在知道定义后写的，至于<span class="number">1143</span>为什么不是以结尾来定义，还没弄明白，如果觉得不好记，统一用max比较也可以</span><br></pre></td></tr></table></figure>
<h3 id="1035-不相交的线-medium"><a href="#1035-不相交的线-medium" class="headerlink" title="1035 不相交的线 medium"></a>1035 不相交的线 medium</h3><p>需要拆解为，两个字符串的最长公共子序列的长度！也就是和上一题一毛一样！ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="53-最大子数组和-medium-1"><a href="#53-最大子数组和-medium-1" class="headerlink" title="53 最大子数组和 medium"></a>53 最大子数组和 medium</h3><p>这个题是连续部分，不是子序，这个题一开始还有点懵，需要理解一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i]：包括下标i之前的最大连续子序列和为dp[i]。</span><br><span class="line"><span class="number">2.</span>两个方向来推：<span class="number">2.1</span> dp[i-<span class="number">1</span>]+nums[i]，即：nums[i] <span class="number">2.2</span>加入当前连续子序列和nums[i]，即：从头开始计算当前连续子序列和</span><br><span class="line"><span class="number">3.</span>初始化为<span class="number">0</span></span><br><span class="line"><span class="number">4.</span>从前到后遍历</span><br><span class="line"><span class="number">5.</span>推导</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);</span><br><span class="line">            sum = Math.max(sum, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="392-判断子序列-medium"><a href="#392-判断子序列-medium" class="headerlink" title="392 判断子序列 medium"></a>392 判断子序列 medium</h3><p>和1143,1035差不多，但是本题注意是s是否t的子序列，也就是最长子序列长度必须要为s的长度才可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                max = Math.max(max, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="115-不同的子序列-hard"><a href="#115-不同的子序列-hard" class="headerlink" title="115 不同的子序列 hard"></a>115 不同的子序列 hard</h3><p>这个题真的超级难懂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1143</span>是找最长公共子序列</span><br><span class="line">而本题是字符串s有很多个子序列(不一定连续)，这些子序列字符串中，字符串t出现了多少次？</span><br><span class="line">也就是计算在 s 的子序列中 t 出现的个数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i][j]：以i-<span class="number">1</span>为结尾的s子序列中出现以j-<span class="number">1</span>为结尾的t的个数为dp[i][j]。</span><br><span class="line"><span class="number">2.</span>递推顺序（https:<span class="comment">//leetcode.cn/problems/distinct-subsequences/solution/tu-jie-dong-tai-gui-hua-by-cyingenohalt-nnlc/）</span></span><br><span class="line">第一种情况s[i-<span class="number">1</span>]与t[j-<span class="number">1</span>]不相等</span><br><span class="line">第一种解释：我们发现当sub_s新增了一个长度后，如果新增的字符（当前sub_s尾字符），与sub_t尾字符不匹配，那么似乎在sub_s上多了个<span class="string">&quot;没用&quot;</span>的字符，sub_s所有子序列字符串中sub_t出现的次数没有任何变化。因此在这种状态下：dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">第二种解释：s[i−<span class="number">1</span>]不能和t[j−<span class="number">1</span>] 匹配，因此只考虑t[j-<span class="number">1</span>]作为s[i-<span class="number">2</span>]的子序列，子序列个数为dp[i-<span class="number">1</span>][j]dp[i−<span class="number">1</span>][j]</span><br><span class="line"></span><br><span class="line">第二种情况：s[i-<span class="number">1</span>]与t[j-<span class="number">1</span>]相等</span><br><span class="line">第一种解释：如果新加入sub_s的这个字符与sub_t尾字符相匹配时，在没有增加这个字符的情况下，sub_t出现的次数是dp[i-<span class="number">1</span>][j], 现在增加了并且和sub_t尾字符相匹配，因此还要在这个基础上加上两者此前的状态下的次数，即dp[i-<span class="number">1</span>][j-<span class="number">1</span>]，因为相比此前，两者都多了同一个字符，与两者没有加上这个相同字符时情况是一样的。因此这种情况下总和是dp[i-<span class="number">1</span>][j]+dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化</span><br><span class="line">如果 j=<span class="number">0</span> 即 t[j]为空字符串，由于空字符串是任何字符串的子序列，因此对任意dp[i][<span class="number">0</span>]=<span class="number">1</span>；</span><br><span class="line">如果 i=<span class="number">0</span>即 s[i]为空字符串，t[j]为非空字符串，由于非空字符串不是空字符串的子序列，因此 dp[<span class="number">0</span>][j]=<span class="number">0</span>。<span class="comment">//这个java默认，可以不用管</span></span><br><span class="line"><span class="number">4.</span>从前到后遍历，从<span class="number">1</span>开始</span><br><span class="line"><span class="number">5.</span>推导数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个题为什么没有加<span class="number">1</span>操作，因为这个题是求出现的次数，如果你下一个字符是相等的，那么他们的出现次数是和之前一样的（我自己理解，不一定对）</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j]; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="583-两个字符串的删除操作-medium"><a href="#583-两个字符串的删除操作-medium" class="headerlink" title="583 两个字符串的删除操作 medium"></a>583 两个字符串的删除操作 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">和上一题的区别是，本题可以任意删除其中一个字符串</span><br><span class="line"><span class="number">1.</span>dp[i][j]：以i-<span class="number">1</span>为结尾的字符串word1，和以j-<span class="number">1</span>位结尾的字符串word2，想要达到相等，所需要删除元素的最少次数。</span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">情况<span class="number">1</span>：当word1[i-<span class="number">1</span>]与word2[j-<span class="number">1</span>]相同的时候</span><br><span class="line">可以理解为，相同，所以不用删，那就复用上一次的结果</span><br><span class="line">dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">情况<span class="number">2</span>：当word1[i-<span class="number">1</span>]与word2[j-<span class="number">1</span>]不相同的时候，有三种情况</span><br><span class="line">删word1[i - <span class="number">1</span>]，最少操作次数为dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">删word2[j - <span class="number">1</span>]，最少操作次数为dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">同时删word1[i - <span class="number">1</span>]和word2[j - <span class="number">1</span>]，操作的最少次数为dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>，因为每操作一次，就要加一，这里同时各操作了一次</span><br><span class="line">dp[i][j] = min(&#123;dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化</span><br><span class="line">dp[i][<span class="number">0</span>]：word2为空字符串，以i-<span class="number">1</span>为结尾的字符串word1要删除多少个元素，才能和word2相同呢，很明显dp[i][<span class="number">0</span>] = i。</span><br><span class="line">dp[<span class="number">0</span>][i]：word1为空字符串，以i-<span class="number">1</span>为结尾的字符串word2要删除多少个元素，才能和word1相同呢，很明显dp[<span class="number">0</span>][i] = i。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>从前到后遍历</span><br><span class="line"><span class="number">5.</span>推导数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word2.length(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>, Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离-hard-1"><a href="#72-编辑距离-hard-1" class="headerlink" title="72 编辑距离 hard"></a>72 编辑距离 hard</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">上一题是任何一个字符串都能删除，本题的话，可以进行删，改，增，或者不操作</span><br><span class="line">我看题解的时候，官方表达的意思是两个字符都能操作，但是实际题目意思，我感觉是只能操作<span class="number">1</span>，然后让其变成<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>dp[i][j] 表示以下标i-<span class="number">1</span>为结尾的字符串word1，和以下标j-<span class="number">1</span>为结尾的字符串word2，最近编辑距离为dp[i][j]。</span><br><span class="line"><span class="number">2.</span>确定递推公式，分为两个情况</span><br><span class="line">情况<span class="number">1</span>：word1[i-<span class="number">1</span>] == word2[j-<span class="number">1</span>]</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">情况<span class="number">2</span>：word1[i-<span class="number">1</span>] != word2[j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">操作<span class="number">1</span>：word1删除一个元素<span class="comment">//word1的[0,i-1]位置与word2的[0,j]位置的字符已匹配, 加1代表执行word1[i]的删除操作</span></span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line">操作<span class="number">2</span>：word2删除一个元素（相当于word1的插入操作）</span><br><span class="line">dp[i][j] = dp[i][j-<span class="number">1</span>]+<span class="number">1</span><span class="comment">//word1的[0,i]位置与word2的[0,j-1]位置的字符已匹配, 加1代表执行word1[i]的插入操作</span></span><br><span class="line">操作<span class="number">3</span>：word1替换操作</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span><span class="comment">//word1的[0,i-1]位置与word2的[0,j-1]位置的字符已匹配, 加1代表执行word1[i]-&gt;word2[j]的替换操作</span></span><br><span class="line">然后取他们的最小值，即</span><br><span class="line">dp[i][j] = min(&#123;dp[i-<span class="number">1</span>][j-<span class="number">1</span>], dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]&#125;) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化dp</span><br><span class="line">和上一题一样</span><br><span class="line">dp[i][<span class="number">0</span>]就应该是i，对word1里的元素全部做删除操作，即：dp[i][<span class="number">0</span>] = i;</span><br><span class="line">dp[<span class="number">0</span>][i]就应该是i，对word2里的元素全部做删除操作，即：dp[<span class="number">0</span>][i] = i;</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>遍历顺序</span><br><span class="line">从前到后</span><br><span class="line"><span class="number">5.</span>推导公式</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= word2.length(); i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.length()][word2.length()];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="647-回文子串-medium"><a href="#647-回文子串-medium" class="headerlink" title="647 回文子串 medium"></a>647 回文子串 medium</h3><p>本题遍历顺序不一样，注意看！！！本题是连续的字符串，而且是算个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">注意本题的dp数组是布尔类型   </span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为<span class="literal">true</span>，否则为<span class="literal">false</span></span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">分为两种情况</span><br><span class="line">情况<span class="number">1</span>：s[i]与s[j]相等</span><br><span class="line"><span class="number">2.1</span>下标i与j相同，同一个字符例如a，是回文子串</span><br><span class="line"><span class="number">2.2</span>下标i与j相差为<span class="number">1</span>，例如aa，也是回文子串</span><br><span class="line"><span class="number">2.</span>3i与j相差大于<span class="number">1</span>的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是i+<span class="number">1</span>与j-<span class="number">1</span>区间，这个区间是不是回文就看dp[i+<span class="number">1</span>][j-<span class="number">1</span>]是否为<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">情况<span class="number">1</span>：s[i]与s[j]不相等</span><br><span class="line">直接为<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>初始化dp</span><br><span class="line">一开始当然都是<span class="literal">false</span>啦，都没有匹配上</span><br><span class="line"><span class="number">4.</span>遍历顺序，不是按顺序，不是按顺序，不是按顺序！！！！</span><br><span class="line">我们可以看到<span class="number">2.3</span>这情况，根据dp[i + <span class="number">1</span>][j - <span class="number">1</span>]是否为<span class="literal">true</span>，在对dp[i][j]进行赋值<span class="literal">true</span>的，然后dp[i + <span class="number">1</span>][j - <span class="number">1</span>]在dp[i][j]左下角，也就是遍历顺序是下到上，左到右，可以理解为从斜左下角推导到右上角。</span><br><span class="line"><span class="number">5.</span>推导数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;<span class="comment">//从下到上遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;<span class="comment">//注意j不是从0开始，然后从左到右</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;<span class="comment">//j - i &lt;= 1包含2.1和2.2情况，dp[i + 1][j - 1]也就是2.3情况</span></span><br><span class="line">                    result++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;    </span><br><span class="line">         &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="516-最长回文子序列-medium"><a href="#516-最长回文子序列-medium" class="headerlink" title="516 最长回文子序列 medium"></a>516 最长回文子序列 medium</h3><p>注意本题是求子序的最长长度</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>dp[i][j]：字符串s在[i, j]范围内最长的回文子序列的长度为dp[i][j]。</span><br><span class="line"><span class="number">2.</span>确定递推公式</span><br><span class="line">s[i]与s[j]相同，那么dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;<span class="comment">//因为长度加2，注意里面是i+1和j-1的基础上，是字串的基础上加2</span></span><br><span class="line">s[i]与s[j]不相同（可以看卡哥的图），说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。</span><br><span class="line">加入s[j]的回文子序列长度为dp[i + <span class="number">1</span>][j]。加入s[i]的回文子序列长度为dp[i][j - <span class="number">1</span>]。那么dp[i][j]一定是取最大的，即：dp[i][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line"><span class="number">3.</span>初始化dp</span><br><span class="line">首先要理解定义，所以i和j相等，那长度肯定是<span class="number">1</span>的，因为他们就是指示一个字符</span><br><span class="line">dp[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="number">4.</span>遍历顺序，和上面一题一样，也是从左下角到右上角，也就是从下到上，从左到右</span><br><span class="line"><span class="number">5.</span>推导数组</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//return dp[0][s.length() - 1];也可以但是不好记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果找更大的元素，需要构建单调递减栈</span><br><span class="line">如果找更小的元素，需要构建单调递增栈</span><br></pre></td></tr></table></figure>
<h3 id="739-每日温度-medium"><a href="#739-每日温度-medium" class="headerlink" title="739 每日温度 medium"></a>739 每日温度 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调栈方法,通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</span></span><br><span class="line">分为三种情况</span><br><span class="line">栈里面是存储数组的下标，而不是值</span><br><span class="line"><span class="number">1.</span>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</span><br><span class="line">把T[i]的下标入栈</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</span><br><span class="line">把T[i]的下标入栈</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</span><br><span class="line">计算距离放入result中，将栈顶元素弹出。</span><br><span class="line">等到不符合条件了（也就是栈里面的元素下标已经大于当前T[i]），那么这时候就把T[i]入栈</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在LinkedList中，poll方法是检测并删除头元素，peek是单纯检索头元素（类似于栈，头元素就是最后加进去的那个元素）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i);<span class="comment">//合并情况1和2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;<span class="comment">//情况3，注意栈不能为空</span></span><br><span class="line">                    result[stack.peek()] =  i - stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力循环，找到第一个大的就break，但是复杂度很高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; temperatures.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (temperatures[j] &gt; temperatures[i]) &#123;</span><br><span class="line">                    result[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="496-下一个更大元素1-easy"><a href="#496-下一个更大元素1-easy" class="headerlink" title="496 下一个更大元素1 easy"></a>496 下一个更大元素1 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单调栈，和上一题的思路是差不多的，关键在于，这里是两个数组</span></span><br><span class="line"></span><br><span class="line">首先我们用一个map把数组<span class="number">1</span>的&lt;数值，下标&gt;存进去</span><br><span class="line"></span><br><span class="line">然后操作数组<span class="number">2</span>，数组<span class="number">2</span>的操作逻辑也是</span><br><span class="line"><span class="number">1.</span>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</span><br><span class="line">把T[i]的下标入栈</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</span><br><span class="line">把T[i]的下标入栈</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</span><br><span class="line">这时候可以找到右边第一个比自己大的元素</span><br><span class="line">判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。</span><br><span class="line">然后出栈</span><br><span class="line"></span><br><span class="line">当不满足大于栈顶元素，就把当前元素入栈</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            map.put(nums1[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums2[i] &lt;= nums2[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (map.containsKey(nums2[stack.peek()])) &#123;</span><br><span class="line">                        <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> map.get(nums2[stack.peek()]);</span><br><span class="line">                        result[index] = nums2[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力出奇迹</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> j + <span class="number">1</span>; x &lt; nums2.length;x++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums2[x] &gt; nums1[i]) &#123;</span><br><span class="line">                            result[i] = nums2[x];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="503-下一个更大元素2-medium"><a href="#503-下一个更大元素2-medium" class="headerlink" title="503 下一个更大元素2 medium"></a>503 下一个更大元素2 medium</h3><p>本题关键在于 如何处理循环数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理循环数组，太秒了，循环的时候，把数组变成两倍的长度，然后用%可以走两遍数组</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">2</span> * nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i % nums.length] &lt;= nums[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i % nums.length);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % nums.length] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">                    result[stack.peek()] = nums[i % nums.length];<span class="comment">//或者用poll，那么pop就省略了</span></span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i % nums.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力出奇迹，找完右边再重新找左边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(result, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                    result[i] = nums[j];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; i; x++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[x] &gt; nums[i]) &#123;</span><br><span class="line">                        result[i] = nums[x];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[nums.length - <span class="number">1</span>]) &#123;</span><br><span class="line">                result[nums.length - <span class="number">1</span>] = nums[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="42-接雨水-hard"><a href="#42-接雨水-hard" class="headerlink" title="42 接雨水 hard"></a>42 接雨水 hard</h3><p>高频率题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">单调栈做法</span><br><span class="line">单调递减栈</span><br><span class="line"></span><br><span class="line">注意用单调栈的做法计算面积和双指针略有不同,双指针直接就是先找到最左边最高，最右边最高，然后用他们比较小的那个减去当前高度就是体积（因为当前高度的宽是<span class="number">1</span>，不用长*宽了）</span><br><span class="line"></span><br><span class="line">栈：先进去的是栈底，</span><br><span class="line">当前元素小于等于栈顶元素，那么就入栈</span><br><span class="line"></span><br><span class="line">如果大于了栈顶元素，这时候就可以找出三个元素</span><br><span class="line">right下标就是当前i小标</span><br><span class="line">mid就是栈顶下标，用了之后要取出来，为什么要取出来，因为用过了。</span><br><span class="line">left就是下一个栈顶下标，这里不用取出来，因为下一次还要用</span><br><span class="line">h是高度，右边下标的对应的值（是指，不是下标数）和左边小标对应的值找到较小那个-当前i的高度</span><br><span class="line">w是宽度，用右边下标-左边下标-<span class="number">1</span>（-<span class="number">1</span>是因为算两个栈中间的区域长度，<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>，比如<span class="number">0</span>和<span class="number">3</span>，中间的长度就是<span class="number">2</span>,<span class="number">3</span>-<span class="number">0</span>-<span class="number">1</span>=<span class="number">2</span>）</span><br><span class="line">然后h*w即可</span><br><span class="line">这里为什么和双指针那个算法不一样，其实我认为是因为单调栈这样出栈顺序，不是他的左边最高和右边最高，这样出栈是单纯能算出体积</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt;= height[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> stack.poll();<span class="comment">//拿到后要取出</span></span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty()) &#123;<span class="comment">//注意这里，有点不一样，还需要判断一次</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[right], height[left]) - height[mid];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> right - left - <span class="number">1</span>;</span><br><span class="line">                        sum += h * w;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本题用双指针解法（但是力扣官方是写暴力解法），这个比较容易懂</span><br><span class="line"></span><br><span class="line">首先清楚，第一根柱子和最后一根柱子，是不接雨水的，所以遍历的时候跳过这两个</span><br><span class="line"></span><br><span class="line">然后要清楚，雨水是如何计算的</span><br><span class="line">对于每一列，我们都要找出他左边最高的一个柱子（包含第一格），同时找出右边最高的柱子（包含最后一格）</span><br><span class="line">然后选出他们两个高度之间小的那个，减去本列的高度，就是雨水的体积，因为长度都是<span class="number">1</span>，所以<span class="number">1</span>*高度就是雨水体积</span><br><span class="line"></span><br><span class="line">那么我们只要找到每一格的高度，就可以完成任务</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;<span class="comment">//第一格和最后一格不算</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">lheight</span> <span class="operator">=</span> height[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">rheight</span> <span class="operator">=</span> height[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; i; l++) &#123;<span class="comment">//找到本列左边最高的柱子，包含第一格</span></span><br><span class="line">                <span class="keyword">if</span> (height[l] &gt; lheight) lheight = height[l];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> i + <span class="number">1</span>; r &lt; height.length; r++) &#123;<span class="comment">//找到本列右边最高的柱子，包含最后一格</span></span><br><span class="line">                <span class="keyword">if</span> (height[r] &gt; rheight) rheight = height[r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(lheight, rheight) - height[i];<span class="comment">//雨水取决于短板</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (high &gt; <span class="number">0</span>) sum += high;<span class="comment">//其实不用high大于0也是可以的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="84-柱状图中最大的矩形-hard"><a href="#84-柱状图中最大的矩形-hard" class="headerlink" title="84 柱状图中最大的矩形 hard"></a>84 柱状图中最大的矩形 hard</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">找每个柱子左右侧的第一个高度值小于该柱子的柱子，注意和上一题的区别</span><br><span class="line"></span><br><span class="line">单调栈：栈顶到栈底：从大到小（每插入一个新的小数值时，都要弹出先前的大数值）</span><br><span class="line">栈顶，栈顶的下一个元素，即将入栈的元素：这三个元素组成了最大面积的高度和宽度</span><br><span class="line">情况一：当前遍历的元素heights[i]大于栈顶元素的情况</span><br><span class="line">情况二：当前遍历的元素heights[i]等于栈顶元素的情况</span><br><span class="line">情况三：当前遍历的元素heights[i]小于栈顶元素的情况</span><br><span class="line"></span><br><span class="line">这里是找到左右侧高度小于当前的，所以用单调递增栈</span><br><span class="line"></span><br><span class="line">当前高度大于等于栈顶，入栈</span><br><span class="line">当前高度小于栈顶</span><br><span class="line"></span><br><span class="line">mid高度栈顶下标，用了需要取出来</span><br><span class="line">right就是当前元素下标</span><br><span class="line">left就是栈顶下标（之前取出了一个mid，这个是新栈顶）</span><br><span class="line"></span><br><span class="line">面积就是 (right-left-<span class="number">1</span>)*mid</span><br><span class="line">减去<span class="number">1</span>可以继续看下面的图理解</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] newheights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            newheights[i + <span class="number">1</span>] = heights[i];</span><br><span class="line">        &#125;</span><br><span class="line">        heights = newheights;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt;= heights[stack.peek()]) &#123;</span><br><span class="line">                stack.push(i);<span class="comment">//情况1和2</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[i] &lt; heights[stack.peek()]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> heights[stack.poll()];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> right - left - <span class="number">1</span>;</span><br><span class="line">                    result = Math.max(result, width * mid);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>借用别人画的图来理解如何计算面积<br>比如计算5（下标是2）的最大面积<br>左边小的是1（下标1），右边小的是2（下标4）<br>面积就是（4-1-1）* 5&#x3D;10</p>
<p>比如计算6（下标是3）的最大面积<br>左边小的是5（下标2），右边小的是2（下标4）<br>面积就是（4-2-1）* 6&#x3D;6</p>
<p><img src="/images/leetcode-java/84.png"></p>
<h2 id="hot100"><a href="#hot100" class="headerlink" title="hot100"></a>hot100</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3 无重复字符的最长子串"></a>3 无重复字符的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用一个map来保存字符</span><br><span class="line">双指针的做法</span><br><span class="line">一个start 一个end</span><br><span class="line">如果发现重复了（map中），需要重新找到start的位置，新start的位置需要这个字符在map的位置然后加<span class="number">1</span>，但是start不能往回走（因为单纯加<span class="number">1</span>的话，可能会回退，因为字符可能在最开始的位置），所以要在start和 这个字符在map的数字加<span class="number">1</span>比较，确定新start的位置</span><br><span class="line">长度就是end-start+<span class="number">1</span>,在过程中记录即可，然后把字符加入到map中</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), ans = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>, start = <span class="number">0</span>; end &lt; n; end++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">alpha</span> <span class="operator">=</span> s.charAt(end);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(alpha)) &#123;</span><br><span class="line">                start = Math.max(map.get(alpha) + <span class="number">1</span>, start);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ans = Math.max(ans, end - start + <span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(end), end);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-最长回文子串-medium"><a href="#5-最长回文子串-medium" class="headerlink" title="5 最长回文子串 medium"></a>5 最长回文子串 medium</h3><p>思路挺简单的，仔细阅读下代码，用的是暴力法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; len &amp;&amp; valid(s, i, j)) &#123;<span class="comment">//注意这里是把整个s带进去</span></span><br><span class="line">                    len = j-i+<span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++,j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-盛水最多的容器-medium"><a href="#11-盛水最多的容器-medium" class="headerlink" title="11 盛水最多的容器 medium"></a>11 盛水最多的容器 medium</h3><p>需要和42 84一起看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">本题的思路是用双指针，一个最左边，一个最右边</span></span><br><span class="line"><span class="comment">每次都是固定长的那根，然后计算面积（较短的那根*距离）</span></span><br><span class="line"><span class="comment">然后每次移动比较短的那根</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> Math.min(height[i], height[j]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> j - i;</span><br><span class="line">                result = Math.max(result, high * width);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="128-最长连续序列-medium"><a href="#128-最长连续序列-medium" class="headerlink" title="128 最长连续序列 medium"></a>128 最长连续序列 medium</h3><p>注意这个题，是指内部可以组成的连续的序列，比如1,2,3,4,5，累加1这种，但是，不是指必须他们在位置上连续，他们一开始是打乱的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用set，因为数组是可能中间有连续一样的数字，set可以用来保留一个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            set.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i - <span class="number">1</span>)) &#123;<span class="comment">//只有当num-1不存在时，才开始向后遍历，如果没有这句话，会超时的</span></span><br><span class="line">                <span class="keyword">while</span> (set.contains(i)) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                    i++;<span class="comment">//在这里进行++，因为连续嘛，比前一个数大于1就可以连续</span></span><br><span class="line">                &#125;</span><br><span class="line">                result = Math.max(result, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="146-LRU缓存-medium"><a href="#146-LRU缓存-medium" class="headerlink" title="146 LRU缓存 medium"></a>146 LRU缓存 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashMap是尾插</span><br><span class="line"></span><br><span class="line">LinkedHashMap和HashMap不一样，HashMap是无序的，前者是有序的，所以不能用hashmap来做这个题</span><br><span class="line"><span class="number">1.</span>查询操作</span><br><span class="line">存在的话，先对他进行最近操作处理，然后返回值</span><br><span class="line">否则返回-<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>插入操作</span><br><span class="line">如果这个key本身存在的话，先对他进行最近操作处理，然后把value更新，并且中断操作</span><br><span class="line">如果key不存在，先判断插入的时候，是否满了，先删除头部的老节点，然后再插入</span><br><span class="line"></span><br><span class="line">最近操作处理</span><br><span class="line">先存这个value，然后删除key，然后再重新put即可</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span> cache.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            makeRecently(key);</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//这个很重要，不然不能通过，否则会往下走</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cache.size() == <span class="built_in">this</span>.capacity) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldKey</span> <span class="operator">=</span> cache.keySet().iterator().next();<span class="comment">//学习这个写法</span></span><br><span class="line">            cache.remove(oldKey);</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(key, value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="152-乘积最大子数组-medium"><a href="#152-乘积最大子数组-medium" class="headerlink" title="152 乘积最大子数组 medium"></a>152 乘积最大子数组 medium</h3><p>对比53题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这题最大的不同点在于需要维护两个dp数组，一个最大的，一个最小的</span><br><span class="line">一般我们都是维护一个最大的即可，这里说下如果不维护一个最小的</span><br><span class="line">比如[-<span class="number">2</span>,<span class="number">3</span>,-<span class="number">4</span>]</span><br><span class="line">dp[<span class="number">0</span>] = -<span class="number">2</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">3</span></span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line">但是，其实正确答案是<span class="number">24</span>，因为可能中间是负数，后面是负数，就可以变成正数，但是单纯用max的话，会忽略掉中间负数的情况</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dpmax = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span>[] dpmin = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="comment">//Arrays.fill(dp, 1);</span></span><br><span class="line">        dpmax[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dpmin[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            dpmax[i] = Math.max(Math.max(nums[i] * dpmax[i - <span class="number">1</span>], nums[i] * dpmin[i - <span class="number">1</span>]), nums[i]);</span><br><span class="line">            dpmin[i] = Math.min(Math.min(nums[i] * dpmax[i - <span class="number">1</span>], nums[i] * dpmin[i - <span class="number">1</span>]), nums[i]);</span><br><span class="line">            result = Math.max(result, dpmax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="136-只出现一次的数字-easy"><a href="#136-只出现一次的数字-easy" class="headerlink" title="136 只出现一次的数字 easy"></a>136 只出现一次的数字 easy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">异或运算</span></span><br><span class="line"><span class="comment">十进制下相同数字异或结果为0，数字a与0异或结果仍为原来的数字a。</span></span><br><span class="line"><span class="comment">还有就是异或运算支持结合律，所以你的数组顺序是无所谓的</span></span><br><span class="line"><span class="comment">计算完后剩下的就是出现那一个的数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">single</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个不符合题目不用额外空间的要求，但是能pass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(i) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="283-移动零-easy"><a href="#283-移动零-easy" class="headerlink" title="283 移动零 easy"></a>283 移动零 easy</h3><p>注意题目要在原数组上操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。</span></span><br><span class="line"><span class="comment">其实第一次看这个做法，还挺奇妙的，只用了一次遍历</span></span><br><span class="line"><span class="comment">可以理解为，left会指向下一个0，然后等着right找到不是0，进行交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;<span class="comment">////当前元素!=0，就把其交换到左边，等于0的会交换到右边</span></span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种是补0，好像和意思不太对，但是也能做</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[slow] = nums[i];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> slow; j &lt; nums.length; j++) &#123;</span><br><span class="line">            nums[j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="169-多数元素-easy"><a href="#169-多数元素-easy" class="headerlink" title="169 多数元素 easy"></a>169 多数元素 easy</h3><p>统计次数，用map</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(i) &gt; nums.length / <span class="number">2</span>) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="234-回文链表-easy"><a href="#234-回文链表-easy" class="headerlink" title="234 回文链表 easy"></a>234 回文链表 easy</h3><p>自己写的，看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            s.append(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> s.toString();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="448-找到所有数组中消失的数字-easy"><a href="#448-找到所有数组中消失的数字-easy" class="headerlink" title="448 找到所有数组中消失的数字 easy"></a>448 找到所有数组中消失的数字 easy</h3><p>用set来保存数，然后遍历1~n，看看哪个数不在就添加</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(i + <span class="number">1</span>)) &#123;</span><br><span class="line">                list.add(i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="287-寻找重复数-medium"><a href="#287-寻找重复数-medium" class="headerlink" title="287 寻找重复数 medium"></a>287 寻找重复数 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不过不满足题目的要求</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (map.get(i) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                result = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="560-和为-K-的子数组-medium"><a href="#560-和为-K-的子数组-medium" class="headerlink" title="560 和为 K 的子数组 medium"></a>560 和为 K 的子数组 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个解法很少见，先找到每个下标，然后从这个下标开始倒着加，如果中途满足k，就计数</span><br><span class="line">当然顺着加也可以（注释中的语句），即先固定左边界，然后枚举右边界哈，</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>; start &lt; nums.length; start++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> start; end &gt;= <span class="number">0</span>; end--) &#123;<span class="comment">//for (int end = start; end &lt; nums.length; end++)也可以，这个我觉得更好理解，倒着来太麻烦   </span></span><br><span class="line">                sum += nums[end];</span><br><span class="line">                <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前缀和解法，前缀和就是前i个数的和，left和right区间内的前缀和相减如果等于k，就说明中间有连续数组是为k</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] presum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        presum[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//注意第一个不算，置为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            presum[i + <span class="number">1</span>] = presum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span> ; j &lt;= nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (presum[j] - presum[i] == k) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="581-最短无序连续子数组-medium"><a href="#581-最短无序连续子数组-medium" class="headerlink" title="581 最短无序连续子数组 medium"></a>581 最短无序连续子数组 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实就是新建一个拍好序的数组，然后从左边遍历看第一个不正确的数，记录left</span><br><span class="line">然后从右边遍历第一个不正确的数，记录right。这里需要注意，不能用sortnum = num，因为这样操作是浅拷贝，如果你把sortnum排序了，那么num也会变的！！！！</span><br><span class="line">比如[<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">15</span>]，最终记录left为<span class="number">1</span>，right为<span class="number">5</span>，然后务必+<span class="number">1</span>才是长度</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> sortnum[] = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sortnum[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Arrays.sort(sortnum);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; nums.length &amp;&amp; nums[left] == sortnum[left]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right &gt; <span class="number">0</span> &amp;&amp; nums[right] == sortnum[right]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">                 </span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="461-汉明距离-easy"><a href="#461-汉明距离-easy" class="headerlink" title="461 汉明距离 easy"></a>461 汉明距离 easy</h3><p>单纯计算二进制，然后比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span> || y != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> != y % <span class="number">2</span>) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">            y = y / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-两数相加-medium"><a href="#2-两数相加-medium" class="headerlink" title="2 两数相加 medium"></a>2 两数相加 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个题的关键是遇到两位数的和，需要把十位上的数，累加到下一次中，举个例子</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br><span class="line">他们的和是<span class="number">7</span>,<span class="number">10</span>,<span class="number">10</span>，第二个数已经超过了<span class="number">10</span>，把<span class="number">0</span>保留，<span class="number">1</span>留在下一个中，就是<span class="number">7</span>,<span class="number">0</span>,<span class="number">11</span>，然后<span class="number">11</span>又超过了两位数，所以把<span class="number">1</span>留下，最后是<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="comment">//ListNode pre = dump;</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> l1 == <span class="literal">null</span> ? <span class="number">0</span> : l1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> l2 == <span class="literal">null</span> ? <span class="number">0</span> : l2.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            sum = sum % <span class="number">10</span>;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum);<span class="comment">//这里前面不需要再声明ListNode</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;<span class="comment">//处理最后遗留的carry，因为最大也就是相加之和为18，所以只能是1</span></span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="338-比特位计数-easy"><a href="#338-比特位计数-easy" class="headerlink" title="338 比特位计数 easy"></a>338 比特位计数 easy</h3><p>很简单，计算二进制即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] countBits(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            result[i] = count(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;<span class="comment">//注意条件是x != 0</span></span><br><span class="line">            <span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            x = x / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="23-合并K个升序链表-hard"><a href="#23-合并K个升序链表-hard" class="headerlink" title="23 合并K个升序链表 hard"></a>23 合并K个升序链表 hard</h3><p>思想参考21题，放在本题就是合并两两链表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lists.length; i++) &#123;</span><br><span class="line">            dump = mergetwoLists(dump, lists[i]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergetwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="comment">//这个可要可不要</span></span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        if (list1 == null || list2 == null) &#123;</span></span><br><span class="line"><span class="comment">            return list1 == null ? list2 : list1;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> dump.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="238-除自身以外数组的乘积-medium"><a href="#238-除自身以外数组的乘积-medium" class="headerlink" title="238 除自身以外数组的乘积 medium"></a>238 除自身以外数组的乘积 medium</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">先算左侧数字累积，也就是当前元素之前元素的累积（不含当前元素）</span><br><span class="line">然后倒过来算累计，也就是当前元素之后元素的累积，在左侧数字累积的基础上相乘，这样就可以算出除自身外的累积</span><br><span class="line">总体思想也就是左侧数字的累积乘以右侧数字的累积，也就是除了这个数的累积。</span><br><span class="line"></span><br><span class="line">不能用暴力，否则超时</span><br><span class="line"></span><br><span class="line">比如[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">左侧数字累积是[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">算完之后用一个R来保存右侧的累积，初始化R为<span class="number">1</span></span><br><span class="line">虽然在第一轮中，<span class="number">4</span>这个位置的左边已经全部算好了，但是我们需要改变R的累积来为<span class="number">3</span>这个数字服务，所以倒着的时候还是先从最后一个数开始</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">Right</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//代表右侧数字的累积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = Right * result[i];</span><br><span class="line">            Right = Right * nums[i];<span class="comment">//累积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="148-排序链表-medium"><a href="#148-排序链表-medium" class="headerlink" title="148 排序链表 medium"></a>148 排序链表 medium</h3><p>和下一个方法一样的思路，但是这个方法可能好理解一点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归并排序，可以看下面一个图</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">切割环节：</span></span><br><span class="line"><span class="comment">使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。</span></span><br><span class="line"><span class="comment">找到中点 slow 后，执行 slow.next = null 将链表切断</span></span><br><span class="line"><span class="comment">递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 </span></span><br><span class="line"><span class="comment">cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">merge环节：</span></span><br><span class="line"><span class="comment">就是21题源代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果下面写成fast = head</span></span><br><span class="line"><span class="comment">传入head只有两个节点的时候，slow会指向第二个节点，此时left : head-&gt;node1-&gt;null ; right:null; 然后在ListNode left = sortList(head);这一步会发生stackoverflow</span></span><br><span class="line"><span class="comment">但是如果要用fast = head</span></span><br><span class="line"><span class="comment">需要把while写成while (fast != null &amp;&amp; fast.next != null &amp;&amp; fast.next.next != null)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  需要找到链表中间节点的前一个节点（876类似，但是又不同于876）</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;<span class="comment">//不能写成head，但是可以写成head.next，但是建议还是写成next.next，和下面对应</span></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        slow.next=<span class="literal">null</span>;<span class="comment">//切割出来</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(sortList(head), sortList(head2));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;<span class="comment">//21题原题代码</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 :list1;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode-java/148.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">归并排序方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 1、递归结束条件</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、找到链表中间节点并断开链表 &amp; 递归下探</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">midNode</span> <span class="operator">=</span> middleNode(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">rightHead</span> <span class="operator">=</span> midNode.next;</span><br><span class="line">        midNode.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);<span class="comment">//递归</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(rightHead);<span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、当前层业务操作（合并有序链表）</span></span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  需要找到链表中间节点的前一个节点（876类似，但是又不同于876）</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;<span class="comment">//不能写成head，但是可以写成head.next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;<span class="comment">//21题原代码，合并两个升序链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 :list1;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自己写的解法，思路很简单，先用Arraylist来记录数字，然后排序，这里注意是用Collections.sort(list);进行排序，而不是Arrays.sort(list)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不过这个不太符合题目的要求，时间和空间复杂度会很高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : list) &#123;</span><br><span class="line">            temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(x);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="200-岛屿数量-medium"><a href="#200-岛屿数量-medium" class="headerlink" title="200 岛屿数量 medium"></a>200 岛屿数量 medium</h3><p>对比695</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">和695非常类似，一开始我用695的方法，在判断上是只要面积大于0就加1，但是感觉有点冗余，下面是去掉了冗余的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> cur_i, <span class="type">int</span> cur_j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur_i &lt; <span class="number">0</span> || cur_j &lt;  <span class="number">0</span> || cur_i == grid.length || cur_j == grid[<span class="number">0</span>].length || grid[cur_i][cur_j] != <span class="string">&#x27;1&#x27;</span>)  &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[cur_i][cur_j] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//这个很重要，把走过的格子置为0，不然会一直重复dfs</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] next_cur_i = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] next_cur_j = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; <span class="number">4</span>; index++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next_i</span> <span class="operator">=</span> cur_i + next_cur_i[index];</span><br><span class="line">            <span class="type">int</span> <span class="variable">next_j</span> <span class="operator">=</span> cur_j + next_cur_j[index];</span><br><span class="line">            dfs(grid, next_i, next_j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="208-实现Trie-前缀树-medium"><a href="#208-实现Trie-前缀树-medium" class="headerlink" title="208 实现Trie(前缀树) medium"></a>208 实现Trie(前缀树) medium</h3><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/trie-tree-de-shi-xian-gua-he-chu-xue-zhe-by-huwt/">具体看解释看</a>，前缀树的用处：一次建树，多次查询</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> isEnd;<span class="comment">//该节点是否是一个串的结束</span></span><br><span class="line">        TrieNode[] next;<span class="comment">//指向孩子节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;<span class="comment">//初始化</span></span><br><span class="line">            isEnd = <span class="literal">false</span>;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];<span class="comment">//字母映射表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;<span class="comment">//指向根，后面每次操作，都是从根开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;<span class="comment">//插入操作</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//从根开始查</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;<span class="comment">//如果没有的话，</span></span><br><span class="line">                node.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>(); <span class="comment">//就开辟一个新的节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next[c - <span class="string">&#x27;a&#x27;</span>];<span class="comment">//插入完之后指向下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;<span class="comment">//插入完之后，设置尾巴为true，表示这个词的终点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;<span class="comment">//查找操作</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//从根开始查</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            node =  node.next[c - <span class="string">&#x27;a&#x27;</span>];<span class="comment">//移动下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;<span class="comment">//如果空的话直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node.isEnd;<span class="comment">//注意因为这个是查找整个单词的操作，所以是返回尾巴的isend看看是不是为true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;<span class="comment">//查找前缀</span></span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;<span class="comment">//从根开始查</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix.toCharArray()) &#123;</span><br><span class="line">            node =  node.next[c - <span class="string">&#x27;a&#x27;</span>];<span class="comment">//移动下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;<span class="comment">//如果空就直接返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//注意这里只是查找前缀，所以如果全部都找完了，说明没有false，那么最终就是返回true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="额外练习"><a href="#额外练习" class="headerlink" title="额外练习"></a>额外练习</h1><h2 id="21-合并两个有序链表-easy"><a href="#21-合并两个有序链表-easy" class="headerlink" title="21 合并两个有序链表 easy"></a>21 合并两个有序链表 easy</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">null</span> &amp;&amp; list2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list2.val &gt;= list1.val) &#123;</span><br><span class="line">                cur.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2.val &lt; list1.val) &#123;</span><br><span class="line">                cur.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;<span class="comment">//判断完记得移到next</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="先递增再递减数组找最大值"><a href="#先递增再递减数组找最大值" class="headerlink" title="先递增再递减数组找最大值"></a>先递增再递减数组找最大值</h2><p>别人面试碰到的题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(1)如果数组先增大再减小，峰值就是最大值。</span></span><br><span class="line"><span class="comment">(2)如果数组单调递增，最后一个元素就是最大值。</span></span><br><span class="line"><span class="comment">(3)如果数组单调递减，第一个元素就是最大值。</span></span><br><span class="line"><span class="comment">(4)如果数组全部都一样，任何一个元素都是答案，更极端地，如果数组只有一个元素，那么这唯一的元素就是答案。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">作者：analanxingde</span></span><br><span class="line"><span class="comment">链接：https://www.jianshu.com/p/fa328c8a323c</span></span><br><span class="line"><span class="comment">来源：简书</span></span><br><span class="line"><span class="comment">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">FindMax</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;            <span class="comment">//如果数组大小为0，则返回错误</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MP</span> <span class="operator">=</span>  (begin + end)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(MP &gt; <span class="number">0</span> &amp;&amp; MP &lt; m -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[MP] &gt; A[MP+<span class="number">1</span>] &amp;&amp; A[MP] &gt; A[MP-<span class="number">1</span>])&#123;  <span class="comment">//如果符合条件就返回此值</span></span><br><span class="line">                   <span class="keyword">return</span> MP;        </span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (A[MP] &lt; A[MP+<span class="number">1</span>])&#123;            <span class="comment">//在递增段</span></span><br><span class="line">                begin = MP+ <span class="number">1</span>;</span><br><span class="line">                MP= begin + (end - begin)/<span class="number">2</span>;</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;                                 <span class="comment">//在递减段</span></span><br><span class="line">                end = MP- <span class="number">1</span>;</span><br><span class="line">                MP= begin + (end - begin)/<span class="number">2</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(MP == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果数组是完全递减的，则第一个值就是最大值</span></span><br><span class="line">    <span class="keyword">if</span>(MP == m-<span class="number">1</span>) <span class="keyword">return</span> m-<span class="number">1</span>; <span class="comment">//如果数组是完全递增的，则最后一个值为最大值</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestConsecutive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt;set=<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();<span class="comment">//HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;<span class="comment">//将元素加入集合中</span></span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>,max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i-<span class="number">1</span>))&#123;<span class="comment">//进行判断如果有比当前元素小的元素就直接跳过不在进行长度增长。如果不进行该操作时间会超限</span></span><br><span class="line">                <span class="keyword">while</span>(set.contains(i)) &#123;</span><br><span class="line">                    len+=<span class="number">1</span>;</span><br><span class="line">                    i+=<span class="number">1</span>;<span class="comment">//取最大连续序列，就一直＋1再判断是否在序列中</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(len&gt;max) &#123;</span><br><span class="line">                    max=len;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：cranky-gausshdx</span><br><span class="line">链接：https:<span class="comment">//leetcode.cn/problems/longest-consecutive-sequence/solution/by-cranky-gausshdx-jm5b/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<h2 id="14-最长公共前缀-easy"><a href="#14-最长公共前缀-easy" class="headerlink" title="14 最长公共前缀 easy"></a>14 最长公共前缀 easy</h2><p>注意这个题只是看前缀，而不是共同字符，所以只在最前面开始搜就行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> strs[<span class="number">0</span>];<span class="comment">//把第一个字符串拿过来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;<span class="comment">//然后从第二个字符串开始比较</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//为什么在这里写而不是下面写？ 下面有解释</span></span><br><span class="line">            <span class="keyword">for</span>( ;j &lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            ans = ans.substring(<span class="number">0</span>, j);<span class="comment">//因为是前缀，所以肯定是从第一个开始，至于到了哪个是共同，就是看j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>错误题解，用来解释的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">但是，如果下面这样写的话</span></span><br><span class="line"><span class="comment">[&quot;ab&quot;, &quot;a&quot;]的输出结果是ab，这是错误的，正确结果应该是a，因为第二个字符串长度为1，所以只进行了一次循环后，就不循环了，也就是b这个数都无法比较，所以最终无法进入if语句</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestCommonPrefix</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ;j &lt; ans.length() &amp;&amp; j &lt; strs[i].length(); j++) &#123;<span class="comment">//如果在这里写，那么ans.sub就要在if里面写，因为是局部变量</span></span><br><span class="line">                <span class="keyword">if</span> (ans.charAt(j) != strs[i].charAt(j)) &#123;</span><br><span class="line">                    ans = ans.substring(<span class="number">0</span>, j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="83-删除排序链表中的重复数字-easy"><a href="#83-删除排序链表中的重复数字-easy" class="headerlink" title="83 删除排序链表中的重复数字 easy"></a>83 删除排序链表中的重复数字 easy</h2><p>其实很简单，为什么自己一开始想的很复杂呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dump.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val == cur.next.val) &#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="88-合并两个有序数组-easy-1"><a href="#88-合并两个有序数组-easy-1" class="headerlink" title="88 合并两个有序数组 easy"></a>88 合并两个有序数组 easy</h2><p>在尾巴处进行修改，需要注意的是，本题的nums1大小是m+n，然后最后返回的数组也是nums1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums2[j] &gt; nums1[i]) &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) nums1[k--] = nums2[j--];<span class="comment">//对剩下的nums2进行操作，不需要对nums1进行操作了，因为本质上是原地复制，无意义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>小陈同学
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/" title="LeetCode-JAVA">https://chenwingsing.github.io/2021/09/20/LeetCode-JAVA/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Leetcode/" rel="tag"># Leetcode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/04/02/Pytorch-Tips/" rel="prev" title="Pytorch Tips">
                  <i class="fa fa-chevron-left"></i> Pytorch Tips
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/04/Github%E7%AC%94%E8%AE%B0/" rel="next" title="Github笔记">
                  Github笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">小陈同学</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://unpkg.com/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://unpkg.com/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  





</body>
</html>
